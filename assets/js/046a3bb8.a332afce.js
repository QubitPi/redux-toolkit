"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["7674"],{4470:function(e,n,t){t.r(n),t.d(n,{default:()=>p,frontMatter:()=>a,metadata:()=>r,assets:()=>d,toc:()=>u,contentTitle:()=>s});var r=JSON.parse('{"id":"api/combineSlices","title":"combineSlices","description":"&nbsp;","source":"@site/../docs/api/combineSlices.mdx","sourceDirName":"api","slug":"/api/combineSlices","permalink":"/api/combineSlices","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1754248441000,"frontMatter":{"id":"combineSlices","title":"combineSlices","sidebar_label":"combineSlices","hide_title":true},"sidebar":"docs","previous":{"title":"createEntityAdapter","permalink":"/api/createEntityAdapter"},"next":{"title":"createSelector","permalink":"/api/createSelector"}}'),i=t("4246"),c=t("980"),l=t("8049"),o=t("5181");let a={id:"combineSlices",title:"combineSlices",sidebar_label:"combineSlices",hide_title:!0},s="combineSlices",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"<code>withLazyLoadedSlices</code>",id:"withlazyloadedslices",level:3},{value:"<code>inject</code>",id:"inject",level:3},{value:"Reducer replacement",id:"reducer-replacement",level:4},{value:"<code>selector</code>",id:"selector",level:3},{value:"Nested combined reducer",id:"nested-combined-reducer",level:4},{value:"<code>original</code>",id:"original",level:4},{value:"Slice integration",id:"slice-integration",level:2},{value:"<code>injectInto</code>",id:"injectinto",level:3},{value:"<code>selectors</code> / <code>getSelectors</code>",id:"selectors--getselectors",level:3}];function h(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,c.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"combineslices",children:(0,i.jsx)(n.code,{children:"combineSlices"})})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"A function that combines slices into a single reducer, and enables injection of more reducers after initialisation."}),"\n",(0,i.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,i.jsx)(l.Z,{value:"ts",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n"})})}),(0,i.jsx)(l.Z,{value:"js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// file: slices/index.js\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n\n// file: store.js\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n"})})})]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:['A "slice" for ',(0,i.jsx)(n.code,{children:"combineSlices"})," is typically created with ",(0,i.jsx)(n.a,{href:"/api/createSlice",children:(0,i.jsx)(n.code,{children:"createSlice"})}),',\nbut can be any "slice-like" object with ',(0,i.jsx)(n.code,{children:"reducerPath"})," and ",(0,i.jsx)(n.code,{children:"reducer"})," properties (meaning RTK Query ",(0,i.jsx)(n.a,{href:"/rtk-query/api/created-api/overview",children:"API instances"})," are also compatible)."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const withUserReducer = rootReducer.inject({\n  reducerPath: 'user',\n  reducer: userReducer,\n})\n\nconst withApiReducer = rootReducer.inject(fooApi)\n"})}),(0,i.jsxs)(n.p,{children:["For simplicity, this ",(0,i.jsx)(n.code,{children:"{ reducerPath, reducer }"}),' shape will be described in these docs as a "slice".']})]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"combineSlices"})," accepts a set of slices and/or reducer map objects, and combines them into a single reducer."]}),"\n",(0,i.jsxs)(n.p,{children:["Slices will be mounted at their ",(0,i.jsx)(n.code,{children:"reducerPath"}),", and items from reducer map objects will be mounted under their respective key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const rootReducer = combineSlices(counterSlice, baseApi, {\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n// is like\nconst rootReducer = combineReducers({\n  [counterSlice.reducerPath]: counterSlice.reducer,\n  [baseApi.reducerPath]: baseApi.reducer,\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"caution",children:[(0,i.jsx)(n.p,{children:"If multiple slices/map objects have the same reducer path, the reducer provided later in the arguments will override the previous."}),(0,i.jsx)(n.p,{children:"However, typing will not be able to account for this. It's best to ensure that all of your reducers will aim for a unique location."})]}),"\n",(0,i.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"combineSlices"})," returns a reducer function, with attached methods."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"interface CombinedSliceReducer<InitialState, DeclaredState = InitialState>\n  extends Reducer<DeclaredState, AnyAction, Partial<DeclaredState>> {\n  withLazyLoadedSlices<LazyLoadedSlices>(): CombinedSliceReducer<\n    InitialState,\n    DeclaredState & Partial<LazyLoadedSlices>\n  >\n  inject<Slice extends SliceLike>(\n    slice: Slice,\n    config?: InjectConfig\n  ): CombinedSliceReducer<InitialState, DeclaredState & WithSlice<Slice>>\n  selector: {\n    (selectorFn: Selector, selectState?: SelectFromRootState) => WrappedSelector\n    original(state: DeclaredState) => InitialState & Partial<DeclaredState>\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"withlazyloadedslices",children:(0,i.jsx)(n.code,{children:"withLazyLoadedSlices"})}),"\n",(0,i.jsxs)(n.p,{children:["It's recommended to ",(0,i.jsx)(n.a,{href:"https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types",children:"infer your RootState type from your store"}),", which is inferred from the reducer. However, this can present issues if slices are lazy loaded, and thus not able to be inferred from."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"withLazyLoadedSlices"})," allows you to declare slices that will be added to state later, which will be included in the final state type."]}),"\n",(0,i.jsx)(n.p,{children:"One possible pattern of managing this would be with declaration merging:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Using declaration merging to declare injected slices"',children:"// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './static'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// keys in LazyLoadedSlices are marked as optional\nexport type RootState = ReturnType<typeof rootReducer>\n\n// file: slices/lazySlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof lazySlice> {}\n}\n\nconst injectedReducer = rootReducer.inject(lazySlice)\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["The above example uses the ",(0,i.jsx)(n.code,{children:"WithSlice"})," utility type for a slice mounted under its ",(0,i.jsx)(n.code,{children:"reducerPath"}),". If the slice is mounted under a different key, you can declare it as a regular key instead."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Declaring a slice mounted outside its reducerPath"',children:"// file: slices/lazySlice.ts\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices {\n    customKey: LazyState\n  }\n}\n\nconst injectedReducer = rootReducer.inject({\n  reducerPath: 'customKey',\n  reducer: lazySlice.reducer,\n})\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer, {\n  reducerPath: 'customKey',\n})\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"inject",children:(0,i.jsx)(n.code,{children:"inject"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"inject"})," allows you to add a slice to your set of reducers after initialisation.\nIt expects to be passed a slice and an optional config, and returns an updated version of the reducer with the slice included."]}),"\n",(0,i.jsx)(n.p,{children:"This is mainly useful for lazy loading reducers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const reducerWithUser = rootReducer.inject(userSlice)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"inject"})," adds the slice to the map of reducers in your original reducer, but doesn't dispatch an action."]}),(0,i.jsx)(n.p,{children:"This means that the added reducer state will not show up in your store until the next action is dispatched."})]}),"\n",(0,i.jsx)(n.h4,{id:"reducer-replacement",children:"Reducer replacement"}),"\n",(0,i.jsxs)(n.p,{children:["By default, replacing a reducer is not allowed.\nIn development mode, a warning will be logged to console if a new reducer instance is attempted to inject into a ",(0,i.jsx)(n.code,{children:"reducerPath"})," that's already injected. (It won't warn if the same reducer instance is injected into the same place twice.)"]}),"\n",(0,i.jsxs)(n.p,{children:["If you wish to allow replacing a reducer with a new instance, you must explicitly pass ",(0,i.jsx)(n.code,{children:"overrideExisting: true"})," as part of your configuration object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const reducerWithUser = rootReducer.inject(userSlice, {\n  overrideExisting: true,\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:['This may be useful for hot reload, or "removing" a reducer by replacing it with a function that always returns ',(0,i.jsx)(n.code,{children:"null"}),".\nNote that for predictable behavior, your types should account for all of the possible reducers you intend to occupy a path."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile title=\"'Removing' a reducer, by replacing it with a no-op function\"",children:"declare module '.' {\n  export interface LazyLoadedSlices {\n    removable: RemovableState | null\n  }\n}\n\nconst withInjected = rootReducer.inject(\n  { reducerPath: 'removable', reducer: removableReducer },\n  { overrideExisting: true },\n)\n\nconst emptyReducer = () => null\n\nconst removeReducer = () =>\n  rootReducer.inject(\n    { reducerPath: 'removable', reducer: emptyReducer },\n    { overrideExisting: true },\n  )\n"})}),"\n",(0,i.jsx)(n.h3,{id:"selector",children:(0,i.jsx)(n.code,{children:"selector"})}),"\n",(0,i.jsx)(n.p,{children:"As noted previously, an injected reducer can still be undefined in state if no action has been dispatched."}),"\n",(0,i.jsx)(n.p,{children:"Dealing with this possibly-optional state can be inconvient when writing selectors, as you may end up with a lot of results being possibly undefined or relying on explicit defaults."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selector"})," allows you to get around this, by wrapping the reducer state in a ",(0,i.jsx)(n.code,{children:"Proxy"})," that ensures that any currently injected reducers evaluate to their initial state if they're currently ",(0,i.jsx)(n.code,{children:"undefined"})," in state."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"declare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    /* ... */\n  },\n})\n\nconst withCounter = rootReducer.inject(counterSlice)\n\nconst selectCounterValue = (rootState: RootState) => rootState.counter?.value // number | undefined\n\nconst wrappedSelectCounterValue = withCounter.selector(\n  (rootState) => rootState.counter.value, // number\n)\n\nconsole.log(\n  selectCounterValue({}), // undefined\n  selectCounterValue({ counter: { value: 2 } }), // 2\n  wrappedSelectCounterValue({}), // 0\n  wrappedSelectCounterValue({ counter: { value: 2 } }), // 2\n)\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Proxy"})," retrieves a reducer's initial state by calling it with a randomly generated action type - don't try to handle this as a special case inside your reducer."]})}),"\n",(0,i.jsx)(n.h4,{id:"nested-combined-reducer",children:"Nested combined reducer"}),"\n",(0,i.jsx)(n.p,{children:"The wrapped selector expects to use the state returned by the combined reducer as its first argument."}),"\n",(0,i.jsxs)(n.p,{children:["If the combined reducer is nested further inside the store state, pass a ",(0,i.jsx)(n.code,{children:"selectState"})," callback as the second argument to ",(0,i.jsx)(n.code,{children:"selector"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"interface RootState {\n  innerCombined: ReturnType<typeof combinedReducer>\n}\n\nconst selectCounterValue = withCounter.selector(\n  (combinedState) => combinedState.counter.value,\n  (rootState: RootState) => rootState.innerCombined,\n)\n\nconsole.log(\n  selectCounterValue({\n    innerCombined: {},\n  }), // 0\n  selectCounterValue({\n    innerCombined: {\n      counter: {\n        value: 2,\n      },\n    },\n  }), // 2\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"original",children:(0,i.jsx)(n.code,{children:"original"})}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.a,{href:"/usage/immer-reducers#debugging-and-inspecting-drafted-state",children:"Immer usage"}),", an ",(0,i.jsx)(n.code,{children:"original"})," function is provided to retrieve the original state value provided to the ",(0,i.jsx)(n.code,{children:"Proxy"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This is mainly useful for debugging/inspecting, as ",(0,i.jsx)(n.code,{children:"Proxy"})," instances tend to be displayed in a format that's hard to read."]}),"\n",(0,i.jsxs)(n.p,{children:["The function is attached as a method on the ",(0,i.jsx)(n.code,{children:"selector"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const wrappedSelectCounterValue = withCounter.selector((rootState) => {\n  console.log(withCounter.selector.original(rootState))\n  return rootState.counter.value\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"slice-integration",children:"Slice integration"}),"\n",(0,i.jsx)(n.h3,{id:"injectinto",children:(0,i.jsx)(n.code,{children:"injectInto"})}),"\n",(0,i.jsxs)(n.p,{children:["Slice instances returned by ",(0,i.jsx)(n.a,{href:"./createSlice",children:(0,i.jsx)(n.code,{children:"createSlice"})})," have an attached ",(0,i.jsx)(n.code,{children:"injectInto"})," method, which receive an injectable reducer from ",(0,i.jsx)(n.code,{children:"combineSlices"}),' and returns an "injected" version of that slice.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const injectedCounterSlice = counterSlice.injectInto(rootReducer)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An optional configuration object can be passed. This follows ",(0,i.jsx)(n.a,{href:"#inject",children:(0,i.jsx)(n.code,{children:"inject"})}),"'s options with an additional ",(0,i.jsx)(n.code,{children:"reducerPath"})," field, for injecting the slice under a path other than its current ",(0,i.jsx)(n.code,{children:"reducerPath"})," property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const aCounterSlice = counterSlice.injectInto(rootReducer, {\n  reducerPath: 'aCounter',\n})\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"selectors--getselectors",children:[(0,i.jsx)(n.code,{children:"selectors"})," / ",(0,i.jsx)(n.code,{children:"getSelectors"})]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.a,{href:"#selector",children:(0,i.jsx)(n.code,{children:"selector"})}),', the selectors from an "injected" slice instance behave slightly differently.']}),"\n",(0,i.jsx)(n.p,{children:"If the slice state is undefined in the store state passed, the selector will instead be called with the slice's initial state."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selectors"})," will also reflect the change in ",(0,i.jsx)(n.code,{children:"reducerPath"})," if one was made during injection."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"console.log(\n  injectedCounterSlice.selectors.selectValue({}), // 0\n  injectedCounterSlice.selectors.selectValue({ counter: { value: 2 } }), // 2\n  aCounterSlice.selectors.selectValue({ aCounter: { value: 2 } }), // 2\n)\n"})})]})}function p(e={}){let{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8049:function(e,n,t){t.d(n,{Z:()=>c});var r=t("4246");t("7378");var i=t("4870");function c(e){let{children:n,hidden:t,className:c}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.Z)("tabItem_wHwb",c),hidden:t,children:n})}},5181:function(e,n,t){t.d(n,{Z:()=>S});var r=t("4246"),i=t("7378"),c=t("4870"),l=t("5403"),o=t("3620"),a=t("7090"),s=t("6180"),d=t("3418"),u=t("9073");function h(e){var n,t;return null!==(t=null===(n=i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==t?t:[]}function p(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var m=t("3344");function j(e){let{className:n,block:t,selectedValue:i,selectValue:o,tabValues:a}=e,s=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.o5)(),u=e=>{let n=e.currentTarget,t=a[s.indexOf(n)].value;t!==i&&(d(n),o(t))},h=e=>{var n,t;let r=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let t=s.indexOf(e.currentTarget)+1;r=null!==(n=s[t])&&void 0!==n?n:s[0];break}case"ArrowLeft":{let n=s.indexOf(e.currentTarget)-1;r=null!==(t=s[n])&&void 0!==t?t:s[s.length-1]}}null==r||r.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":t},n),children:a.map(e=>{let{value:n,label:t,attributes:l}=e;return(0,r.jsx)("li",{role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>s.push(e),onKeyDown:h,onClick:u,...l,className:(0,c.Z)("tabs__item","tabItem_l0OV",null==l?void 0:l.className,{"tabs__item--active":i===n}),children:null!=t?t:n},n)})})}function f(e){let{lazy:n,children:t,selectedValue:l}=e,o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=o.find(e=>e.props.value===l);return e?(0,i.cloneElement)(e,{className:(0,c.Z)("margin-top--md",e.props.className)}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==l}))})}function x(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:r}=e,c=function(e){let{values:n,children:t}=e;return(0,i.useMemo)(()=>{let e=null!=n?n:h(t).map(e=>{let{props:{value:n,label:t,attributes:r,default:i}}=e;return{value:n,label:t,attributes:r,default:i}});return!function(e){let n=(0,d.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,t])}(e),[l,m]=(0,i.useState)(()=>(function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(t,'" but none of its children has the corresponding value. Available values are: ').concat(r.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return t}let i=null!==(n=r.find(e=>e.default))&&void 0!==n?n:r[0];if(!i)throw Error("Unexpected error: 0 tabValues");return i.value})({defaultValue:n,tabValues:c})),[j,f]=function(e){let{queryString:n=!1,groupId:t}=e,r=(0,o.k6)(),c=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,s._X)(c),(0,i.useCallback)(e=>{if(!c)return;let n=new URLSearchParams(r.location.search);n.set(c,e),r.replace({...r.location,search:n.toString()})},[c,r])]}({queryString:t,groupId:r}),[x,S]=function(e){let{groupId:n}=e,t=n?"docusaurus.tab.".concat(n):null,[r,c]=(0,u.Nk)(t);return[r,(0,i.useCallback)(e=>{t&&c.set(e)},[t,c])]}({groupId:r}),b=(()=>{let e=null!=j?j:x;return p({value:e,tabValues:c})?e:null})();return(0,a.Z)(()=>{b&&m(b)},[b]),{selectedValue:l,selectValue:(0,i.useCallback)(e=>{if(!p({value:e,tabValues:c}))throw Error("Can't select invalid tab value=".concat(e));m(e),f(e),S(e)},[f,S,c]),tabValues:c}}(e);return(0,r.jsxs)("div",{className:(0,c.Z)("tabs-container","tabList_J5MA"),children:[(0,r.jsx)(j,{...n,...e}),(0,r.jsx)(f,{...n,...e})]})}function S(e){let n=(0,m.Z)();return(0,r.jsx)(x,{...e,children:h(e.children)},String(n))}},980:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return l}});var r=t(7378);let i={},c=r.createContext(i);function l(e){let n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);