"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5334],{3411:function(e,t,a){a.d(t,{Z:function(){return s}});var n=a(7378),i=a(7140),r="tabItem_wHwb";function s(e){var t=e.children,a=e.hidden,s=e.className;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,s),hidden:a},t)}},2453:function(e,t,a){a.d(t,{Z:function(){return h}});var n=a(2685),i=a(7378),r=a(7140),s=a(362),u=a(56),l=a(5720),o=a(9169),p="tabList_J5MA",c="tabItem_l0OV";function d(e){var t,a,s=e.lazy,d=e.block,h=e.defaultValue,m=e.values,y=e.groupId,f=e.className,g=i.Children.map(e.children,(function(e){if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=m?m:g.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,u.l)(k,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===h?h:null!=(t=null!=h?h:null==(a=g.find((function(e){return e.props.default})))?void 0:a.props.value)?t:g[0].props.value;if(null!==v&&!k.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+k.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var N=(0,l.U)(),w=N.tabGroupChoices,P=N.setTabGroupChoices,C=(0,i.useState)(v),x=C[0],T=C[1],q=[],Q=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=y){var O=w[y];null!=O&&O!==x&&k.some((function(e){return e.value===O}))&&T(O)}var j=function(e){var t=e.currentTarget,a=q.indexOf(t),n=k[a].value;n!==x&&(Q(t),T(n),null!=y&&P(y,String(n)))},D=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n,i=q.indexOf(e.currentTarget)+1;a=null!=(n=q[i])?n:q[0];break;case"ArrowLeft":var r,s=q.indexOf(e.currentTarget)-1;a=null!=(r=q[s])?r:q[q.length-1]}null==(t=a)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":d},f)},k.map((function(e){var t=e.value,a=e.label,s=e.attributes;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:function(e){return q.push(e)},onKeyDown:D,onFocus:j,onClick:j},s,{className:(0,r.Z)("tabs__item",c,null==s?void 0:s.className,{"tabs__item--active":x===t})}),null!=a?a:t)}))),s?(0,i.cloneElement)(g.filter((function(e){return e.props.value===x}))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},g.map((function(e,t){return(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==x})}))))}function h(e){var t=(0,s.Z)();return i.createElement(d,(0,n.Z)({key:String(t)},e))}},5091:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return y},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return h}});var n=a(2685),i=a(1244),r=(a(7378),a(5318)),s=a(3411),u=a(2453),l=["components"],o={id:"manual-cache-updates",title:"Manual Cache Updates",sidebar_label:"Manual Cache Updates",hide_title:!0,description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},p=void 0,c={unversionedId:"rtk-query/usage/manual-cache-updates",id:"rtk-query/usage/manual-cache-updates",title:"Manual Cache Updates",description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually",source:"@site/../docs/rtk-query/usage/manual-cache-updates.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/manual-cache-updates",permalink:"/rtk-query/usage/manual-cache-updates",draft:!1,tags:[],version:"current",lastUpdatedAt:1716195420,formattedLastUpdatedAt:"May 20, 2024",frontMatter:{id:"manual-cache-updates",title:"Manual Cache Updates",sidebar_label:"Manual Cache Updates",hide_title:!0,description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},sidebar:"docs",previous:{title:"Automated Re-fetching",permalink:"/rtk-query/usage/automated-refetching"},next:{title:"Conditional Fetching",permalink:"/rtk-query/usage/conditional-fetching"}},d={},h=[{value:"Overview",id:"overview",level:2},{value:"Updating existing cache entries",id:"updating-existing-cache-entries",level:3},{value:"Creating new cache entries or replacing existing ones",id:"creating-new-cache-entries-or-replacing-existing-ones",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Example",id:"example",level:4},{value:"Pessimistic Updates",id:"pessimistic-updates",level:3},{value:"General Updates",id:"general-updates",level:3}],m={toc:h};function y(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"manual-cache-updates"},"Manual Cache Updates"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"For most cases, in order to receive up to date data after a triggering a change in the backend, you can take advantage of cache tag invalidation to perform ",(0,r.kt)("a",{parentName:"p",href:"./automated-refetching"},"automated re-fetching"),". This will cause a query to re-fetch its data when it has been told that a mutation has occurred which would cause its data to become out of date."),(0,r.kt)("p",null,"We recommend using automated re-fetching as a preference over manual cache updates in most situations."),(0,r.kt)("p",null,"However, there ",(0,r.kt)("em",{parentName:"p"},"are"),' use cases when manual cache updates are necessary, such as "optimistic" or "pessimistic" updates, or modifying data as part of cache entry lifecycles.'),(0,r.kt)("p",null,"RTK Query exports thunks for these use cases, attached to ",(0,r.kt)("inlineCode",{parentName:"p"},"api.utils"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/rtk-query/api/created-api/api-slice-utils#updatequerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"updateQueryData")),": updates an already existing cache entry"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/rtk-query/api/created-api/api-slice-utils#upsertquerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"upsertQueryData")),": creates or replaces cache entries")),(0,r.kt)("p",null,"Since these are thunks, you can dispatch them anywhere you have access to ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch"),"."),(0,r.kt)("h3",{id:"updating-existing-cache-entries"},"Updating existing cache entries"),(0,r.kt)("p",null,"For updates of existing cache entries, use ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/api/created-api/api-slice-utils#updatequerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"updateQueryData")),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," is strictly intended to perform ",(0,r.kt)("em",{parentName:"p"},"updates")," to existing cache entries, not create new entries. If an ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," thunk action is dispatched and the ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," combination that does not match any existing cache entry, the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"recipe")," callback will not be called, and no ",(0,r.kt)("inlineCode",{parentName:"p"},"patches")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," will be returned."),(0,r.kt)("p",null,"Use cases for manual update of cache entries:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Providing immediate feedback to the user when a mutation is attempted"),(0,r.kt)("li",{parentName:"ul"},"After a mutation, updating a single item in a large list of items that is already cached, rather than re-fetching the whole list"),(0,r.kt)("li",{parentName:"ul"},"Debouncing a large number of mutations with immediate feedback as though they are being applied, followed by a single request sent to the server to update the debounced attempts")),(0,r.kt)("h3",{id:"creating-new-cache-entries-or-replacing-existing-ones"},"Creating new cache entries or replacing existing ones"),(0,r.kt)("p",null,"To create or replace existing cache entries, use ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/api/created-api/api-slice-utils#upsertquerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"upsertQueryData")),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"upsertQueryData")," is intended to perform ",(0,r.kt)("em",{parentName:"p"},"replacements")," to existing cache entries or ",(0,r.kt)("em",{parentName:"p"},"creation")," of new ones. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"upsertQueryData")," does not have access to the previous state of the cache entry, the update may be performed only as a replacement. In comparison, ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," allows patching of the existing cache entry, but cannot create a new one."),(0,r.kt)("p",null,"One example use case is ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/manual-cache-updates#pessimistic-updates"},"pessimistic updates"),". If the client makes an API call to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Post"),", the backend could return its complete data including the ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),". Then we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"upsertQueryData")," to create a new cache entry for the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPostById(id)")," query, preventing an extra fetch to retrieve the item later."),(0,r.kt)("h2",{id:"recipes"},"Recipes"),(0,r.kt)("h3",{id:"optimistic-updates"},"Optimistic Updates"),(0,r.kt)("p",null,"When you wish to perform an update to cache data immediately after a ",(0,r.kt)("a",{parentName:"p",href:"./mutations"},(0,r.kt)("inlineCode",{parentName:"a"},"mutation"))," is\ntriggered, you can apply an ",(0,r.kt)("inlineCode",{parentName:"p"},"optimistic update"),". This can be a useful pattern for when you want to\ngive the user the impression that their changes are immediate, even while the mutation request is\nstill in flight."),(0,r.kt)("p",null,"The core concepts for an optimistic update are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when you start a query or mutation, ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")," will be executed"),(0,r.kt)("li",{parentName:"ul"},"you manually update the cached data by dispatching ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.updateQueryData")," within ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")),(0,r.kt)("li",{parentName:"ul"},"then, in the case that ",(0,r.kt)("inlineCode",{parentName:"li"},"queryFulfilled")," rejects:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"you roll it back via the ",(0,r.kt)("inlineCode",{parentName:"li"},".undo")," property of the object you got back from the earlier dispatch,\nOR"),(0,r.kt)("li",{parentName:"ul"},"you invalidate the cache data via ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.invalidateTags")," to trigger a full re-fetch of the data")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Where many mutations are potentially triggered in short succession causing overlapping requests,\nyou may encounter race conditions if attempting to roll back patches using the ",(0,r.kt)("inlineCode",{parentName:"p"},".undo")," property\non failures. For these scenarios, it is often simplest and safest to invalidate the tags on error\ninstead, and re-fetch truly up-to-date data from the server.")),(0,r.kt)(u.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Optimistic update mutation example (async await)"',title:'"Optimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<void, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Optimistic update mutation example (async await)"',title:'"Optimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,r.kt)("p",null,"or, if you prefer the slightly shorter version with ",(0,r.kt)("inlineCode",{parentName:"p"},".catch")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n+      onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n-       try {\n-         await queryFulfilled\n-       } catch {\n-         patchResult.undo()\n-       }\n+       queryFulfilled.catch(patchResult.undo)\n      }\n")),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./examples#react-optimistic-updates"},"React Optimistic Updates")),(0,r.kt)("h3",{id:"pessimistic-updates"},"Pessimistic Updates"),(0,r.kt)("p",null,"When you wish to perform an update to cache data based on the response received from the server\nafter a ",(0,r.kt)("a",{parentName:"p",href:"./mutations"},(0,r.kt)("inlineCode",{parentName:"a"},"mutation"))," is triggered, you can apply a ",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update"),".\nThe distinction between a ",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"optimistic update")," is that the\n",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update")," will instead wait for the response from the server prior to updating\nthe cached data."),(0,r.kt)("p",null,"The core concepts for a pessimistic update are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when you start a query or mutation, ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")," will be executed"),(0,r.kt)("li",{parentName:"ul"},"you await ",(0,r.kt)("inlineCode",{parentName:"li"},"queryFulfilled")," to resolve to an object containing the transformed response from the\nserver in the ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," property"),(0,r.kt)("li",{parentName:"ul"},"you manually update the cached data by dispatching ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.updateQueryData")," within\n",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted"),", using the data in the response from the server for your draft updates"),(0,r.kt)("li",{parentName:"ul"},"you manually create a new cache entry by dispatching ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.upsertQueryData")," within ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted"),",\nusing the complete Post object returned by backend.")),(0,r.kt)(u.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Pessimistic update mutation example (async await)"',title:'"Pessimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            })\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n    createPost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost)\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Pessimistic update mutation example (async await)"',title:'"Pessimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            })\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n    createPost: build.mutation({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost)\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,r.kt)("h3",{id:"general-updates"},"General Updates"),(0,r.kt)("p",null,"If you find yourself wanting to update cache data elsewhere in your application, you can do so\nanywhere you have access to the ",(0,r.kt)("inlineCode",{parentName:"p"},"store.dispatch")," method, including within React components via\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://react-redux.js.org/api/hooks#usedispatch"},"useDispatch")," hook (or a typed version such\nas ",(0,r.kt)("a",{parentName:"p",href:"https://react-redux.js.org/using-react-redux/usage-with-typescript#define-typed-hooks"},"useAppDispatch"),"\nfor typescript users)."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You should generally avoid manually updating the cache outside of the ",(0,r.kt)("inlineCode",{parentName:"p"},"onQueryStarted"),"\ncallback for a mutation without a good reason, as RTK Query is intended to be used by considering\nyour cached data as a reflection of the server-side state.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'no-transpile title="General manual cache update example"',"no-transpile":!0,title:'"General',manual:!0,cache:!0,update:!0,'example"':!0},"import { api } from './api'\nimport { useAppDispatch } from './store/hooks'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n\n  function handleClick() {\n    /**\n     * This will update the cache data for the query corresponding to the `getPosts` endpoint,\n     * when that endpoint is used with no argument (undefined).\n     */\n    const patchCollection = dispatch(\n      api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n        draftPosts.push({ id: 1, name: 'Teddy' })\n      }),\n    )\n  }\n\n  return <button onClick={handleClick}>Add post to cache</button>\n}\n")))}y.isMDXComponent=!0},5318:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7378);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function u(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),o=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=o(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),d=o(a),h=i,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||r;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=d;var u={};for(var l in t)hasOwnProperty.call(t,l)&&(u[l]=t[l]);u.originalType=e,u.mdxType="string"==typeof e?e:i,s[1]=u;for(var o=2;o<r;o++)s[o]=a[o];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);