"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2150],{3411:function(e,t,a){a.d(t,{Z:function(){return l}});var n=a(7378),i=a(7140),r="tabItem_wHwb";function l(e){var t=e.children,a=e.hidden,l=e.className;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:a},t)}},2453:function(e,t,a){a.d(t,{Z:function(){return h}});var n=a(2685),i=a(7378),r=a(7140),l=a(362),s=a(56),o=a(5720),p=a(9169),u="tabList_J5MA",d="tabItem_l0OV";function c(e){var t,a,l=e.lazy,c=e.block,h=e.defaultValue,m=e.values,g=e.groupId,k=e.className,y=i.Children.map(e.children,(function(e){if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=m?m:y.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),N=(0,s.l)(f,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===h?h:null!=(t=null!=h?h:null==(a=y.find((function(e){return e.props.default})))?void 0:a.props.value)?t:y[0].props.value;if(null!==v&&!f.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var b=(0,o.U)(),C=b.tabGroupChoices,T=b.setTabGroupChoices,w=(0,i.useState)(v),P=w[0],x=w[1],q=[],D=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=g){var A=C[g];null!=A&&A!==P&&f.some((function(e){return e.value===A}))&&x(A)}var S=function(e){var t=e.currentTarget,a=q.indexOf(t),n=f[a].value;n!==P&&(D(t),x(n),null!=g&&T(g,String(n)))},E=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n,i=q.indexOf(e.currentTarget)+1;a=null!=(n=q[i])?n:q[0];break;case"ArrowLeft":var r,l=q.indexOf(e.currentTarget)-1;a=null!=(r=q[l])?r:q[q.length-1]}null==(t=a)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",u)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":c},k)},f.map((function(e){var t=e.value,a=e.label,l=e.attributes;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:P===t?0:-1,"aria-selected":P===t,key:t,ref:function(e){return q.push(e)},onKeyDown:E,onFocus:S,onClick:S},l,{className:(0,r.Z)("tabs__item",d,null==l?void 0:l.className,{"tabs__item--active":P===t})}),null!=a?a:t)}))),l?(0,i.cloneElement)(y.filter((function(e){return e.props.value===P}))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},y.map((function(e,t){return(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==P})}))))}function h(e){var t=(0,l.Z)();return i.createElement(c,(0,n.Z)({key:String(t)},e))}},978:function(e,t,a){a.r(t),a.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d}});var n=a(2685),i=a(1244),r=(a(7378),a(5318)),l=(a(3411),a(2453),["components"]),s={id:"api-slice-utils",title:"API Slices: Utilities",sidebar_label:"API Slice Utilities",hide_title:!0},o=void 0,p={unversionedId:"rtk-query/api/created-api/api-slice-utils",id:"rtk-query/api/created-api/api-slice-utils",title:"API Slices: Utilities",description:"&nbsp;",source:"@site/../docs/rtk-query/api/created-api/api-slice-utils.mdx",sourceDirName:"rtk-query/api/created-api",slug:"/rtk-query/api/created-api/api-slice-utils",permalink:"/rtk-query/api/created-api/api-slice-utils",draft:!1,tags:[],version:"current",lastUpdatedAt:1716195420,formattedLastUpdatedAt:"May 20, 2024",frontMatter:{id:"api-slice-utils",title:"API Slices: Utilities",sidebar_label:"API Slice Utilities",hide_title:!0},sidebar:"docs",previous:{title:"Code Splitting",permalink:"/rtk-query/api/created-api/code-splitting"},next:{title:"React Hooks",permalink:"/rtk-query/api/created-api/hooks"}},u={},d=[{value:"<code>updateQueryData</code>",id:"updatequerydata",level:3},{value:"Signature",id:"signature",level:4},{value:"Description",id:"description",level:4},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"<code>upsertQueryData</code>",id:"upsertquerydata",level:3},{value:"Signature",id:"signature-1",level:4},{value:"Description",id:"description-1",level:4},{value:"Example",id:"example",level:4},{value:"<code>patchQueryData</code>",id:"patchquerydata",level:3},{value:"Signature",id:"signature-2",level:4},{value:"Description",id:"description-2",level:4},{value:"Example",id:"example-3",level:4},{value:"<code>prefetch</code>",id:"prefetch",level:3},{value:"Signature",id:"signature-3",level:4},{value:"Description",id:"description-3",level:4},{value:"Example",id:"example-4",level:4},{value:"<code>selectInvalidatedBy</code>",id:"selectinvalidatedby",level:3},{value:"Signature",id:"signature-4",level:4},{value:"Description",id:"description-4",level:4},{value:"Example",id:"example-5",level:4},{value:"<code>invalidateTags</code>",id:"invalidatetags",level:3},{value:"Signature",id:"signature-5",level:4},{value:"Description",id:"description-5",level:4},{value:"Example",id:"example-6",level:4},{value:"<code>selectCachedArgsForQuery</code>",id:"selectcachedargsforquery",level:3},{value:"Signature",id:"signature-6",level:4},{value:"Description",id:"description-6",level:4},{value:"Example",id:"example-7",level:4},{value:"<code>resetApiState</code>",id:"resetapistate",level:3},{value:"Signature",id:"signature-7",level:4},{value:"Description",id:"description-7",level:4},{value:"Example",id:"example-8",level:4},{value:"<code>getRunningQueriesThunk</code> and <code>getRunningMutationsThunk</code>",id:"getrunningqueriesthunk-and-getrunningmutationsthunk",level:2},{value:"Signature",id:"signature-8",level:4},{value:"Description",id:"description-8",level:4},{value:"<code>getRunningQueryThunk</code> and <code>getRunningMutationThunk</code>",id:"getrunningquerythunk-and-getrunningmutationthunk",level:2},{value:"Signature",id:"signature-9",level:4},{value:"Description",id:"description-9",level:4}],c={toc:d};function h(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"api-slices-utilities"},"API Slices: Utilities"),(0,r.kt)("p",null,"The API slice object includes various utilities that can be used for cache management,\nsuch as implementing ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/manual-cache-updates#optimistic-updates"},"optimistic updates"),",\nas well implementing ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/server-side-rendering"},"server side rendering"),"."),(0,r.kt)("p",null,"These are included as ",(0,r.kt)("inlineCode",{parentName:"p"},"api.util")," inside the API object."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Some of the TS types on this page are pseudocode to illustrate intent, as the actual internal types are fairly complex.")),(0,r.kt)("h3",{id:"updatequerydata"},(0,r.kt)("inlineCode",{parentName:"h3"},"updateQueryData")),(0,r.kt)("h4",{id:"signature"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const updateQueryData = (\n  endpointName: string,\n  args: any,\n  updateRecipe: (draft: Draft<CachedState>) => void,\n  updateProvided?: boolean,\n) => ThunkAction<PatchCollection, PartialState, any, AnyAction>\n\ninterface PatchCollection {\n  patches: Patch[]\n  inversePatches: Patch[]\n  undo: () => void\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": an argument matching that used for a previous query call, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updateRecipe"),": an Immer ",(0,r.kt)("inlineCode",{parentName:"li"},"produce")," callback that can apply changes to the cached state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updateProvided"),": a boolean indicating whether the endpoint's provided tags should be re-calculated based on the updated cache. Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),".")))),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that, when dispatched, creates and applies a set of JSON diff/patch objects to the current state. This immediately updates the Redux state with those changes."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), any relevant query arguments, and a callback function. The callback receives an Immer-wrapped ",(0,r.kt)("inlineCode",{parentName:"p"},"draft")," of the current state, and may modify the draft to match the expected results after the mutation completes successfully."),(0,r.kt)("p",null,"The thunk returns an object containing ",(0,r.kt)("inlineCode",{parentName:"p"},"{patches: Patch[], inversePatches: Patch[], undo: () => void}"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"patches")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," are generated using Immer's ",(0,r.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/patches"},(0,r.kt)("inlineCode",{parentName:"a"},"produceWithPatches")," method"),"."),(0,r.kt)("p",null,"This is typically used as the first step in implementing optimistic updates. The generated ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," can be used to revert the updates by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(patchQueryData(endpointName, args, inversePatches))"),". Alternatively, the ",(0,r.kt)("inlineCode",{parentName:"p"},"undo")," method can be called directly to achieve the same effect."),(0,r.kt)("p",null,"Note that the first two arguments (",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),") are used to determine which existing cache entry to update. If no existing cache entry is found, the ",(0,r.kt)("inlineCode",{parentName:"p"},"updateRecipe")," callback will not run."),(0,r.kt)("h4",{id:"example-1"},"Example 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n")),(0,r.kt)("p",null,"In the example above, ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPosts'")," is provided for the ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," is provided\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),". This will match a query cache key of ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPosts(undefined)'"),"."),(0,r.kt)("p",null,"i.e. it will match a cache entry that may have been created via any of the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"api.endpoints.getPosts.useQuery()\n\nuseGetPostsQuery()\n\nuseGetPostsQuery(undefined, { ...options })\n\ndispatch(api.endpoints.getPosts.initiate())\n\ndispatch(api.endpoints.getPosts.initiate(undefined, { ...options }))\n")),(0,r.kt)("h4",{id:"example-2"},"Example 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPostById', 1, (draftPost) => {\n    draftPost.name = 'Lilly'\n  }),\n)\n")),(0,r.kt)("p",null,"In the example above, ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPostById'")," is provided for the ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," is provided\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),". This will match a query cache key of ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPostById(1)'"),"."),(0,r.kt)("p",null,"i.e. it will match a cache entry that may have been created via any of the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"api.endpoints.getPostById.useQuery(1)\n\nuseGetPostByIdQuery(1)\n\nuseGetPostByIdQuery(1, { ...options })\n\ndispatch(api.endpoints.getPostById.initiate(1))\n\ndispatch(api.endpoints.getPostById.initiate(1, { ...options }))\n")),(0,r.kt)("h3",{id:"upsertquerydata"},(0,r.kt)("inlineCode",{parentName:"h3"},"upsertQueryData")),(0,r.kt)("h4",{id:"signature-1"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const upsertQueryData = <T>(endpointName: string, args: any, newEntryData: T) =>\n  ThunkAction<Promise<CacheEntry<T>>, PartialState, any, UnknownAction>\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": an argument matching that used for a previous query call, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newEntryValue"),": the value to be written into the corresponding cache entry's ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," field")))),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that, when dispatched, acts as an artificial API request to upsert a value into the cache."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), the appropriate query arg values to construct the desired cache key, and the data to upsert."),(0,r.kt)("p",null,"If no cache entry for that cache key exists, a cache entry will be created and the data added. If a cache entry already exists, this will ",(0,r.kt)("em",{parentName:"p"},"overwrite")," the existing cache entry data."),(0,r.kt)("p",null,"The thunk executes ",(0,r.kt)("em",{parentName:"p"},"asynchronously"),", and returns a promise that resolves when the store has been updated."),(0,r.kt)("p",null,'If dispatched while an actual request is in progress, both the upsert and request will be handled as soon as they resolve, resulting in a "last result wins" update behavior.'),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"await dispatch(\n  api.util.upsertQueryData('getPost', { id: 1 }, { id: 1, text: 'Hello!' }),\n)\n")),(0,r.kt)("h3",{id:"patchquerydata"},(0,r.kt)("inlineCode",{parentName:"h3"},"patchQueryData")),(0,r.kt)("h4",{id:"signature-2"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchQueryData = (\n  endpointName: string,\n  args: any\n  patches: Patch[],\n  updateProvided?: boolean\n) => ThunkAction<void, PartialState, any, UnknownAction>;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": a cache key, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"patches"),": an array of patches (or inverse patches) to apply to cached state. These would typically be obtained from the result of dispatching ",(0,r.kt)("a",{parentName:"li",href:"#updatequerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"updateQueryData"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updateProvided"),": a boolean indicating whether the endpoint's provided tags should be re-calculated based on the updated cache. Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),".")))),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that, when dispatched, applies a JSON diff/patch array to the cached data for a given query result. This immediately updates the Redux state with those changes."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), the appropriate query arg values to construct the desired cache key, and a JSON diff/patch array as produced by Immer's ",(0,r.kt)("inlineCode",{parentName:"p"},"produceWithPatches"),"."),(0,r.kt)("p",null,"This is typically used as the second step in implementing optimistic updates. If a request fails, the optimistically-applied changes can be reverted by dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"patchQueryData")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," that were generated by ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," earlier."),(0,r.kt)("p",null,"In cases where it is desired to simply revert the previous changes, it may be preferable to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"undo")," method returned from dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," instead."),(0,r.kt)("h4",{id:"example-3"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n\n// later\ndispatch(\n  api.util.patchQueryData(\n    'getPosts',\n    undefined,\n    patchCollection.inversePatches,\n  ),\n)\n\n// or\npatchCollection.undo()\n")),(0,r.kt)("h3",{id:"prefetch"},(0,r.kt)("inlineCode",{parentName:"h3"},"prefetch")),(0,r.kt)("h4",{id:"signature-3"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"type PrefetchOptions = { ifOlderThan?: false | number } | { force?: boolean }\n\nconst prefetch = (endpointName: string, arg: any, options: PrefetchOptions) =>\n  ThunkAction<void, any, any, UnknownAction>\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": a cache key, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options"),": options to determine whether the request should be sent for a given situation:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ifOlderThan"),": if specified, only runs the query if the difference between ",(0,r.kt)("inlineCode",{parentName:"li"},"new Date()")," and the last",(0,r.kt)("inlineCode",{parentName:"li"},"fulfilledTimeStamp")," is greater than the given value (in seconds)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"force"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", it will ignore the ",(0,r.kt)("inlineCode",{parentName:"li"},"ifOlderThan")," value if it is set and the query will be run even if it exists in the cache.")))))),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that can be used to manually trigger pre-fetching of data."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), any relevant query arguments, and a set of options used to determine if the data actually should be re-fetched based on cache staleness."),(0,r.kt)("p",null,"React Hooks users will most likely never need to use this directly, as the ",(0,r.kt)("inlineCode",{parentName:"p"},"usePrefetch")," hook will dispatch the thunk action creator result internally as needed when you call the prefetching function supplied by the hook."),(0,r.kt)("h4",{id:"example-4"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.prefetch('getPosts', undefined, { force: true }))\n")),(0,r.kt)("h3",{id:"selectinvalidatedby"},(0,r.kt)("inlineCode",{parentName:"h3"},"selectInvalidatedBy")),(0,r.kt)("h4",{id:"signature-4"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"function selectInvalidatedBy(\n  state: RootState,\n  tags: ReadonlyArray<TagDescription<string>>,\n): Array<{\n  endpointName: string\n  originalArgs: any\n  queryCacheKey: QueryCacheKey\n}>\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"state"),": the root state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tags"),": a readonly array of invalidated tags, where the provided ",(0,r.kt)("inlineCode",{parentName:"li"},"TagDescription")," is one of the strings provided to the ",(0,r.kt)("a",{parentName:"li",href:"/rtk-query/api/createApi#tagtypes"},(0,r.kt)("inlineCode",{parentName:"a"},"tagTypes"))," property of the api. e.g.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[TagType]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType }]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType, id: number | string }]"))))))),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"A function that can select query parameters to be invalidated."),(0,r.kt)("p",null,"The function accepts two arguments"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the root state and"),(0,r.kt)("li",{parentName:"ul"},"the cache tags to be invalidated.")),(0,r.kt)("p",null,"It returns an array that contains"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the endpoint name,"),(0,r.kt)("li",{parentName:"ul"},"the original args and"),(0,r.kt)("li",{parentName:"ul"},"the queryCacheKey.")),(0,r.kt)("h4",{id:"example-5"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const entries = api.util.selectInvalidatedBy(state, ['Post'])\nconst entries = api.util.selectInvalidatedBy(state, [{ type: 'Post', id: 1 }])\nconst entries = api.util.selectInvalidatedBy(state, [\n  { type: 'Post', id: 1 },\n  { type: 'Post', id: 4 },\n])\n")),(0,r.kt)("h3",{id:"invalidatetags"},(0,r.kt)("inlineCode",{parentName:"h3"},"invalidateTags")),(0,r.kt)("h4",{id:"signature-5"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const invalidateTags = (\n  tags: Array<TagTypes | FullTagDescription<TagTypes>>,\n) => ({\n  type: string,\n  payload: tags,\n})\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tags"),": an array of tags to be invalidated, where the provided ",(0,r.kt)("inlineCode",{parentName:"li"},"TagType")," is one of the strings provided to the ",(0,r.kt)("a",{parentName:"li",href:"/rtk-query/api/createApi#tagtypes"},(0,r.kt)("inlineCode",{parentName:"a"},"tagTypes"))," property of the api. e.g.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[TagType]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType }]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType, id: number | string }]"))))))),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"A Redux action creator that can be used to manually invalidate cache tags for ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/automated-refetching"},"automated re-fetching"),"."),(0,r.kt)("p",null,"The action creator accepts one argument: the cache tags to be invalidated. It returns an action with those tags as a payload, and the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"invalidateTags")," action type for the api."),(0,r.kt)("p",null,"Dispatching the result of this action creator will ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/automated-refetching#invalidating-cache-data"},"invalidate")," the given tags, causing queries to automatically re-fetch if they are subscribed to cache data that ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/usage/automated-refetching#providing-cache-data"},"provides")," the corresponding tags."),(0,r.kt)("h4",{id:"example-6"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.invalidateTags(['Post']))\ndispatch(api.util.invalidateTags([{ type: 'Post', id: 1 }]))\ndispatch(\n  api.util.invalidateTags([\n    { type: 'Post', id: 1 },\n    { type: 'Post', id: 'LIST' },\n  ]),\n)\n")),(0,r.kt)("h3",{id:"selectcachedargsforquery"},(0,r.kt)("inlineCode",{parentName:"h3"},"selectCachedArgsForQuery")),(0,r.kt)("h4",{id:"signature-6"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"function selectCachedArgsForQuery(\n  state: RootState,\n  queryName: QueryName,\n): Array<QueryArg>\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"state"),": the root state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryName"),": a string matching an existing query endpoint name")))),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"A function that can select arguments for currently cached queries."),(0,r.kt)("p",null,"The function accepts two arguments"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the root state and")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the name of the query"))),(0,r.kt)("p",null,"It returns an array that contains arguments used for each entry."),(0,r.kt)("h4",{id:"example-7"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const args = api.util.selectCachedArgsForQuery(state, 'getPosts')\n")),(0,r.kt)("h3",{id:"resetapistate"},(0,r.kt)("inlineCode",{parentName:"h3"},"resetApiState")),(0,r.kt)("h4",{id:"signature-7"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const resetApiState = () => ({\n  type: string,\n  payload: undefined,\n})\n")),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"A Redux action creator that can be dispatched to manually reset the api state completely. This will immediately remove all existing cache entries, and all queries will be considered 'uninitialized'."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("a",{parentName:"p",href:"/rtk-query/api/created-api/hooks"},"hooks")," also track state in local component state and might not fully be reset by ",(0,r.kt)("inlineCode",{parentName:"p"},"resetApiState"),"."),(0,r.kt)("h4",{id:"example-8"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.resetApiState())\n")),(0,r.kt)("h2",{id:"getrunningqueriesthunk-and-getrunningmutationsthunk"},(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningQueriesThunk")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningMutationsThunk")),(0,r.kt)("h4",{id:"signature-8"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"getRunningQueriesThunk(): ThunkWithReturnValue<Array<QueryActionCreatorResult<any>>>\ngetRunningMutationsThunk(): ThunkWithReturnValue<Array<MutationActionCreatorResult<any>>>\n")),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("p",null,"Thunks that (if dispatched) return either all running queries or mutations.\nThese returned values can be awaited like promises."),(0,r.kt)("p",null,"This is useful for SSR scenarios to await all queries (or mutations) triggered in any way, including via hook calls\nor manually dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"initiate")," actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="Awaiting all currently running queries example"',"no-transpile":!0,title:'"Awaiting',all:!0,currently:!0,running:!0,queries:!0,'example"':!0},"await Promise.all(dispatch(api.util.getRunningQueriesThunk()))\n")),(0,r.kt)("h2",{id:"getrunningquerythunk-and-getrunningmutationthunk"},(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningQueryThunk")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningMutationThunk")),(0,r.kt)("h4",{id:"signature-9"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"getRunningQueryThunk<EndpointName extends QueryKeys<Definitions>>(\n  endpointName: EndpointName,\n  args: QueryArgFrom<Definitions[EndpointName]>\n): ThunkWithReturnValue<\n  | QueryActionCreatorResult<\n      Definitions[EndpointName] & { type: 'query' }\n    >\n  | undefined\n>\n\ngetRunningMutationThunk<EndpointName extends MutationKeys<Definitions>>(\n  endpointName: EndpointName,\n  fixedCacheKeyOrRequestId: string\n): ThunkWithReturnValue<\n  | MutationActionCreatorResult<\n      Definitions[EndpointName] & { type: 'mutation' }\n    >\n  | undefined\n>\n")),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("p",null,"Thunks that (if dispatched) return a single running query (or mutation) for a given\nendpoint name + argument (or requestId/fixedCacheKey) combination, if it is currently running.\nIf it is not currently running, the function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("p",null,"These thunks are primarily added to add experimental support for suspense in the future.\nThey enable writing custom hooks that look up if RTK Query has already got a running query/mutation\nfor a certain endpoint/argument combination, and retrieving that to ",(0,r.kt)("inlineCode",{parentName:"p"},"throw")," it as a promise."))}h.isMDXComponent=!0},5318:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return h}});var n=a(7378);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(a),h=i,m=c["".concat(o,".").concat(h)]||c[h]||d[h]||r;return a?n.createElement(m,l(l({ref:t},u),{},{components:a})):n.createElement(m,l({ref:t},u))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"}}]);