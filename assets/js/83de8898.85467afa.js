"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["8208"],{3993:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>r,metadata:()=>i,assets:()=>l,toc:()=>c,contentTitle:()=>d});var i=JSON.parse('{"id":"rtk-query/api/created-api/api-slice-utils","title":"API Slices: Utilities","description":"&nbsp;","source":"@site/../docs/rtk-query/api/created-api/api-slice-utils.mdx","sourceDirName":"rtk-query/api/created-api","slug":"/rtk-query/api/created-api/api-slice-utils","permalink":"/rtk-query/api/created-api/api-slice-utils","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1747236559000,"frontMatter":{"id":"api-slice-utils","title":"API Slices: Utilities","sidebar_label":"API Slice Utilities","hide_title":true},"sidebar":"docs","previous":{"title":"Code Splitting","permalink":"/rtk-query/api/created-api/code-splitting"}}'),a=t("4246"),s=t("980");t("8049"),t("5181");let r={id:"api-slice-utils",title:"API Slices: Utilities",sidebar_label:"API Slice Utilities",hide_title:!0},d="API Slices: Utilities",l={},c=[{value:"<code>updateQueryData</code>",id:"updatequerydata",level:3},{value:"Signature",id:"signature",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Description",id:"description",level:4},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"<code>upsertQueryData</code>",id:"upsertquerydata",level:3},{value:"Signature",id:"signature-1",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Description",id:"description-1",level:4},{value:"Example",id:"example",level:4},{value:"<code>patchQueryData</code>",id:"patchquerydata",level:3},{value:"Signature",id:"signature-2",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"Description",id:"description-2",level:4},{value:"Example",id:"example-3",level:4},{value:"<code>upsertQueryEntries</code>",id:"upsertqueryentries",level:3},{value:"Signature",id:"signature-3",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Description",id:"description-3",level:4},{value:"Example",id:"example-4",level:4},{value:"<code>prefetch</code>",id:"prefetch",level:3},{value:"Signature",id:"signature-4",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"Description",id:"description-4",level:4},{value:"Example",id:"example-5",level:4},{value:"<code>selectInvalidatedBy</code>",id:"selectinvalidatedby",level:3},{value:"Signature",id:"signature-5",level:4},{value:"Parameters",id:"parameters-5",level:4},{value:"Description",id:"description-5",level:4},{value:"Example",id:"example-6",level:4},{value:"<code>invalidateTags</code>",id:"invalidatetags",level:3},{value:"Signature",id:"signature-6",level:4},{value:"Parameters",id:"parameters-6",level:4},{value:"Description",id:"description-6",level:4},{value:"Example",id:"example-7",level:4},{value:"<code>selectCachedArgsForQuery</code>",id:"selectcachedargsforquery",level:3},{value:"Signature",id:"signature-7",level:4},{value:"Parameters",id:"parameters-7",level:4},{value:"Description",id:"description-7",level:4},{value:"Example",id:"example-8",level:4},{value:"<code>resetApiState</code>",id:"resetapistate",level:3},{value:"Signature",id:"signature-8",level:4},{value:"Description",id:"description-8",level:4},{value:"Example",id:"example-9",level:4},{value:"<code>getRunningQueriesThunk</code> and <code>getRunningMutationsThunk</code>",id:"getrunningqueriesthunk-and-getrunningmutationsthunk",level:2},{value:"Signature",id:"signature-9",level:4},{value:"Description",id:"description-9",level:4},{value:"<code>getRunningQueryThunk</code> and <code>getRunningMutationThunk</code>",id:"getrunningquerythunk-and-getrunningmutationthunk",level:2},{value:"Signature",id:"signature-10",level:4},{value:"Description",id:"description-10",level:4}];function o(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"\xa0"}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"api-slices-utilities",children:"API Slices: Utilities"})}),"\n",(0,a.jsxs)(n.p,{children:["The API slice object includes various utilities that can be used for cache management,\nsuch as implementing ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/manual-cache-updates#optimistic-updates",children:"optimistic updates"}),",\nas well implementing ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/server-side-rendering",children:"server side rendering"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["These are included as ",(0,a.jsx)(n.code,{children:"api.util"})," inside the API object."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Some of the TS types on this page are pseudocode to illustrate intent, as the actual internal types are fairly complex."})}),"\n",(0,a.jsx)(n.h3,{id:"updatequerydata",children:(0,a.jsx)(n.code,{children:"updateQueryData"})}),"\n",(0,a.jsx)(n.p,{children:"A Redux thunk action creator that, when dispatched, creates and applies a set of JSON diff/patch objects to the current state. This immediately updates the Redux state with those changes."}),"\n",(0,a.jsx)(n.h4,{id:"signature",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const updateQueryData = (\n  endpointName: string,\n  arg: any,\n  updateRecipe: (draft: Draft<CachedState>) => void,\n  updateProvided?: boolean,\n) => ThunkAction<PatchCollection, PartialState, any, AnyAction>\n\ninterface PatchCollection {\n  patches: Patch[]\n  inversePatches: Patch[]\n  undo: () => void\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpointName"}),": a string matching an existing endpoint name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arg"}),": an argument matching that used for a previous query call, used to determine which cached dataset needs to be updated"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateRecipe"}),": an Immer ",(0,a.jsx)(n.code,{children:"produce"})," callback that can apply changes to the cached state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateProvided"}),": a boolean indicating whether the endpoint's provided tags should be re-calculated based on the updated cache. Defaults to ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,a.jsx)(n.code,{children:"'getPost'"}),"), any relevant query arguments, and a callback function. The callback receives an Immer-wrapped ",(0,a.jsx)(n.code,{children:"draft"})," of the current state, and may modify the draft to match the expected results after the mutation completes successfully."]}),"\n",(0,a.jsxs)(n.p,{children:["The thunk returns an object containing ",(0,a.jsx)(n.code,{children:"{patches: Patch[], inversePatches: Patch[], undo: () => void}"}),". The ",(0,a.jsx)(n.code,{children:"patches"})," and ",(0,a.jsx)(n.code,{children:"inversePatches"})," are generated using Immer's ",(0,a.jsxs)(n.a,{href:"https://immerjs.github.io/immer/patches",children:[(0,a.jsx)(n.code,{children:"produceWithPatches"})," method"]}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["This is typically used as the first step in implementing optimistic updates. The generated ",(0,a.jsx)(n.code,{children:"inversePatches"})," can be used to revert the updates by calling ",(0,a.jsx)(n.code,{children:"dispatch(patchQueryData(endpointName, arg, inversePatches))"}),". Alternatively, the ",(0,a.jsx)(n.code,{children:"undo"})," method can be called directly to achieve the same effect."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that the first two arguments (",(0,a.jsx)(n.code,{children:"endpointName"})," and ",(0,a.jsx)(n.code,{children:"arg"}),") are used to determine which existing cache entry to update. If no existing cache entry is found, the ",(0,a.jsx)(n.code,{children:"updateRecipe"})," callback will not run."]}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example 1"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the example above, ",(0,a.jsx)(n.code,{children:"'getPosts'"})," is provided for the ",(0,a.jsx)(n.code,{children:"endpointName"}),", and ",(0,a.jsx)(n.code,{children:"undefined"})," is provided\nfor ",(0,a.jsx)(n.code,{children:"arg"}),". This will match a query cache key of ",(0,a.jsx)(n.code,{children:"'getPosts(undefined)'"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"i.e. it will match a cache entry that may have been created via any of the following calls:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"api.endpoints.getPosts.useQuery()\n\nuseGetPostsQuery()\n\nuseGetPostsQuery(undefined, { ...options })\n\ndispatch(api.endpoints.getPosts.initiate())\n\ndispatch(api.endpoints.getPosts.initiate(undefined, { ...options }))\n"})}),"\n",(0,a.jsx)(n.h4,{id:"example-2",children:"Example 2"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const patchCollection = dispatch(\n  api.util.updateQueryData('getPostById', 1, (draftPost) => {\n    draftPost.name = 'Lilly'\n  }),\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the example above, ",(0,a.jsx)(n.code,{children:"'getPostById'"})," is provided for the ",(0,a.jsx)(n.code,{children:"endpointName"}),", and ",(0,a.jsx)(n.code,{children:"1"})," is provided\nfor ",(0,a.jsx)(n.code,{children:"arg"}),". This will match a query cache key of ",(0,a.jsx)(n.code,{children:"'getPostById(1)'"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"i.e. it will match a cache entry that may have been created via any of the following calls:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"api.endpoints.getPostById.useQuery(1)\n\nuseGetPostByIdQuery(1)\n\nuseGetPostByIdQuery(1, { ...options })\n\ndispatch(api.endpoints.getPostById.initiate(1))\n\ndispatch(api.endpoints.getPostById.initiate(1, { ...options }))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"upsertquerydata",children:(0,a.jsx)(n.code,{children:"upsertQueryData"})}),"\n",(0,a.jsx)(n.p,{children:"A Redux thunk action creator that, when dispatched, acts as an artificial API request to upsert a value into the cache."}),"\n",(0,a.jsx)(n.h4,{id:"signature-1",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const upsertQueryData = <T>(endpointName: string, arg: any, newEntryData: T) =>\n  ThunkAction<Promise<CacheEntry<T>>, PartialState, any, UnknownAction>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpointName"}),": a string matching an existing endpoint name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arg"}),": an argument matching that used for a previous query call, used to determine which cached dataset needs to be updated"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"newEntryValue"}),": the value to be written into the corresponding cache entry's ",(0,a.jsx)(n.code,{children:"data"})," field"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-1",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,a.jsx)(n.code,{children:"'getPost'"}),"), the appropriate query arg values to construct the desired cache key, and the data to upsert."]}),"\n",(0,a.jsxs)(n.p,{children:["If no cache entry for that cache key exists, a cache entry will be created and the data added. If a cache entry already exists, this will ",(0,a.jsx)(n.em,{children:"overwrite"})," the existing cache entry data."]}),"\n",(0,a.jsxs)(n.p,{children:["The thunk executes ",(0,a.jsx)(n.em,{children:"asynchronously"}),", and returns a promise that resolves when the store has been updated. This includes executing the ",(0,a.jsx)(n.code,{children:"transformResponse"})," callback if defined for that endpoint."]}),"\n",(0,a.jsx)(n.p,{children:'If dispatched while an actual request is in progress, both the upsert and request will be handled as soon as they resolve, resulting in a "last result wins" update behavior.'}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"await dispatch(\n  api.util.upsertQueryData('getPost', { id: 1 }, { id: 1, text: 'Hello!' }),\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"patchquerydata",children:(0,a.jsx)(n.code,{children:"patchQueryData"})}),"\n",(0,a.jsx)(n.p,{children:"A Redux thunk action creator that, when dispatched, applies a JSON diff/patch array to the cached data for a given query result. This immediately updates the Redux state with those changes."}),"\n",(0,a.jsx)(n.h4,{id:"signature-2",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const patchQueryData = (\n  endpointName: string,\n  arg: any\n  patches: Patch[],\n  updateProvided?: boolean\n) => ThunkAction<void, PartialState, any, UnknownAction>;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpointName"}),": a string matching an existing endpoint name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arg"}),": a cache key, used to determine which cached dataset needs to be updated"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"patches"}),": an array of patches (or inverse patches) to apply to cached state. These would typically be obtained from the result of dispatching ",(0,a.jsx)(n.a,{href:"#updatequerydata",children:(0,a.jsx)(n.code,{children:"updateQueryData"})})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateProvided"}),": a boolean indicating whether the endpoint's provided tags should be re-calculated based on the updated cache. Defaults to ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-2",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,a.jsx)(n.code,{children:"'getPost'"}),"), the appropriate query arg values to construct the desired cache key, and a JSON diff/patch array as produced by Immer's ",(0,a.jsx)(n.code,{children:"produceWithPatches"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["This is typically used as the second step in implementing optimistic updates. If a request fails, the optimistically-applied changes can be reverted by dispatching ",(0,a.jsx)(n.code,{children:"patchQueryData"})," with the ",(0,a.jsx)(n.code,{children:"inversePatches"})," that were generated by ",(0,a.jsx)(n.code,{children:"updateQueryData"})," earlier."]}),"\n",(0,a.jsxs)(n.p,{children:["In cases where it is desired to simply revert the previous changes, it may be preferable to call the ",(0,a.jsx)(n.code,{children:"undo"})," method returned from dispatching ",(0,a.jsx)(n.code,{children:"updateQueryData"})," instead."]}),"\n",(0,a.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  }),\n)\n\n// later\ndispatch(\n  api.util.patchQueryData(\n    'getPosts',\n    undefined,\n    patchCollection.inversePatches,\n  ),\n)\n\n// or\npatchCollection.undo()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"upsertqueryentries",children:(0,a.jsx)(n.code,{children:"upsertQueryEntries"})}),"\n",(0,a.jsx)(n.p,{children:"A standard Redux action creator that accepts an array of individual cache entry descriptions, and immediately upserts them into the store. This is designed to efficiently bulk-insert many entries at once."}),"\n",(0,a.jsx)(n.h4,{id:"signature-3",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"/**\n * A typesafe single entry to be upserted into the cache\n */\nexport type NormalizedQueryUpsertEntry<\n  Definitions extends EndpointDefinitions,\n  EndpointName extends QueryKeys<Definitions>,\n> = {\n  endpointName: EndpointName\n  arg: QueryArgFrom<Definitions[EndpointName]>\n  value: ResultTypeFrom<Definitions[EndpointName]>\n}\n\nconst upsertQueryEntries = (entries: NormalizedQueryUpsertEntry[]) =>\n  PayloadAction<NormalizedQueryUpsertEntry[]>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"entries"}),": an array of objects that contain the data needed to upsert individual cache entries:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpointName"}),": the name of the endpoint, such as ",(0,a.jsx)(n.code,{children:'"getPokemon"'})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arg"}),": the full query key argument needed to identify this cache entry, such as ",(0,a.jsx)(n.code,{children:'"pikachu"'})," (same as you would pass to a ",(0,a.jsx)(n.code,{children:"useQuery"})," hook or ",(0,a.jsx)(n.code,{children:"api.endpoints.someEndpoint.select()"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"value"}),": the data to be upserted into this cache entry, exactly as formatted."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-3",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["This method is designed as a more efficient approach to bulk-inserting many entries at once than many individual calls to ",(0,a.jsx)(n.code,{children:"upsertQueryData"}),". As a comparison:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"upsertQueryData"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"upserts one cache entry at a time"}),"\n",(0,a.jsx)(n.li,{children:"Is async"}),"\n",(0,a.jsxs)(n.li,{children:["Dispatches 2 separate actions, ",(0,a.jsx)(n.code,{children:"pending"})," and ",(0,a.jsx)(n.code,{children:"fulfilled"})]}),"\n",(0,a.jsxs)(n.li,{children:["Runs the ",(0,a.jsx)(n.code,{children:"transformResponse"})," callback if defined for that endpoint, as well as the ",(0,a.jsx)(n.code,{children:"merge"})," callback if defined"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"upsertQueryEntries"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"upserts many cache entries at once, and they may be for any combination of endpoints defined in the API"}),"\n",(0,a.jsx)(n.li,{children:"Is a single synchronous action"}),"\n",(0,a.jsxs)(n.li,{children:["Does ",(0,a.jsx)(n.em,{children:"not"})," run ",(0,a.jsx)(n.code,{children:"transformResponse"}),", so the provided ",(0,a.jsx)(n.code,{children:"value"})," fields must already be in the final format expected for that endpoint. However, it will still run the ",(0,a.jsx)(n.code,{children:"merge"})," callback if defined"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['Currently, this method has two main use cases. The first is prefilling the cache with data retrieved from storage on app startup. The second is to act as a "pseudo-normalization" tool. ',(0,a.jsxs)(n.a,{href:"/rtk-query/usage/cache-behavior#no-normalized-or-de-duplicated-cache",children:["RTK Query is ",(0,a.jsx)(n.em,{children:"not"}),' a "normalized" cache']}),". However, there are times when you may want to prefill other cache entries with the contents of another endpoint, such as taking the results of a ",(0,a.jsx)(n.code,{children:"getPosts"})," list endpoint response and prefilling the individual ",(0,a.jsx)(n.code,{children:"getPost(id)"})," endpoint cache entries."]}),"\n",(0,a.jsxs)(n.p,{children:["If no cache entry for that cache key exists, a cache entry will be created and the data added. If a cache entry already exists, this will ",(0,a.jsx)(n.em,{children:"overwrite"})," the existing cache entry data."]}),"\n",(0,a.jsx)(n.p,{children:'If dispatched while an actual request is in progress, both the upsert and request will be handled as soon as they resolve, resulting in a "last result wins" update behavior.'}),"\n",(0,a.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const api = createApi({\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => '/posts',\n      async onQueryStarted(_, { dispatch, queryFulfilled }) {\n        const res = await queryFulfilled\n        const posts = res.data\n\n        // Pre-fill the individual post entries with the results\n        // from the list endpoint query\n        dispatch(\n          api.util.upsertQueryEntries(\n            posts.map((post) => ({\n              endpointName: 'getPost',\n              arg: { id: post.id },\n              value: post,\n            })),\n          ),\n        )\n      },\n    }),\n    getPost: build.query<Post, Pick<Post, 'id'>>({\n      query: (post) => `post/${post.id}`,\n    }),\n  }),\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"prefetch",children:(0,a.jsx)(n.code,{children:"prefetch"})}),"\n",(0,a.jsx)(n.p,{children:"A Redux thunk action creator that can be used to manually trigger pre-fetching of data."}),"\n",(0,a.jsx)(n.h4,{id:"signature-4",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type PrefetchOptions = { ifOlderThan?: false | number } | { force?: boolean }\n\nconst prefetch = (endpointName: string, arg: any, options: PrefetchOptions) =>\n  ThunkAction<void, any, any, UnknownAction>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-4",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpointName"}),": a string matching an existing endpoint name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"}),": a cache key, used to determine which cached dataset needs to be updated"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),": options to determine whether the request should be sent for a given situation:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ifOlderThan"}),": if specified, only runs the query if the difference between ",(0,a.jsx)(n.code,{children:"new Date()"})," and the last",(0,a.jsx)(n.code,{children:"fulfilledTimeStamp"})," is greater than the given value (in seconds)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"force"}),": if ",(0,a.jsx)(n.code,{children:"true"}),", it will ignore the ",(0,a.jsx)(n.code,{children:"ifOlderThan"})," value if it is set and the query will be run even if it exists in the cache."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-4",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,a.jsx)(n.code,{children:"'getPost'"}),"), any relevant query arguments, and a set of options used to determine if the data actually should be re-fetched based on cache staleness."]}),"\n",(0,a.jsxs)(n.p,{children:["React Hooks users will most likely never need to use this directly, as the ",(0,a.jsx)(n.code,{children:"usePrefetch"})," hook will dispatch the thunk action creator result internally as needed when you call the prefetching function supplied by the hook."]}),"\n",(0,a.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"dispatch(api.util.prefetch('getPosts', undefined, { force: true }))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"selectinvalidatedby",children:(0,a.jsx)(n.code,{children:"selectInvalidatedBy"})}),"\n",(0,a.jsx)(n.p,{children:"A selector function that can select query parameters to be invalidated."}),"\n",(0,a.jsx)(n.h4,{id:"signature-5",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"function selectInvalidatedBy(\n  state: RootState,\n  tags: ReadonlyArray<TagDescription<string>>,\n): Array<{\n  endpointName: string\n  originalArgs: any\n  queryCacheKey: QueryCacheKey\n}>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-5",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"state"}),": the root state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tags"}),": a readonly array of invalidated tags, where the provided ",(0,a.jsx)(n.code,{children:"TagDescription"})," is one of the strings provided to the ",(0,a.jsx)(n.a,{href:"/rtk-query/api/createApi#tagtypes",children:(0,a.jsx)(n.code,{children:"tagTypes"})})," property of the api. e.g.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[TagType]"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[{ type: TagType }]"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[{ type: TagType, id: number | string }]"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-5",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"The function accepts two arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the root state and"}),"\n",(0,a.jsx)(n.li,{children:"the cache tags to be invalidated."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"It returns an array that contains"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the endpoint name,"}),"\n",(0,a.jsx)(n.li,{children:"the original args and"}),"\n",(0,a.jsx)(n.li,{children:"the queryCacheKey."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-6",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const entries = api.util.selectInvalidatedBy(state, ['Post'])\nconst entries = api.util.selectInvalidatedBy(state, [{ type: 'Post', id: 1 }])\nconst entries = api.util.selectInvalidatedBy(state, [\n  { type: 'Post', id: 1 },\n  { type: 'Post', id: 4 },\n])\n"})}),"\n",(0,a.jsx)(n.h3,{id:"invalidatetags",children:(0,a.jsx)(n.code,{children:"invalidateTags"})}),"\n",(0,a.jsxs)(n.p,{children:["A Redux action creator that can be used to manually invalidate cache tags for ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching",children:"automated re-fetching"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"signature-6",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const invalidateTags = (\n  tags: Array<TagTypes | FullTagDescription<TagTypes>>,\n) => ({\n  type: string,\n  payload: tags,\n})\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-6",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tags"}),": an array of tags to be invalidated, where the provided ",(0,a.jsx)(n.code,{children:"TagType"})," is one of the strings provided to the ",(0,a.jsx)(n.a,{href:"/rtk-query/api/createApi#tagtypes",children:(0,a.jsx)(n.code,{children:"tagTypes"})})," property of the api. e.g.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[TagType]"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[{ type: TagType }]"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[{ type: TagType, id: number | string }]"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-6",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["The action creator accepts one argument: the cache tags to be invalidated. It returns an action with those tags as a payload, and the corresponding ",(0,a.jsx)(n.code,{children:"invalidateTags"})," action type for the api."]}),"\n",(0,a.jsxs)(n.p,{children:["Dispatching the result of this action creator will ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#invalidating-cache-data",children:"invalidate"})," the given tags, causing queries to automatically re-fetch if they are subscribed to cache data that ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#providing-cache-data",children:"provides"})," the corresponding tags."]}),"\n",(0,a.jsx)(n.h4,{id:"example-7",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"dispatch(api.util.invalidateTags(['Post']))\ndispatch(api.util.invalidateTags([{ type: 'Post', id: 1 }]))\ndispatch(\n  api.util.invalidateTags([\n    { type: 'Post', id: 1 },\n    { type: 'Post', id: 'LIST' },\n  ]),\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"selectcachedargsforquery",children:(0,a.jsx)(n.code,{children:"selectCachedArgsForQuery"})}),"\n",(0,a.jsx)(n.p,{children:"A selector function that can select arguments for currently cached queries."}),"\n",(0,a.jsx)(n.h4,{id:"signature-7",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"function selectCachedArgsForQuery(\n  state: RootState,\n  queryName: QueryName,\n): Array<QueryArg>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-7",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"state"}),": the root state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"queryName"}),": a string matching an existing query endpoint name"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"description-7",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"The function accepts two arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"the root state and"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"the name of the query"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"It returns an array that contains arguments used for each entry."}),"\n",(0,a.jsx)(n.h4,{id:"example-8",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const args = api.util.selectCachedArgsForQuery(state, 'getPosts')\n"})}),"\n",(0,a.jsx)(n.h3,{id:"resetapistate",children:(0,a.jsx)(n.code,{children:"resetApiState"})}),"\n",(0,a.jsx)(n.h4,{id:"signature-8",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const resetApiState = () => ({\n  type: string,\n  payload: undefined,\n})\n"})}),"\n",(0,a.jsx)(n.h4,{id:"description-8",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"A Redux action creator that can be dispatched to manually reset the api state completely. This will immediately remove all existing cache entries, and all queries will be considered 'uninitialized'."}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.a,{href:"/rtk-query/api/created-api/hooks",children:"hooks"})," also track state in local component state and might not fully be reset by ",(0,a.jsx)(n.code,{children:"resetApiState"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"example-9",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"dispatch(api.util.resetApiState())\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"getrunningqueriesthunk-and-getrunningmutationsthunk",children:[(0,a.jsx)(n.code,{children:"getRunningQueriesThunk"})," and ",(0,a.jsx)(n.code,{children:"getRunningMutationsThunk"})]}),"\n",(0,a.jsx)(n.h4,{id:"signature-9",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"getRunningQueriesThunk(): ThunkWithReturnValue<Array<QueryActionCreatorResult<any>>>\ngetRunningMutationsThunk(): ThunkWithReturnValue<Array<MutationActionCreatorResult<any>>>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"description-9",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"Thunks that (if dispatched) return either all running queries or mutations.\nThese returned values can be awaited like promises."}),"\n",(0,a.jsxs)(n.p,{children:["This is useful for SSR scenarios to await all queries (or mutations) triggered in any way, including via hook calls\nor manually dispatching ",(0,a.jsx)(n.code,{children:"initiate"})," actions."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Awaiting all currently running queries example"',children:"await Promise.all(dispatch(api.util.getRunningQueriesThunk()))\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"getrunningquerythunk-and-getrunningmutationthunk",children:[(0,a.jsx)(n.code,{children:"getRunningQueryThunk"})," and ",(0,a.jsx)(n.code,{children:"getRunningMutationThunk"})]}),"\n",(0,a.jsx)(n.h4,{id:"signature-10",children:"Signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"getRunningQueryThunk<EndpointName extends QueryKeys<Definitions>>(\n  endpointName: EndpointName,\n  args: QueryArgFrom<Definitions[EndpointName]>\n): ThunkWithReturnValue<\n  | QueryActionCreatorResult<\n      Definitions[EndpointName] & { type: 'query' }\n    >\n  | undefined\n>\n\ngetRunningMutationThunk<EndpointName extends MutationKeys<Definitions>>(\n  endpointName: EndpointName,\n  fixedCacheKeyOrRequestId: string\n): ThunkWithReturnValue<\n  | MutationActionCreatorResult<\n      Definitions[EndpointName] & { type: 'mutation' }\n    >\n  | undefined\n>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"description-10",children:"Description"}),"\n",(0,a.jsxs)(n.p,{children:["Thunks that (if dispatched) return a single running query (or mutation) for a given\nendpoint name + argument (or requestId/fixedCacheKey) combination, if it is currently running.\nIf it is not currently running, the function returns ",(0,a.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["These thunks are primarily added to add experimental support for suspense in the future.\nThey enable writing custom hooks that look up if RTK Query has already got a running query/mutation\nfor a certain endpoint/argument combination, and retrieving that to ",(0,a.jsx)(n.code,{children:"throw"})," it as a promise."]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8049:function(e,n,t){t.d(n,{Z:()=>s});var i=t("4246");t("7378");var a=t("4870");function s(e){let{children:n,hidden:t,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.Z)("tabItem_wHwb",s),hidden:t,children:n})}},5181:function(e,n,t){t.d(n,{Z:()=>y});var i=t("4246"),a=t("7378"),s=t("4870"),r=t("5403"),d=t("3620"),l=t("7090"),c=t("6180"),o=t("3418"),h=t("9073");function u(e){var n,t;return null!==(t=null===(n=a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==t?t:[]}function p(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var x=t("3344");function g(e){let{className:n,block:t,selectedValue:a,selectValue:d,tabValues:l}=e,c=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.o5)(),h=e=>{let n=e.currentTarget,t=l[c.indexOf(n)].value;t!==a&&(o(n),d(t))},u=e=>{var n,t;let i=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let t=c.indexOf(e.currentTarget)+1;i=null!==(n=c[t])&&void 0!==n?n:c[0];break}case"ArrowLeft":{let n=c.indexOf(e.currentTarget)-1;i=null!==(t=c[n])&&void 0!==t?t:c[c.length-1]}}null==i||i.focus()};return(0,i.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n),children:l.map(e=>{let{value:n,label:t,attributes:r}=e;return(0,i.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>c.push(e),onKeyDown:u,onClick:h,...r,className:(0,s.Z)("tabs__item","tabItem_l0OV",null==r?void 0:r.className,{"tabs__item--active":a===n}),children:null!=t?t:n},n)})})}function m(e){let{lazy:n,children:t,selectedValue:r}=e,d=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=d.find(e=>e.props.value===r);return e?(0,a.cloneElement)(e,{className:(0,s.Z)("margin-top--md",e.props.className)}):null}return(0,i.jsx)("div",{className:"margin-top--md",children:d.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function j(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:i}=e,s=function(e){let{values:n,children:t}=e;return(0,a.useMemo)(()=>{let e=null!=n?n:u(t).map(e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}});return!function(e){let n=(0,o.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,t])}(e),[r,x]=(0,a.useState)(()=>(function(e){var n;let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:i}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(t,'" but none of its children has the corresponding value. Available values are: ').concat(i.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return t}let a=null!==(n=i.find(e=>e.default))&&void 0!==n?n:i[0];if(!a)throw Error("Unexpected error: 0 tabValues");return a.value})({defaultValue:n,tabValues:s})),[g,m]=function(e){let{queryString:n=!1,groupId:t}=e,i=(0,d.k6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,c._X)(s),(0,a.useCallback)(e=>{if(!s)return;let n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})},[s,i])]}({queryString:t,groupId:i}),[j,y]=function(e){let{groupId:n}=e,t=n?"docusaurus.tab.".concat(n):null,[i,s]=(0,h.Nk)(t);return[i,(0,a.useCallback)(e=>{t&&s.set(e)},[t,s])]}({groupId:i}),f=(()=>{let e=null!=g?g:j;return p({value:e,tabValues:s})?e:null})();return(0,l.Z)(()=>{f&&x(f)},[f]),{selectedValue:r,selectValue:(0,a.useCallback)(e=>{if(!p({value:e,tabValues:s}))throw Error("Can't select invalid tab value=".concat(e));x(e),m(e),y(e)},[m,y,s]),tabValues:s}}(e);return(0,i.jsxs)("div",{className:(0,s.Z)("tabs-container","tabList_J5MA"),children:[(0,i.jsx)(g,{...n,...e}),(0,i.jsx)(m,{...n,...e})]})}function y(e){let n=(0,x.Z)();return(0,i.jsx)(j,{...e,children:u(e.children)},String(n))}},980:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return r}});var i=t(7378);let a={},s=i.createContext(a);function r(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);