"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["9296"],{3094:function(e,n,r){r.r(n),r.d(n,{default:()=>p,frontMatter:()=>l,metadata:()=>t,assets:()=>d,toc:()=>u,contentTitle:()=>c});var t=JSON.parse('{"id":"rtk-query/api/createApi","title":"createApi","description":"RTK Query > API: createApi reference","source":"@site/../docs/rtk-query/api/createApi.mdx","sourceDirName":"rtk-query/api","slug":"/rtk-query/api/createApi","permalink":"/rtk-query/api/createApi","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1747236559000,"frontMatter":{"id":"createApi","title":"createApi","sidebar_label":"createApi","hide_title":true,"description":"RTK Query > API: createApi reference"},"sidebar":"docs","previous":{"title":"Customizing createApi","permalink":"/rtk-query/usage/customizing-create-api"},"next":{"title":"fetchBaseQuery","permalink":"/rtk-query/api/fetchBaseQuery"}}'),a=r("4246"),i=r("980"),s=r("8049"),o=r("5181");let l={id:"createApi",title:"createApi",sidebar_label:"createApi",hide_title:!0,description:"RTK Query > API: createApi reference"},c="createApi",d={},u=[{value:"<code>createApi</code> Parameters",id:"createapi-parameters",level:2},{value:"<code>baseQuery</code>",id:"basequery",level:3},{value:"baseQuery function arguments",id:"basequery-function-arguments",level:4},{value:"baseQuery function signature",id:"basequery-function-signature",level:4},{value:"<code>endpoints</code>",id:"endpoints",level:3},{value:"Query endpoint definition",id:"query-endpoint-definition",level:4},{value:"Infinite Query endpoint definition",id:"infinite-query-endpoint-definition",level:4},{value:"Mutation endpoint definition",id:"mutation-endpoint-definition",level:4},{value:"How endpoints get used",id:"how-endpoints-get-used",level:4},{value:"<code>extractRehydrationInfo</code>",id:"extractrehydrationinfo",level:3},{value:"<code>tagTypes</code>",id:"tagtypes",level:3},{value:"<code>reducerPath</code>",id:"reducerpath",level:3},{value:"<code>serializeQueryArgs</code>",id:"serializequeryargs",level:3},{value:"<code>invalidationBehavior</code>",id:"invalidationbehavior",level:3},{value:"<code>keepUnusedDataFor</code>",id:"keepunuseddatafor",level:3},{value:"<code>refetchOnMountOrArgChange</code>",id:"refetchonmountorargchange",level:3},{value:"<code>refetchOnFocus</code>",id:"refetchonfocus",level:3},{value:"<code>refetchOnReconnect</code>",id:"refetchonreconnect",level:3},{value:"<code>onSchemaFailure</code>",id:"onschemafailure",level:3},{value:"<code>catchSchemaFailure</code>",id:"catchschemafailure",level:3},{value:"<code>skipSchemaValidation</code>",id:"skipschemavalidation",level:3},{value:"Endpoint Definition Parameters",id:"endpoint-definition-parameters",level:2},{value:"<code>query</code>",id:"query",level:3},{value:"<code>queryFn</code>",id:"queryfn",level:3},{value:"<code>queryFn</code> function arguments",id:"queryfn-function-arguments",level:4},{value:"<code>infiniteQueryOptions</code>",id:"infinitequeryoptions",level:3},{value:"<code>transformResponse</code>",id:"transformresponse",level:3},{value:"<code>transformErrorResponse</code>",id:"transformerrorresponse",level:3},{value:"<code>extraOptions</code>",id:"extraoptions",level:3},{value:"<code>providesTags</code>",id:"providestags",level:3},{value:"<code>invalidatesTags</code>",id:"invalidatestags",level:3},{value:"<code>keepUnusedDataFor</code>",id:"keepunuseddatafor-1",level:3},{value:"<code>serializeQueryArgs</code>",id:"serializequeryargs-1",level:3},{value:"<code>merge</code>",id:"merge",level:3},{value:"<code>forceRefetch</code>",id:"forcerefetch",level:3},{value:"<code>onQueryStarted</code>",id:"onquerystarted",level:3},{value:"Lifecycle API properties",id:"lifecycle-api-properties",level:4},{value:"<code>onCacheEntryAdded</code>",id:"oncacheentryadded",level:3},{value:"Cache Lifecycle API properties",id:"cache-lifecycle-api-properties",level:4},{value:"Schema Validation",id:"schema-validation",level:3},{value:"<code>argSchema</code>",id:"argschema",level:4},{value:"<code>responseSchema</code>",id:"responseschema",level:4},{value:"<code>rawResponseSchema</code>",id:"rawresponseschema",level:4},{value:"<code>errorResponseSchema</code>",id:"errorresponseschema",level:4},{value:"<code>rawErrorResponseSchema</code>",id:"rawerrorresponseschema",level:4},{value:"<code>metaSchema</code>",id:"metaschema",level:4},{value:"Return value",id:"return-value",level:2}];function h(e){let n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"\xa0"}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"createapi",children:(0,a.jsx)(n.code,{children:"createApi"})})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"createApi"}),' is the core of RTK Query\'s functionality. It allows you to define a set of "endpoints" that describe how to retrieve data from backend APIs and other async sources, including the configuration of how to fetch and transform that data. It generates ',(0,a.jsx)(n.a,{href:"/rtk-query/api/created-api/overview",children:'an "API slice" structure'})," that contains Redux logic (and optionally React hooks) that encapsulate the data fetching and caching process for you."]}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["Typically, you should only have one API slice per base URL that your application needs to communicate with. For example, if your site fetches data from both ",(0,a.jsx)(n.code,{children:"/api/posts"})," and ",(0,a.jsx)(n.code,{children:"/api/users"}),", you would have a single API slice with ",(0,a.jsx)(n.code,{children:"/api/"})," as the base URL, and separate endpoint definitions for ",(0,a.jsx)(n.code,{children:"posts"})," and ",(0,a.jsx)(n.code,{children:"users"}),". This allows you to effectively take advantage of ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching",children:"automated re-fetching"})," by defining ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#tags",children:"tag"})," relationships across endpoints."]}),(0,a.jsx)(n.p,{children:"This is because:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automatic tag invalidation only works within a single API slice. If you have multiple API slices, the automatic invalidation won't work across them."}),"\n",(0,a.jsxs)(n.li,{children:["Every ",(0,a.jsx)(n.code,{children:"createApi"})," call generates its own middleware, and each middleware added to the store will run checks against every dispatched action. That has a perf cost that adds up. So, if you called ",(0,a.jsx)(n.code,{children:"createApi"})," 10 times and added 10 separate API middleware to the store, that will be noticeably slower perf-wise."]}),"\n"]}),(0,a.jsxs)(n.p,{children:["For maintainability purposes, you may wish to split up endpoint definitions across multiple files, while still maintaining a single API slice which includes all of these endpoints. See ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/code-splitting",children:"code splitting"})," for how you can use the ",(0,a.jsx)(n.code,{children:"injectEndpoints"})," property to inject API endpoints from other files into a single API slice definition."]})]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Example: src/services/pokemon.ts"',children:"// Need to use the React-specific entry point to allow generating React hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Pokemon } from './types'\n\n// highlight-start\n// Define a service using a base URL and expected endpoints\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query<Pokemon, string>({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n//highlight-end\n\n// highlight-start\n// Export hooks for usage in function components, which are\n// auto-generated based on the defined endpoints\nexport const { useGetPokemonByNameQuery } = pokemonApi\n// highlight-end\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="Example: src/services/pokemon.js"',children:"// Need to use the React-specific entry point to allow generating React hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// highlight-start\n// Define a service using a base URL and expected endpoints\nexport const pokemonApi = createApi({\n  reducerPath: 'pokemonApi',\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getPokemonByName: build.query({\n      query: (name) => `pokemon/${name}`,\n    }),\n  }),\n})\n//highlight-end\n\n// highlight-start\n// Export hooks for usage in function components, which are\n// auto-generated based on the defined endpoints\nexport const { useGetPokemonByNameQuery } = pokemonApi\n// highlight-end\n"})})})]}),"\n",(0,a.jsxs)(n.h2,{id:"createapi-parameters",children:[(0,a.jsx)(n.code,{children:"createApi"})," Parameters"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"createApi"})," accepts a single configuration object parameter with the following options:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"  baseQuery(args: InternalQueryArgs, api: BaseQueryApi, extraOptions?: DefinitionExtraOptions): any;\n  endpoints(build: EndpointBuilder<InternalQueryArgs, TagTypes>): Definitions;\n  extractRehydrationInfo?: (\n    action: UnknownAction,\n    {\n      reducerPath,\n    }: {\n      reducerPath: ReducerPath\n    }\n  ) =>\n    | undefined\n    | CombinedState<Definitions, TagTypes, ReducerPath>\n  tagTypes?: readonly TagTypes[];\n  reducerPath?: ReducerPath;\n  serializeQueryArgs?: SerializeQueryArgs<InternalQueryArgs>;\n  keepUnusedDataFor?: number; // value is in seconds\n  refetchOnMountOrArgChange?: boolean | number; // value is in seconds\n  refetchOnFocus?: boolean;\n  refetchOnReconnect?: boolean;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"basequery",children:(0,a.jsx)(n.code,{children:"baseQuery"})}),"\n",(0,a.jsxs)(n.p,{children:["The base query used by each endpoint if no ",(0,a.jsx)(n.code,{children:"queryFn"})," option is specified. RTK Query exports a utility called ",(0,a.jsx)(n.a,{href:"./fetchBaseQuery",children:"fetchBaseQuery"})," as a lightweight wrapper around ",(0,a.jsx)(n.code,{children:"fetch"})," for common use-cases. See ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/customizing-queries",children:"Customizing Queries"})," if ",(0,a.jsx)(n.code,{children:"fetchBaseQuery"})," does not handle your requirements."]}),"\n",(0,a.jsx)(n.h4,{id:"basequery-function-arguments",children:"baseQuery function arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"})," - The return value of the ",(0,a.jsx)(n.code,{children:"query"})," function for a given endpoint"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"api"})," - The ",(0,a.jsx)(n.code,{children:"BaseQueryApi"})," object contains:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"signal"})," - An ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,a.jsx)(n.code,{children:"AbortSignal"})})," object that may be used to abort DOM requests and/or read whether the request is aborted."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"abort"})," - The ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort",children:(0,a.jsx)(n.code,{children:"abort()"})})," method of the AbortController attached to ",(0,a.jsx)(n.code,{children:"signal"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dispatch"})," - The ",(0,a.jsx)(n.code,{children:"store.dispatch"})," method for the corresponding Redux store"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getState"})," - A function that may be called to access the current store state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extra"})," - Provided as thunk.extraArgument to the configureStore getDefaultMiddleware option."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"endpoint"})," - The name of the endpoint."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"type"})," - Type of request (",(0,a.jsx)(n.code,{children:"query"})," or ",(0,a.jsx)(n.code,{children:"mutation"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forced"})," - Indicates if a query has been forced."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"queryCacheKey"}),"- The computed query cache key."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extraOptions"})," - The value of the optional ",(0,a.jsx)(n.code,{children:"extraOptions"})," property provided for a given endpoint"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"basequery-function-signature",children:"baseQuery function signature"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Base Query signature" no-transpile',children:"export type BaseQueryFn<\n  Args = any,\n  Result = unknown,\n  Error = unknown,\n  DefinitionExtraOptions = {},\n  Meta = {},\n> = (\n  args: Args,\n  api: BaseQueryApi,\n  extraOptions: DefinitionExtraOptions,\n) => MaybePromise<QueryReturnValue<Result, Error, Meta>>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  abort: (reason?: string) => void\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n  extra: unknown\n  endpoint: string\n  type: 'query' | 'mutation'\n  forced?: boolean\n}\n\nexport type QueryReturnValue<T = unknown, E = unknown, M = unknown> =\n  | {\n      error: E\n      data?: undefined\n      meta?: M\n    }\n  | {\n      error?: undefined\n      data: T\n      meta?: M\n    }\n"})}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"endpoints",children:(0,a.jsx)(n.code,{children:"endpoints"})}),"\n",(0,a.jsxs)(n.p,{children:["Endpoints are a set of operations that you want to perform against your server. You define them as an object using the builder syntax. There are three endpoint types: ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/queries",children:(0,a.jsx)(n.code,{children:"query"})}),", ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/infinite-queries",children:(0,a.jsx)(n.code,{children:"infiniteQuery"})})," and ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/mutations",children:(0,a.jsx)(n.code,{children:"mutation"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"#endpoint-definition-parameters",children:"Endpoint Definition Parameters"})," for details on individual properties."]}),"\n",(0,a.jsx)(n.h4,{id:"query-endpoint-definition",children:"Query endpoint definition"}),"\n",(0,a.jsxs)(n.p,{children:["Query endpoints (defined with ",(0,a.jsx)(n.code,{children:"build.query()"}),") are used to cache data fetched from the server."]}),"\n",(0,a.jsxs)(n.p,{children:["You must specify either a ",(0,a.jsx)(n.code,{children:"query"})," field (which will use the API's ",(0,a.jsx)(n.code,{children:"baseQuery"})," to make a request), or a ",(0,a.jsx)(n.code,{children:"queryFn"})," function with your own async logic. All other fields are optional."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Query endpoint definition" no-transpile',children:"export type FullTagDescription<TagType> = {\n  type: TagType\n  id?: number | string\n}\nexport type TagDescription<TagType> = TagType | FullTagDescription<TagType>\n\ntype TagDescriptionArray<TagTypes extends string> = ReadonlyArray<\n  TagDescription<TagTypes> | undefined | null\n>\n\nexport type ResultDescription<\n  TagTypes extends string,\n  ResultType,\n  QueryArg,\n  ErrorType,\n  MetaType,\n> =\n  | TagDescriptionArray<TagTypes>\n  | (\n  result: ResultType | undefined,\n  error: ErrorType | undefined,\n  arg: QueryArg,\n  meta: MetaType,\n) => TagDescriptionArray<TagTypes>\n\n\nexport type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  /* either `query` or `queryFn` can be present, but not both simultaneously */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  /* transformResponse only available with `query`, not `queryFn` */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  /* transformErrorResponse only available with `query`, not `queryFn` */\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  providesTags?: ResultDescription<\n    TagTypes,\n    ResultType,\n    QueryArg,\n    BaseQueryError<BaseQuery>\n  >\n\n  keepUnusedDataFor?: number\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n      updateCachedData, // available for query endpoints only\n    }: QueryCacheLifecycleApi,\n  ): Promise<void>\n\n  argSchema?: StandardSchemaV1<QueryArg>\n\n  /* only available with `query`, not `queryFn` */\n  rawResponseSchema?: StandardSchemaV1<BaseQueryResult<BaseQuery>>\n\n  responseSchema?: StandardSchemaV1<ResultType>\n\n  /* only available with `query`, not `queryFn` */\n  rawErrorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>\n\n  errorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>\n\n  metaSchema?: StandardSchemaV1<BaseQueryMeta<BaseQuery>>\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"infinite-query-endpoint-definition",children:"Infinite Query endpoint definition"}),"\n",(0,a.jsxs)(n.p,{children:["Infinite query endpoints (defined with ",(0,a.jsx)(n.code,{children:"build.infiniteQuery()"}),") are used to cache multi-page data sets from the server. They have all the same callbacks and options as standard query endpoints, but also require an additional ",(0,a.jsx)(n.a,{href:"#infinitequeryoptions",children:(0,a.jsx)(n.code,{children:"infiniteQueryOptions"})})," field to specify how to calculate the unique parameters to fetch each page."]}),"\n",(0,a.jsxs)(n.p,{children:['For infinite query endpoints, there is a separation between the "query arg" used for the cache key, and the "page param" used to fetch a specific page. For example, a Pokemon API endpoint might have a string query arg like ',(0,a.jsx)(n.code,{children:'"fire"'})," , but use a page number as the param to determine which page to fetch out of the results. The ",(0,a.jsx)(n.code,{children:"query"})," and ",(0,a.jsx)(n.code,{children:"queryFn"})," methods will receive a combined ",(0,a.jsx)(n.code,{children:"{queryArg, pageParam}"})," object as the argument, rather than just the ",(0,a.jsx)(n.code,{children:"queryArg"})," by itself."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Infinite Query endpoint definition" no-transpile',children:"export type PageParamFunction<DataType, PageParam, QueryArg> = (\n  firstPage: DataType,\n  allPages: Array<DataType>,\n  firstPageParam: PageParam,\n  allPageParams: Array<PageParam>,\n  queryArg: QueryArg,\n) => PageParam | undefined | null\n\ntype InfiniteQueryCombinedArg<QueryArg, PageParam> = {\n  queryArg: QueryArg\n  pageParam: PageParam\n}\n\nexport type InfiniteQueryDefinition<\n  QueryArg,\n  PageParam,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n> =\n  // Infinite queries have all the same options as query endpoints,\n  // but store the `{pages, pageParams}` structure, and receive an object\n  // with both `{queryArg, pageParam}` as the arg for `query` and `queryFn`.\n  QueryDefinition<\n    InfiniteQueryCombinedArg<QueryArg, PageParam>,\n    BaseQuery,\n    TagTypes,\n    InfiniteData<ResultType>\n  > & {\n    /**\n     * Required options to configure the infinite query behavior.\n     * `initialPageParam` and `getNextPageParam` are required, to\n     * ensure the infinite query can properly fetch the next page of data.\n     * `initialPageparam` may be specified when using the\n     * endpoint, to override the default value.\n     */\n    infiniteQueryOptions: {\n      /**\n       * The initial page parameter to use for the first page fetch.\n       */\n      initialPageParam: PageParam\n      /**\n       * This function is required to automatically get the next cursor for infinite queries.\n       * The result will also be used to determine the value of `hasNextPage`.\n       */\n      getNextPageParam: PageParamFunction<DataType, PageParam, QueryArg>\n      /**\n       * This function can be set to automatically get the previous cursor for infinite queries.\n       * The result will also be used to determine the value of `hasPreviousPage`.\n       */\n      getPreviousPageParam?: PageParamFunction<DataType, PageParam, QueryArg>\n      /**\n       * If specified, only keep this many pages in cache at once.\n       * If additional pages are fetched, older pages in the other\n       * direction will be dropped from the cache.\n       */\n      maxPages?: number\n    }\n  }\n"})}),"\n",(0,a.jsx)(n.h4,{id:"mutation-endpoint-definition",children:"Mutation endpoint definition"}),"\n",(0,a.jsxs)(n.p,{children:["Mutation endpoints (defined with ",(0,a.jsx)(n.code,{children:"build.mutation()"}),") are used to send updates to the server, and force invalidation and refetching of query endpoints."]}),"\n",(0,a.jsxs)(n.p,{children:["As with queries, you must specify either the ",(0,a.jsx)(n.code,{children:"query"})," option or the ",(0,a.jsx)(n.code,{children:"queryFn"})," async method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation endpoint definition" no-transpile',children:"export type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string,\n  Context = Record<string, any>,\n> = {\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n\n  /* either `query` or `queryFn` can be present, but not both simultaneously */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>,\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n\n  /* transformResponse only available with `query`, not `queryFn` */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): ResultType | Promise<ResultType>\n\n  /* transformErrorResponse only available with `query`, not `queryFn` */\n  transformErrorResponse?(\n    baseQueryReturnValue: BaseQueryError<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>,\n    arg: QueryArg,\n  ): unknown\n\n  extraOptions?: BaseQueryExtraOptions<BaseQuery>\n\n  invalidatesTags?: ResultDescription<TagTypes, ResultType, QueryArg>\n\n  onQueryStarted?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      queryFulfilled,\n      getCacheEntry,\n    }: MutationLifecycleApi,\n  ): Promise<void>\n\n  onCacheEntryAdded?(\n    arg: QueryArg,\n    {\n      dispatch,\n      getState,\n      extra,\n      requestId,\n      cacheEntryRemoved,\n      cacheDataLoaded,\n      getCacheEntry,\n    }: MutationCacheLifecycleApi,\n  ): Promise<void>\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"how-endpoints-get-used",children:"How endpoints get used"}),"\n",(0,a.jsxs)(n.p,{children:["When defining a key like ",(0,a.jsx)(n.code,{children:"getPosts"})," as shown below, it's important to know that this name will become exportable from ",(0,a.jsx)(n.code,{children:"api"})," and be able to referenced under ",(0,a.jsx)(n.code,{children:"api.endpoints.getPosts.useQuery()"}),", ",(0,a.jsx)(n.code,{children:"api.endpoints.getPosts.initiate()"})," and ",(0,a.jsx)(n.code,{children:"api.endpoints.getPosts.select()"}),". The same thing applies to ",(0,a.jsx)(n.code,{children:"mutation"}),"s but they reference ",(0,a.jsx)(n.code,{children:"useMutation"})," instead of ",(0,a.jsx)(n.code,{children:"useQuery"}),"."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : [],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query: (body) => ({\n        url: `posts`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n  }),\n})\n\n// Auto-generated hooks\nexport const { useGetPostsQuery, useAddPostMutation } = api\n\n// Possible exports\nexport const { endpoints, reducerPath, reducer, middleware } = api\n// reducerPath, reducer, middleware are only used in store configuration\n// endpoints will have:\n// endpoints.getPosts.initiate(), endpoints.getPosts.select(), endpoints.getPosts.useQuery()\n// endpoints.addPost.initiate(), endpoints.addPost.select(), endpoints.addPost.useMutation()\n// see `createApi` overview for _all exports_\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result ? result.map(({ id }) => ({ type: 'Posts', id })) : [],\n    }),\n    addPost: build.mutation({\n      query: (body) => ({\n        url: `posts`,\n        method: 'POST',\n        body,\n      }),\n      invalidatesTags: ['Posts'],\n    }),\n  }),\n})\n\n// Auto-generated hooks\nexport const { useGetPostsQuery, useAddPostMutation } = api\n\n// Possible exports\nexport const { endpoints, reducerPath, reducer, middleware } = api\n// reducerPath, reducer, middleware are only used in store configuration\n// endpoints will have:\n// endpoints.getPosts.initiate(), endpoints.getPosts.select(), endpoints.getPosts.useQuery()\n// endpoints.addPost.initiate(), endpoints.addPost.select(), endpoints.addPost.useMutation()\n// see `createApi` overview for _all exports_\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"extractrehydrationinfo",children:(0,a.jsx)(n.code,{children:"extractRehydrationInfo"})}),"\n",(0,a.jsxs)(n.p,{children:["A function that is passed every dispatched action. If this returns something other than ",(0,a.jsx)(n.code,{children:"undefined"}),",\nthat return value will be used to rehydrate fulfilled & errored queries."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="next-redux-wrapper rehydration example"',children:"import type { Action, PayloadAction } from '@reduxjs/toolkit'\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { HYDRATE } from 'next-redux-wrapper'\n\ntype RootState = any // normally inferred from state\n\nfunction isHydrateAction(action: Action): action is PayloadAction<RootState> {\n  return action.type === HYDRATE\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  extractRehydrationInfo(action, { reducerPath }): any {\n    if (isHydrateAction(action)) {\n      return action.payload[reducerPath]\n    }\n  },\n  // highlight-end\n  endpoints: (build) => ({\n    // omitted\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="next-redux-wrapper rehydration example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { HYDRATE } from 'next-redux-wrapper'\n\nfunction isHydrateAction(action) {\n  return action.type === HYDRATE\n}\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  extractRehydrationInfo(action, { reducerPath }) {\n    if (isHydrateAction(action)) {\n      return action.payload[reducerPath]\n    }\n  },\n  // highlight-end\n  endpoints: (build) => ({\n    // omitted\n  }),\n})\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/server-side-rendering",children:"Server Side Rendering"})," and\n",(0,a.jsx)(n.a,{href:"/rtk-query/usage/persistence-and-rehydration",children:"Persistence and Rehydration"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"tagtypes",children:(0,a.jsx)(n.code,{children:"tagTypes"})}),"\n",(0,a.jsxs)(n.p,{children:["An array of string tag type names. Specifying tag types is optional, but you should define them so that they can be used for caching and invalidation. When defining a tag type, you will be able to ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/automated-refetching#providing-tags",children:"provide"})," them with ",(0,a.jsx)(n.code,{children:"providesTags"})," and ",(0,a.jsx)(n.a,{href:"../../rtk-query/usage/automated-refetching#invalidating-tags",children:"invalidate"})," them with ",(0,a.jsx)(n.code,{children:"invalidatesTags"})," when configuring ",(0,a.jsx)(n.a,{href:"#endpoints",children:"endpoints"}),"."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  tagTypes: ['Post', 'User'],\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  // highlight-start\n  tagTypes: ['Post', 'User'],\n  // highlight-end\n  endpoints: (build) => ({\n    // ...endpoints\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"reducerpath",children:(0,a.jsx)(n.code,{children:"reducerPath"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"reducerPath"})," is a ",(0,a.jsx)(n.em,{children:"unique"})," key that your service will be mounted to in your store. If you call ",(0,a.jsx)(n.code,{children:"createApi"})," more than once in your application, you will need to provide a unique value each time. Defaults to ",(0,a.jsx)(n.code,{children:"'api'"}),"."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="apis.js"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst apiOne = createApi({\n  // highlight-start\n  reducerPath: 'apiOne',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n})\n\nconst apiTwo = createApi({\n  // highlight-start\n  reducerPath: 'apiTwo',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="apis.js"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst apiOne = createApi({\n  // highlight-start\n  reducerPath: 'apiOne',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n})\n\nconst apiTwo = createApi({\n  // highlight-start\n  reducerPath: 'apiTwo',\n  // highlight-end\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    // ...endpoints\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"serializequeryargs",children:(0,a.jsx)(n.code,{children:"serializeQueryArgs"})}),"\n",(0,a.jsx)(n.p,{children:"Accepts a custom function if you have a need to change the creation of cache keys for any reason."}),"\n",(0,a.jsx)(n.p,{children:"By default, this function will take the query arguments, sort object keys where applicable, stringify the result, and concatenate it with the endpoint name. This creates a cache key based on the combination of arguments + endpoint name (ignoring object key order), such that calling any given endpoint with the same arguments will result in the same cache key."}),"\n",(0,a.jsx)(n.h3,{id:"invalidationbehavior",children:(0,a.jsx)(n.code,{children:"invalidationBehavior"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"'delayed'"}),". This setting allows you to control when tags are invalidated after a mutation."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"'immediately'"}),": Queries are invalidated instantly after the mutation finished, even if they are running.\nIf the query provides tags that were invalidated while it ran, it won't be re-fetched."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"'delayed'"}),': Invalidation only happens after all queries and mutations are settled.\nThis ensures that queries are always invalidated correctly and automatically "batches" invalidations of concurrent mutations.\nNote that if you constantly have some queries (or mutations) running, this can delay tag invalidations indefinitely.']}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"keepunuseddatafor",children:(0,a.jsx)(n.code,{children:"keepUnusedDataFor"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"60"})," ",(0,a.jsx)(n.em,{children:"(this value is in seconds)"}),". This is how long RTK Query will keep your data cached for ",(0,a.jsx)(n.strong,{children:"after"})," the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then mount another component that makes the same request within the given time frame, the most recent value will be served from the cache."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="keepUnusedDataFor example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5,\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="keepUnusedDataFor example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5,\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"refetchonmountorargchange",children:(0,a.jsx)(n.code,{children:"refetchOnMountOrArgChange"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"false"}),". This setting allows you to control whether if a cached result is already available RTK Query will only serve a cached result, or if it should ",(0,a.jsx)(n.code,{children:"refetch"})," when set to ",(0,a.jsx)(n.code,{children:"true"})," or if an adequate amount of time has passed since the last successful query result."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"false"})," - Will not cause a query to be performed ",(0,a.jsx)(n.em,{children:"unless"})," it does not exist yet."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"true"})," - Will always refetch when a new subscriber to a query is added. Behaves the same as calling the ",(0,a.jsx)(n.code,{children:"refetch"})," callback or passing ",(0,a.jsx)(n.code,{children:"forceRefetch: true"})," in the action creator."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"number"})," - ",(0,a.jsx)(n.strong,{children:"Value is in seconds"}),". If a number is provided and there is an existing query in the cache, it will compare the current time vs the last fulfilled timestamp, and only refetch if enough time has elapsed."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["If you specify this option alongside ",(0,a.jsx)(n.code,{children:"skip: true"}),", this ",(0,a.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,a.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"refetchOnMountOrArgChange"})," to each individual hook call or similarly by passing ",(0,a.jsx)(n.code,{children:"forceRefetch: true"})," when dispatching the ",(0,a.jsx)(n.a,{href:"/rtk-query/api/created-api/endpoints#initiate",children:(0,a.jsx)(n.code,{children:"initiate"})})," action."]})}),"\n",(0,a.jsx)(n.h3,{id:"refetchonfocus",children:(0,a.jsx)(n.code,{children:"refetchOnFocus"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"false"}),". This setting allows you to control whether RTK Query will try to refetch all subscribed queries after the application window regains focus."]}),"\n",(0,a.jsxs)(n.p,{children:["If you specify this option alongside ",(0,a.jsx)(n.code,{children:"skip: true"}),", this ",(0,a.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,a.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,a.jsxs)(n.p,{children:["Note: requires ",(0,a.jsx)(n.a,{href:"./setupListeners",children:(0,a.jsx)(n.code,{children:"setupListeners"})})," to have been called."]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"refetchOnFocus"})," to each individual hook call or when dispatching the ",(0,a.jsx)(n.a,{href:"/rtk-query/api/created-api/endpoints#initiate",children:(0,a.jsx)(n.code,{children:"initiate"})})," action."]}),(0,a.jsxs)(n.p,{children:["If you specify ",(0,a.jsx)(n.code,{children:"track: false"})," when manually dispatching queries, RTK Query will not be able to automatically refetch for you."]})]}),"\n",(0,a.jsx)(n.h3,{id:"refetchonreconnect",children:(0,a.jsx)(n.code,{children:"refetchOnReconnect"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"false"}),". This setting allows you to control whether RTK Query will try to refetch all subscribed queries after regaining a network connection."]}),"\n",(0,a.jsxs)(n.p,{children:["If you specify this option alongside ",(0,a.jsx)(n.code,{children:"skip: true"}),", this ",(0,a.jsx)(n.strong,{children:"will not be evaluated"})," until ",(0,a.jsx)(n.code,{children:"skip"})," is false."]}),"\n",(0,a.jsxs)(n.p,{children:["Note: requires ",(0,a.jsx)(n.a,{href:"./setupListeners",children:(0,a.jsx)(n.code,{children:"setupListeners"})})," to have been called."]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"refetchOnReconnect"})," to each individual hook call or when dispatching the ",(0,a.jsx)(n.a,{href:"/rtk-query/api/created-api/endpoints#initiate",children:(0,a.jsx)(n.code,{children:"initiate"})})," action."]}),(0,a.jsxs)(n.p,{children:["If you specify ",(0,a.jsx)(n.code,{children:"track: false"})," when manually dispatching queries, RTK Query will not be able to automatically refetch for you."]})]}),"\n",(0,a.jsx)(n.h3,{id:"onschemafailure",children:(0,a.jsx)(n.code,{children:"onSchemaFailure"})}),"\n",(0,a.jsx)(n.p,{children:"A function that is called when a schema validation fails."}),"\n",(0,a.jsxs)(n.p,{children:["Gets called with a ",(0,a.jsx)(n.code,{children:"NamedSchemaError"})," and an object containing the endpoint name, the type of the endpoint, the argument passed to the endpoint, and the query cache key (if applicable)."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"NamedSchemaError"})," has the following properties:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"issues"}),": an array of issues that caused the validation to fail"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"value"}),": the value that was passed to the schema"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"schemaName"}),": the name of the schema that was used to validate the value (e.g. ",(0,a.jsx)(n.code,{children:"argSchema"}),")"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"import { createApi } from '@reduxjs/toolkit/query/react'\nimport * as v from \"valibot\"\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n    }),\n  }),\n  onSchemaFailure: (error, info) => {\n    console.error(error, info)\n  },\n})\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"onSchemaFailure"})," to each individual endpoint definition."]})}),"\n",(0,a.jsx)(n.h3,{id:"catchschemafailure",children:(0,a.jsx)(n.code,{children:"catchSchemaFailure"})}),"\n",(0,a.jsx)(n.p,{children:"Convert a schema validation failure into an error shape matching base query errors."}),"\n",(0,a.jsx)(n.p,{children:"When not provided, schema failures are treated as fatal, and normal error handling such as tag invalidation will not be executed."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'import { createApi } from \'@reduxjs/toolkit/query/react\'\nimport * as v from "valibot"\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: \'/\' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: v.object({ id: v.number(), name: v.string() }),\n    }),\n  }),\n  catchSchemaFailure: (error, info) => ({\n    status: "CUSTOM_ERROR",\n    error: error.schemaName + " failed validation",\n    data: error.issues,\n  }),\n})\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"catchSchemaFailure"})," to each individual endpoint definition."]})}),"\n",(0,a.jsx)(n.h3,{id:"skipschemavalidation",children:(0,a.jsx)(n.code,{children:"skipSchemaValidation"})}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If set to ",(0,a.jsx)(n.code,{children:"true"}),", will skip schema validation for all endpoints, unless overridden by the endpoint."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"import { createApi } from '@reduxjs/toolkit/query/react'\nimport * as v from \"valibot\"\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  skipSchemaValidation: process.env.NODE_ENV === \"test\", // skip schema validation in tests, since we'll be mocking the response\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: v.object({ id: v.number(), name: v.string() }),\n    }),\n  })\n})\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["You can set this globally in ",(0,a.jsx)(n.code,{children:"createApi"}),", but you can also override the default value and have more granular control by passing ",(0,a.jsx)(n.code,{children:"skipSchemaValidation"})," to each individual endpoint definition."]})}),"\n",(0,a.jsx)(n.h2,{id:"endpoint-definition-parameters",children:"Endpoint Definition Parameters"}),"\n",(0,a.jsx)(n.h3,{id:"query",children:(0,a.jsx)(n.code,{children:"query"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(required if no ",(0,a.jsx)(n.code,{children:"queryFn"})," provided)"]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="query signature" no-transpile',children:"export type query = <QueryArg>(\n  arg: QueryArg,\n) => string | Record<string, unknown>\n\n// with `fetchBaseQuery`\nexport type query = <QueryArg>(arg: QueryArg) => string | FetchArgs\n"})}),"\n",(0,a.jsx)(n.h3,{id:"queryfn",children:(0,a.jsx)(n.code,{children:"queryFn"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(required if no ",(0,a.jsx)(n.code,{children:"query"})," provided)"]})}),"\n",(0,a.jsxs)(n.p,{children:["Called with the same arguments as ",(0,a.jsx)(n.code,{children:"baseQuery"}),", as well as the provided ",(0,a.jsx)(n.code,{children:"baseQuery"})," function itself. It is expected to return an object with either a ",(0,a.jsx)(n.code,{children:"data"})," or ",(0,a.jsx)(n.code,{children:"error"})," property, or a promise that resolves to return such an object."]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/customizing-queries#customizing-queries-with-queryfn",children:"Customizing queries with queryFn"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="queryFn signature" no-transpile',children:"queryFn(\n  arg: QueryArg,\n  api: BaseQueryApi,\n  extraOptions: BaseQueryExtraOptions<BaseQuery>,\n  baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>\n): MaybePromise<\n| {\n    error: BaseQueryError<BaseQuery>\n    data?: undefined\n  }\n| {\n    error?: undefined\n    data: ResultType\n  }\n>\n\nexport interface BaseQueryApi {\n  signal: AbortSignal\n  dispatch: ThunkDispatch<any, any, any>\n  getState: () => unknown\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"queryfn-function-arguments",children:[(0,a.jsx)(n.code,{children:"queryFn"})," function arguments"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"})," - The argument provided when the query itself is called"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"api"})," - The ",(0,a.jsx)(n.code,{children:"BaseQueryApi"})," object, containing ",(0,a.jsx)(n.code,{children:"signal"}),", ",(0,a.jsx)(n.code,{children:"dispatch"})," and ",(0,a.jsx)(n.code,{children:"getState"})," properties","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"signal"})," - An ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,a.jsx)(n.code,{children:"AbortSignal"})})," object that may be used to abort DOM requests and/or read whether the request is aborted."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dispatch"})," - The ",(0,a.jsx)(n.code,{children:"store.dispatch"})," method for the corresponding Redux store"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getState"})," - A function that may be called to access the current store state"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extraOptions"})," - The value of the optional ",(0,a.jsx)(n.code,{children:"extraOptions"})," property provided for the endpoint"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"baseQuery"})," - The ",(0,a.jsx)(n.code,{children:"baseQuery"})," function provided to the api itself"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"infinitequeryoptions",children:(0,a.jsx)(n.code,{children:"infiniteQueryOptions"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(only for ",(0,a.jsx)(n.code,{children:"infiniteQuery"})," endpoints)"]})}),"\n",(0,a.jsxs)(n.p,{children:["Required options to configure the infinite query behavior.\n",(0,a.jsx)(n.code,{children:"initialPageParam"})," and ",(0,a.jsx)(n.code,{children:"getNextPageParam"})," are required, to\nensure the infinite query can properly fetch the next page of data.\n",(0,a.jsx)(n.code,{children:"initialPageParam"})," may be specified when using the\nendpoint, to override the default value.\n",(0,a.jsx)(n.code,{children:"maxPages"})," and ",(0,a.jsx)(n.code,{children:"getPreviousPageParam"})," are both optional."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"infiniteQueryOptions"})," field includes:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"initialPageParam"}),": the default page param value used for the first request, if this was not specified at the usage site"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getNextPageParam"}),": a required callback you must provide to calculate the next page param, given the existing cached pages and page params"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getPreviousPageParam"}),": an optional callback that will be used to calculate the previous page param, if you try to fetch backwards."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"maxPages"}),": an optional limit to how many fetched pages will be kept in the cache entry at a time"]}),"\n"]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="infiniteQueryOptions example"',children:"import {\n  createApi,\n  fetchBaseQuery,\n  defaultSerializeQueryArgs,\n} from '@reduxjs/toolkit/query/react'\n\ntype Pokemon = {\n  id: string\n  name: string\n}\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getInfinitePokemonWithMax: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        initialPageParam: 0,\n        maxPages: 3,\n        getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n          lastPageParam + 1,\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      query({ pageParam }) {\n        return `https://example.com/listItems?page=${pageParam}`\n      },\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="infiniteQueryOptions example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),\n  endpoints: (build) => ({\n    getInfinitePokemonWithMax: build.infiniteQuery({\n      infiniteQueryOptions: {\n        initialPageParam: 0,\n        maxPages: 3,\n        getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n          lastPageParam + 1,\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      query({ pageParam }) {\n        return `https://example.com/listItems?page=${pageParam}`\n      },\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"transformresponse",children:(0,a.jsx)(n.code,{children:"transformResponse"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(optional, not applicable with ",(0,a.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,a.jsxs)(n.p,{children:["In some cases, you may want to manipulate the data returned from a query before you put it in the cache. In this instance, you can take advantage of ",(0,a.jsx)(n.code,{children:"transformResponse"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsxs)(n.a,{href:"/rtk-query/usage/customizing-queries#customizing-query-responses-with-transformresponse",children:["Customizing query responses with ",(0,a.jsx)(n.code,{children:"transformResponse"})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested collection" no-transpile',children:"transformResponse: (response, meta, arg) =>\n  response.some.deeply.nested.collection\n"})}),"\n",(0,a.jsx)(n.h3,{id:"transformerrorresponse",children:(0,a.jsx)(n.code,{children:"transformErrorResponse"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(optional, not applicable with ",(0,a.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,a.jsxs)(n.p,{children:["In some cases, you may want to manipulate the error returned from a query before you put it in the cache. In this instance, you can take advantage of ",(0,a.jsx)(n.code,{children:"transformErrorResponse"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsxs)(n.a,{href:"/rtk-query/usage/customizing-queries#customizing-query-responses-with-transformerrorresponse",children:["Customizing query responses with ",(0,a.jsx)(n.code,{children:"transformErrorResponse"})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Unpack a deeply nested error object" no-transpile',children:"transformErrorResponse: (response, meta, arg) =>\n  response.data.some.deeply.nested.errorObject\n"})}),"\n",(0,a.jsx)(n.h3,{id:"extraoptions",children:(0,a.jsx)(n.code,{children:"extraOptions"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["Passed as the third argument to the supplied ",(0,a.jsx)(n.code,{children:"baseQuery"})," function"]}),"\n",(0,a.jsx)(n.h3,{id:"providestags",children:(0,a.jsx)(n.code,{children:"providesTags"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,a.jsxs)(n.p,{children:["Used by ",(0,a.jsx)(n.code,{children:"query"})," endpoints. Determines which 'tag' is attached to the cached data returned by the query.\nExpects an array of tag type strings, an array of objects of tag types with ids, or a function that returns such an array."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"['Post']"})," - equivalent to ",(0,a.jsx)(n.code,{children:"2"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"[{ type: 'Post' }]"})," - equivalent to ",(0,a.jsx)(n.code,{children:"1"})]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[{ type: 'Post', id: 1 }]"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"(result, error, arg) => ['Post']"})," - equivalent to ",(0,a.jsx)(n.code,{children:"5"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"(result, error, arg) => [{ type: 'Post' }]"})," - equivalent to ",(0,a.jsx)(n.code,{children:"4"})]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"(result, error, arg) => [{ type: 'Post', id: 1 }]"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#providing-cache-data",children:"Providing cache data"}),"."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="providesTags example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="providesTags example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      // highlight-start\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts', id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"invalidatestags",children:(0,a.jsx)(n.code,{children:"invalidatesTags"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for mutation endpoints)"})}),"\n",(0,a.jsxs)(n.p,{children:["Used by ",(0,a.jsx)(n.code,{children:"mutation"})," endpoints. Determines which cached data should be either re-fetched or removed from the cache.\nExpects the same shapes as ",(0,a.jsx)(n.code,{children:"providesTags"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/automated-refetching#invalidating-cache-data",children:"Invalidating cache data"}),"."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="invalidatesTags example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation<Post, Partial<Post>>({\n      query(body) {\n        return {\n          url: `posts`,\n          method: 'POST',\n          body,\n        }\n      },\n      // highlight-start\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="invalidatesTags example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Posts'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Posts', id })),\n              { type: 'Posts', id: 'LIST' },\n            ]\n          : [{ type: 'Posts', id: 'LIST' }],\n    }),\n    addPost: build.mutation({\n      query(body) {\n        return {\n          url: `posts`,\n          method: 'POST',\n          body,\n        }\n      },\n      // highlight-start\n      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"keepunuseddatafor-1",children:(0,a.jsx)(n.code,{children:"keepUnusedDataFor"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,a.jsxs)(n.p,{children:["Overrides the api-wide definition of ",(0,a.jsx)(n.code,{children:"keepUnusedDataFor"})," for this endpoint only."]}),"\n",(0,a.jsxs)(n.p,{children:["Defaults to ",(0,a.jsx)(n.code,{children:"60"})," ",(0,a.jsx)(n.em,{children:"(this value is in seconds)"}),". This is how long RTK Query will keep your data cached for ",(0,a.jsx)(n.strong,{children:"after"})," the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then mount another component that makes the same request within the given time frame, the most recent value will be served from the cache."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="keepUnusedDataFor example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5,\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="keepUnusedDataFor example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      // highlight-start\n      keepUnusedDataFor: 5,\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"serializequeryargs-1",children:(0,a.jsx)(n.code,{children:"serializeQueryArgs"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,a.jsx)(n.p,{children:"Can be provided to return a custom cache key value based on the query arguments."}),"\n",(0,a.jsx)(n.p,{children:"This is primarily intended for cases where a non-serializable value is passed as part of the query arg object and should be excluded from the cache key.  It may also be used for cases where an endpoint should only have a single cache entry, such as an infinite loading / pagination implementation."}),"\n",(0,a.jsxs)(n.p,{children:["Unlike the ",(0,a.jsx)(n.code,{children:"createApi"})," version which can ",(0,a.jsx)(n.em,{children:"only"})," return a string, this per-endpoint option can also return an an object, number, or boolean.  If it returns a string, that value will be used as the cache key directly.  If it returns an object / number / boolean, that value will be passed to the built-in ",(0,a.jsx)(n.code,{children:"defaultSerializeQueryArgs"}),".  This simplifies the use case of stripping out args you don't want included in the cache key."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="serializeQueryArgs : exclude value"',children:"import {\n  createApi,\n  fetchBaseQuery,\n  defaultSerializeQueryArgs,\n} from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ninterface MyApiClient {\n  fetchPost: (id: string) => Promise<Post>\n}\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    // Example: an endpoint with an API client passed in as an argument,\n    // but only the item ID should be used as the cache key\n    getPost: build.query<Post, { id: string; client: MyApiClient }>({\n      queryFn: async ({ id, client }) => {\n        const post = await client.fetchPost(id)\n        return { data: post }\n      },\n      // highlight-start\n      serializeQueryArgs: ({ queryArgs, endpointDefinition, endpointName }) => {\n        const { id } = queryArgs\n        // This can return a string, an object, a number, or a boolean.\n        // If it returns an object, number or boolean, that value\n        // will be serialized automatically via `defaultSerializeQueryArgs`\n        return { id } // omit `client` from the cache key\n\n        // Alternately, you can use `defaultSerializeQueryArgs` yourself:\n        // return defaultSerializeQueryArgs({\n        //   endpointName,\n        //   queryArgs: { id },\n        //   endpointDefinition\n        // })\n        // Or  create and return a string yourself:\n        // return `getPost(${id})`\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="serializeQueryArgs : exclude value"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    // Example: an endpoint with an API client passed in as an argument,\n    // but only the item ID should be used as the cache key\n    getPost: build.query({\n      queryFn: async ({ id, client }) => {\n        const post = await client.fetchPost(id)\n        return { data: post }\n      },\n      // highlight-start\n      serializeQueryArgs: ({ queryArgs, endpointDefinition, endpointName }) => {\n        const { id } = queryArgs\n        // This can return a string, an object, a number, or a boolean.\n        // If it returns an object, number or boolean, that value\n        // will be serialized automatically via `defaultSerializeQueryArgs`\n        return { id } // omit `client` from the cache key\n\n        // Alternately, you can use `defaultSerializeQueryArgs` yourself:\n        // return defaultSerializeQueryArgs({\n        //   endpointName,\n        //   queryArgs: { id },\n        //   endpointDefinition\n        // })\n        // Or  create and return a string yourself:\n        // return `getPost(${id})`\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"merge",children:(0,a.jsx)(n.code,{children:"merge"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,a.jsx)(n.p,{children:"Can be provided to merge an incoming response value into the current cache data.\nIf supplied, no automatic structural sharing will be applied - it's up to\nyou to update the cache appropriately."}),"\n",(0,a.jsxs)(n.p,{children:["Since RTKQ normally replaces cache entries with the new response, you will usually\nneed to use this with the ",(0,a.jsx)(n.code,{children:"serializeQueryArgs"})," or ",(0,a.jsx)(n.code,{children:"forceRefetch"})," options to keep\nan existing cache entry so that it can be updated."]}),"\n",(0,a.jsxs)(n.p,{children:["Since this is wrapped with Immer, you may either mutate the ",(0,a.jsx)(n.code,{children:"currentCacheValue"})," directly,\nor return a new value, but ",(0,a.jsx)(n.em,{children:"not"})," both at once."]}),"\n",(0,a.jsxs)(n.p,{children:["Will only be called if the existing ",(0,a.jsx)(n.code,{children:"currentCacheData"})," is ",(0,a.jsx)(n.em,{children:"not"})," ",(0,a.jsx)(n.code,{children:"undefined"})," - on first response,\nthe cache entry will just save the response data directly."]}),"\n",(0,a.jsx)(n.p,{children:"Useful if you don't want a new request to completely override the current cache value,\nmaybe because you have manually updated it from another source and don't want those\nupdates to get lost."}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="merge: pagination"',children:"import {\n  createApi,\n  fetchBaseQuery,\n  defaultSerializeQueryArgs,\n} from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    listItems: build.query<string[], number>({\n      query: (pageNumber) => `/listItems?page=${pageNumber}`,\n      // Only have one cache entry because the arg always maps to one string\n      serializeQueryArgs: ({ endpointName }) => {\n        return endpointName\n      },\n      // Always merge incoming data to the cache entry\n      merge: (currentCache, newItems) => {\n        currentCache.push(...newItems)\n      },\n      // Refetch when the page arg changes\n      forceRefetch({ currentArg, previousArg }) {\n        return currentArg !== previousArg\n      },\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="merge: pagination"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    listItems: build.query({\n      query: (pageNumber) => `/listItems?page=${pageNumber}`,\n      // Only have one cache entry because the arg always maps to one string\n      serializeQueryArgs: ({ endpointName }) => {\n        return endpointName\n      },\n      // Always merge incoming data to the cache entry\n      merge: (currentCache, newItems) => {\n        currentCache.push(...newItems)\n      },\n      // Refetch when the page arg changes\n      forceRefetch({ currentArg, previousArg }) {\n        return currentArg !== previousArg\n      },\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"forcerefetch",children:(0,a.jsx)(n.code,{children:"forceRefetch"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional, only for query endpoints)"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="forceRefetch signature" no-transpile',children:"type forceRefetch = (params: {\n  currentArg: QueryArg | undefined\n  previousArg: QueryArg | undefined\n  state: RootState<any, any, string>\n  endpointState?: QuerySubState<any>\n}) => boolean\n"})}),"\n",(0,a.jsxs)(n.p,{children:['Check to see if the endpoint should force a refetch in cases where it normally wouldn\'t.\nThis is primarily useful for "infinite scroll" / pagination use cases where\nRTKQ is keeping a single cache entry that is added to over time, in combination\nwith ',(0,a.jsx)(n.code,{children:"serializeQueryArgs"})," returning a fixed cache key and a ",(0,a.jsx)(n.code,{children:"merge"})," callback\nset to add incoming data to the cache entry each time."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="forceRefresh: pagination"',children:"import {\n  createApi,\n  fetchBaseQuery,\n  defaultSerializeQueryArgs,\n} from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    listItems: build.query<string[], number>({\n      query: (pageNumber) => `/listItems?page=${pageNumber}`,\n      // Only have one cache entry because the arg always maps to one string\n      serializeQueryArgs: ({ endpointName }) => {\n        return endpointName\n      },\n      // Always merge incoming data to the cache entry\n      merge: (currentCache, newItems) => {\n        currentCache.push(...newItems)\n      },\n      // Refetch when the page arg changes\n      forceRefetch({ currentArg, previousArg }) {\n        return currentArg !== previousArg\n      },\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="forceRefresh: pagination"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\ncreateApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    listItems: build.query({\n      query: (pageNumber) => `/listItems?page=${pageNumber}`,\n      // Only have one cache entry because the arg always maps to one string\n      serializeQueryArgs: ({ endpointName }) => {\n        return endpointName\n      },\n      // Always merge incoming data to the cache entry\n      merge: (currentCache, newItems) => {\n        currentCache.push(...newItems)\n      },\n      // Refetch when the page arg changes\n      forceRefetch({ currentArg, previousArg }) {\n        return currentArg !== previousArg\n      },\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"onquerystarted",children:(0,a.jsx)(n.code,{children:"onQueryStarted"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["Available to both ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/queries",children:"queries"})," and ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/mutations",children:"mutations"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["A function that is called when you start each individual query or mutation. The function is called with a lifecycle api object containing properties such as ",(0,a.jsx)(n.code,{children:"queryFulfilled"}),", allowing code to be run when a query is started, when it succeeds, and when it fails (i.e. throughout the lifecycle of an individual query/mutation call)."]}),"\n",(0,a.jsxs)(n.p,{children:["Can be used in ",(0,a.jsx)(n.code,{children:"mutations"})," for ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/manual-cache-updates#optimistic-updates",children:"optimistic updates"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"lifecycle-api-properties",children:"Lifecycle API properties"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dispatch"})," - The dispatch method for the store."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getState"})," - A method to get the current state for the store."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extra"})," - ",(0,a.jsx)(n.code,{children:"extra"})," as provided as ",(0,a.jsx)(n.code,{children:"thunk.extraArgument"})," to the ",(0,a.jsx)(n.code,{children:"configureStore"})," ",(0,a.jsx)(n.code,{children:"getDefaultMiddleware"})," option."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"requestId"})," - A unique ID generated for the query/mutation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"queryFulfilled"})," - A Promise that will resolve with a ",(0,a.jsx)(n.code,{children:"data"})," property (the transformed query result),\nand a ",(0,a.jsx)(n.code,{children:"meta"})," property (",(0,a.jsx)(n.code,{children:"meta"})," returned by the ",(0,a.jsx)(n.code,{children:"baseQuery"}),").\nIf the query fails, this Promise will reject with the error. This allows you to ",(0,a.jsx)(n.code,{children:"await"})," for the query to finish."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getCacheEntry"})," - A function that gets the current value of the cache entry."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateCachedData"})," ",(0,a.jsx)(n.em,{children:"(query endpoints only)"})," - A function that accepts a 'recipe' callback specifying how to update the data for the corresponding cache at the time it is called. This uses ",(0,a.jsx)(n.code,{children:"immer"})," internally, and updates can be written 'mutably' while safely producing the next immutable state."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation onQueryStarted signature" no-transpile',children:"async function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n  }: MutationLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Query onQueryStarted signature" no-transpile',children:"async function onQueryStarted(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    queryFulfilled,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,a.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="onQueryStarted query lifecycle example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { messageCreated } from './notificationsSlice'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        // `onStart` side-effect\n        dispatch(messageCreated('Fetching post...'))\n        try {\n          const { data } = await queryFulfilled\n          // `onSuccess` side-effect\n          dispatch(messageCreated('Post received!'))\n        } catch (err) {\n          // `onError` side-effect\n          dispatch(messageCreated('Error fetching post!'))\n        }\n      },\n    }),\n  }),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="onQueryStarted query lifecycle example"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { messageCreated } from './notificationsSlice'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        // `onStart` side-effect\n        dispatch(messageCreated('Fetching post...'))\n        try {\n          const { data } = await queryFulfilled\n          // `onSuccess` side-effect\n          dispatch(messageCreated('Post received!'))\n        } catch (err) {\n          // `onError` side-effect\n          dispatch(messageCreated('Error fetching post!'))\n        }\n      },\n    }),\n  }),\n})\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"oncacheentryadded",children:(0,a.jsx)(n.code,{children:"onCacheEntryAdded"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["Available to both ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/queries",children:"queries"})," and ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/mutations",children:"mutations"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["A function that is called when a new cache entry is added, i.e. when a new subscription for the endpoint + query parameters combination is created. The function is called with a lifecycle api object containing properties such as ",(0,a.jsx)(n.code,{children:"cacheDataLoaded"})," & ",(0,a.jsx)(n.code,{children:"cacheDataRemoved"}),", allowing code to be run when a cache entry is added, when cache data is loaded, and when the cache entry is removed (i.e. throughout the lifecycle of a cache entry)."]}),"\n",(0,a.jsxs)(n.p,{children:["Can be used for ",(0,a.jsx)(n.a,{href:"/rtk-query/usage/streaming-updates",children:"streaming updates"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"cache-lifecycle-api-properties",children:"Cache Lifecycle API properties"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dispatch"})," - The dispatch method for the store."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getState"})," - A method to get the current state for the store."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extra"})," - ",(0,a.jsx)(n.code,{children:"extra"})," as provided as ",(0,a.jsx)(n.code,{children:"thunk.extraArgument"})," to the ",(0,a.jsx)(n.code,{children:"configureStore"})," ",(0,a.jsx)(n.code,{children:"getDefaultMiddleware"})," option."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"requestId"})," - A unique ID generated for the cache entry."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"cacheEntryRemoved"})," - A Promise that allows you to wait for the point in time when the cache entry has been removed from the cache, by not being used/subscribed to any more in the application for too long or by dispatching ",(0,a.jsx)(n.code,{children:"api.util.resetApiState"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"cacheDataLoaded"})," - A Promise that will resolve with the first value for this cache key. This allows you to ",(0,a.jsx)(n.code,{children:"await"})," until an actual value is in the cache.",(0,a.jsx)(n.br,{}),"\n","Note: If the cache entry is removed from the cache before any value has ever been resolved, this Promise will reject with ",(0,a.jsx)(n.code,{children:"new Error('Promise never resolved before cacheEntryRemoved.')"})," to prevent memory leaks. You can just re-throw that error (or not handle it at all) - it will be caught outside of ",(0,a.jsx)(n.code,{children:"cacheEntryAdded"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getCacheEntry"})," - A function that gets the current value of the cache entry."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateCachedData"})," ",(0,a.jsx)(n.em,{children:"(query endpoints only)"})," - A function that accepts a 'recipe' callback specifying how to update the data at the time it is called. This uses ",(0,a.jsx)(n.code,{children:"immer"})," internally, and updates can be written 'mutably' while safely producing the next immutable state."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Mutation onCacheEntryAdded signature" no-transpile',children:"async function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n  }: MutationCacheLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Query onCacheEntryAdded signature" no-transpile',children:"async function onCacheEntryAdded(\n  arg: QueryArg,\n  {\n    dispatch,\n    getState,\n    extra,\n    requestId,\n    cacheEntryRemoved,\n    cacheDataLoaded,\n    getCacheEntry,\n    updateCachedData, // available for query endpoints only\n  }: QueryCacheLifecycleApi,\n): Promise<void>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"schema-validation",children:"Schema Validation"}),"\n",(0,a.jsxs)(n.p,{children:["Endpoints can have schemas for runtime validation of query args, responses, and errors. Any ",(0,a.jsx)(n.a,{href:"https://standardschema.dev/",children:"Standard Schema"})," compliant library can be used."]}),"\n",(0,a.jsxs)(n.p,{children:["When used with TypeScript, schemas can also be used to ",(0,a.jsx)(n.a,{href:"/rtk-query/usage-with-typescript#schema-validation",children:"infer the type of that value instead of having to declare it"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsxs)(n.p,{children:["By default, schema failures are treated as ",(0,a.jsx)(n.em,{children:"fatal"}),", meaning that normal error handling such as tag invalidation will not be executed."]}),(0,a.jsxs)(n.p,{children:["In order for schema failures to be treated as non-fatal, you must provide a ",(0,a.jsx)(n.a,{href:"#catchschemafailure",children:(0,a.jsx)(n.code,{children:"catchSchemaFailure"})})," function, to convert the schema failure into an error shape matching the base query errors."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="catchSchemaFailure example" no-transpile',children:"const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  catchSchemaFailure: (error, info) => ({\n    status: 'CUSTOM_ERROR',\n    error: error.schemaName + ' failed validation',\n    data: error,\n  }),\n  endpoints: (build) => ({\n    // ...\n  }),\n})\n"})})]}),"\n",(0,a.jsx)(n.h4,{id:"argschema",children:(0,a.jsx)(n.code,{children:"argSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["A schema for the arguments to be passed to the ",(0,a.jsx)(n.code,{children:"query"})," or ",(0,a.jsx)(n.code,{children:"queryFn"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from \"valibot\"\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      argSchema: v.object({ id: v.number() }),\n    }),\n  })\n})\n"})}),"\n",(0,a.jsx)(n.h4,{id:"responseschema",children:(0,a.jsx)(n.code,{children:"responseSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["A schema for the result (including ",(0,a.jsx)(n.code,{children:"transformResponse"})," if provided)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from \"valibot\"\n\nconst postSchema = v.object({ id: v.number(), name: v.string() })\ntype Post = v.InferOutput<typeof postSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      responseSchema: postSchema,\n    }),\n  })\n})\n"})}),"\n",(0,a.jsx)(n.h4,{id:"rawresponseschema",children:(0,a.jsx)(n.code,{children:"rawResponseSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(optional, not applicable with ",(0,a.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,a.jsx)(n.h4,{id:"errorresponseschema",children:(0,a.jsx)(n.code,{children:"errorResponseSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["A schema for the error object returned by the ",(0,a.jsx)(n.code,{children:"query"})," or ",(0,a.jsx)(n.code,{children:"queryFn"})," (including ",(0,a.jsx)(n.code,{children:"transformErrorResponse"})," if provided)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'import { createApi } from \'@reduxjs/toolkit/query/react\'\nimport * as v from "valibot"\nimport { customBaseQuery, baseQueryErrorSchema } from "./customBaseQuery"\n\nconst api = createApi({\n  baseQuery: customBaseQuery,\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      errorResponseSchema: baseQueryErrorSchema,\n    }),\n  })\n})\n'})}),"\n",(0,a.jsx)(n.h4,{id:"rawerrorresponseschema",children:(0,a.jsx)(n.code,{children:"rawErrorResponseSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["(optional, not applicable with ",(0,a.jsx)(n.code,{children:"queryFn"}),")"]})}),"\n",(0,a.jsx)(n.h4,{id:"metaschema",children:(0,a.jsx)(n.code,{children:"metaSchema"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"(optional)"})}),"\n",(0,a.jsxs)(n.p,{children:["A schema for the ",(0,a.jsx)(n.code,{children:"meta"})," property returned by the ",(0,a.jsx)(n.code,{children:"query"})," or ",(0,a.jsx)(n.code,{children:"queryFn"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'import { createApi } from \'@reduxjs/toolkit/query/react\'\nimport * as v from "valibot"\nimport { customBaseQuery, baseQueryMetaSchema } from "./customBaseQuery"\n\nconst api = createApi({\n  baseQuery: customBaseQuery,\n  endpoints: (build) => ({\n    getPost: build.query<Post, { id: number }>({\n      query: ({ id }) => `/post/${id}`,\n      metaSchema: baseQueryMetaSchema,\n    }),\n  })\n})\n'})}),"\n",(0,a.jsx)(n.h2,{id:"return-value",children:"Return value"}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"./created-api/overview",children:'the "created Api" API reference'})]})]})}function p(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8049:function(e,n,r){r.d(n,{Z:()=>i});var t=r("4246");r("7378");var a=r("4870");function i(e){let{children:n,hidden:r,className:i}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,a.Z)("tabItem_wHwb",i),hidden:r,children:n})}},5181:function(e,n,r){r.d(n,{Z:()=>x});var t=r("4246"),a=r("7378"),i=r("4870"),s=r("5403"),o=r("3620"),l=r("7090"),c=r("6180"),d=r("3418"),u=r("9073");function h(e){var n,r;return null!==(r=null===(n=a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==r?r:[]}function p(e){let{value:n,tabValues:r}=e;return r.some(e=>e.value===n)}var y=r("3344");function g(e){let{className:n,block:r,selectedValue:a,selectValue:o,tabValues:l}=e,c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),u=e=>{let n=e.currentTarget,r=l[c.indexOf(n)].value;r!==a&&(d(n),o(r))},h=e=>{var n,r;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let r=c.indexOf(e.currentTarget)+1;t=null!==(n=c[r])&&void 0!==n?n:c[0];break}case"ArrowLeft":{let n=c.indexOf(e.currentTarget)-1;t=null!==(r=c[n])&&void 0!==r?r:c[c.length-1]}}null==t||t.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":r},n),children:l.map(e=>{let{value:n,label:r,attributes:s}=e;return(0,t.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>c.push(e),onKeyDown:h,onClick:u,...s,className:(0,i.Z)("tabs__item","tabItem_l0OV",null==s?void 0:s.className,{"tabs__item--active":a===n}),children:null!=r?r:n},n)})})}function m(e){let{lazy:n,children:r,selectedValue:s}=e,o=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){let e=o.find(e=>e.props.value===s);return e?(0,a.cloneElement)(e,{className:(0,i.Z)("margin-top--md",e.props.className)}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function f(e){let n=function(e){let{defaultValue:n,queryString:r=!1,groupId:t}=e,i=function(e){let{values:n,children:r}=e;return(0,a.useMemo)(()=>{let e=null!=n?n:h(r).map(e=>{let{props:{value:n,label:r,attributes:t,default:a}}=e;return{value:n,label:r,attributes:t,default:a}});return!function(e){let n=(0,d.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,r])}(e),[s,y]=(0,a.useState)(()=>(function(e){var n;let{defaultValue:r,tabValues:t}=e;if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!p({value:r,tabValues:t}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(r,'" but none of its children has the corresponding value. Available values are: ').concat(t.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return r}let a=null!==(n=t.find(e=>e.default))&&void 0!==n?n:t[0];if(!a)throw Error("Unexpected error: 0 tabValues");return a.value})({defaultValue:n,tabValues:i})),[g,m]=function(e){let{queryString:n=!1,groupId:r}=e,t=(0,o.k6)(),i=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:n,groupId:r});return[(0,c._X)(i),(0,a.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})},[i,t])]}({queryString:r,groupId:t}),[f,x]=function(e){let{groupId:n}=e,r=n?"docusaurus.tab.".concat(n):null,[t,i]=(0,u.Nk)(r);return[t,(0,a.useCallback)(e=>{r&&i.set(e)},[r,i])]}({groupId:t}),j=(()=>{let e=null!=g?g:f;return p({value:e,tabValues:i})?e:null})();return(0,l.Z)(()=>{j&&y(j)},[j]),{selectedValue:s,selectValue:(0,a.useCallback)(e=>{if(!p({value:e,tabValues:i}))throw Error("Can't select invalid tab value=".concat(e));y(e),m(e),x(e)},[m,x,i]),tabValues:i}}(e);return(0,t.jsxs)("div",{className:(0,i.Z)("tabs-container","tabList_J5MA"),children:[(0,t.jsx)(g,{...n,...e}),(0,t.jsx)(m,{...n,...e})]})}function x(e){let n=(0,y.Z)();return(0,t.jsx)(f,{...e,children:h(e.children)},String(n))}},980:function(e,n,r){r.d(n,{Z:function(){return o},a:function(){return s}});var t=r(7378);let a={},i=t.createContext(a);function s(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);