"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2062"],{4276:function(e,n,a){a.r(n),a.d(n,{default:()=>p,frontMatter:()=>l,metadata:()=>i,assets:()=>d,toc:()=>u,contentTitle:()=>c});var i=JSON.parse('{"id":"rtk-query/usage/infinite-queries","title":"Infinite Queries","description":"RTK Query > Usage > Infinite Queries: fetching many data pages from a server","source":"@site/../docs/rtk-query/usage/infinite-queries.mdx","sourceDirName":"rtk-query/usage","slug":"/rtk-query/usage/infinite-queries","permalink":"/rtk-query/usage/infinite-queries","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1753994190000,"frontMatter":{"id":"infinite-queries","title":"Infinite Queries","sidebar_label":"Infinite Queries","hide_title":true,"description":"RTK Query > Usage > Infinite Queries: fetching many data pages from a server"},"sidebar":"docs","previous":{"title":"Queries","permalink":"/rtk-query/usage/queries"},"next":{"title":"Mutations","permalink":"/rtk-query/usage/mutations"}}'),t=a("4246"),r=a("980"),s=a("8049"),o=a("5181");let l={id:"infinite-queries",title:"Infinite Queries",sidebar_label:"Infinite Queries",hide_title:!0,description:"RTK Query > Usage > Infinite Queries: fetching many data pages from a server"},c="Infinite Queries",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Infinite Query Concepts",id:"infinite-query-concepts",level:2},{value:"Query Args, Page Params, and Cache Structure",id:"query-args-page-params-and-cache-structure",level:3},{value:"Defining Infinite Query Endpoints",id:"defining-infinite-query-endpoints",level:2},{value:"<code>infiniteQueryOptions</code>",id:"infinitequeryoptions",level:3},{value:"Page Param Functions",id:"page-param-functions",level:3},{value:"Infinite Query Definition Example",id:"infinite-query-definition-example",level:3},{value:"Performing Infinite Queries with React Hooks",id:"performing-infinite-queries-with-react-hooks",level:2},{value:"Hook Types",id:"hook-types",level:3},{value:"Query Hook Options",id:"query-hook-options",level:3},{value:"Frequently Used Query Hook Return Values",id:"frequently-used-query-hook-return-values",level:3},{value:"Displaying Infinite Query Data",id:"displaying-infinite-query-data",level:3},{value:"Infinite Query Hook Usage Example",id:"infinite-query-hook-usage-example",level:3},{value:"Infinite Query Behaviors",id:"infinite-query-behaviors",level:2},{value:"Overlapping Page Fetches",id:"overlapping-page-fetches",level:3},{value:"Refetching",id:"refetching",level:3},{value:"Limiting Cache Entry Size",id:"limiting-cache-entry-size",level:3},{value:"Common Infinite Query Patterns",id:"common-infinite-query-patterns",level:2},{value:"Basic Pagination",id:"basic-pagination",level:3},{value:"Pagination with Sizes",id:"pagination-with-sizes",level:3},{value:"Bidirectional Cursors",id:"bidirectional-cursors",level:3},{value:"Limit and Offset",id:"limit-and-offset",level:3},{value:"Runtime Validation using Schemas",id:"runtime-validation-using-schemas",level:2}];function h(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"\xa0"}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"infinite-queries",children:"Infinite Queries"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:'Rendering lists that can additively "load more" data onto an existing set of data or "infinite scroll" is a common UI pattern.'}),"\n",(0,t.jsx)(n.p,{children:'RTK Query supports this use case via "infinite query" endpoints. Infinite Query endpoints are similar to standard query endpoints, in that they fetch data and cache the results. However, infinite query endpoints have the ability to fetch "next" and "previous" pages, and contain all related fetched pages in a single cache entry.'}),"\n",(0,t.jsx)(n.h2,{id:"infinite-query-concepts",children:"Infinite Query Concepts"}),"\n",(0,t.jsxs)(n.p,{children:["RTK Query's support for infinite queries is modeled after ",(0,t.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries",children:"React Query's infinite query API design"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"query-args-page-params-and-cache-structure",children:"Query Args, Page Params, and Cache Structure"}),"\n",(0,t.jsx)(n.p,{children:"With standard query endpoints:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['You specify the "query arg" value, which is passed to the ',(0,t.jsx)(n.code,{children:"query"})," or ",(0,t.jsx)(n.code,{children:"queryFn"})," function that will calculate the desired URL or do the actual fetching"]}),"\n",(0,t.jsx)(n.li,{children:"The query arg is also serialized to generate the unique internal key for this specific cache entry"}),"\n",(0,t.jsxs)(n.li,{children:["The single response value is directly stored as the ",(0,t.jsx)(n.code,{children:"data"})," field in the cache entry"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Infinite queries work similarly, but have a couple additional layers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'You still specify a "query arg", which is still used to generate the unique cache key for this specific cache entry'}),"\n",(0,t.jsxs)(n.li,{children:['However, there is a separation between the "query arg" used for the cache key, and the "page param" used to fetch a specific page. Since both are useful for determining what to fetch, ',(0,t.jsxs)(n.strong,{children:["your ",(0,t.jsx)(n.code,{children:"query"})," and ",(0,t.jsx)(n.code,{children:"queryFn"})," methods will receive a combined object with ",(0,t.jsx)(n.code,{children:"{queryArg, pageParam}"})," as the first argument, instead of just the ",(0,t.jsx)(n.code,{children:"queryArg"})," by itself"]}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"data"})," field in the cache entry stores a ",(0,t.jsx)(n.code,{children:"{pages: DataType[], pageParams: PageParam[]}"})," structure that contains ",(0,t.jsx)(n.em,{children:"all"})," of the fetched page results and their corresponding page params used to fetch them."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For example, a Pokemon API endpoint might have a string query arg like ",(0,t.jsx)(n.code,{children:'"fire"'}),", but use a page number as the param to determine which page to fetch out of the results. For a query like ",(0,t.jsx)(n.code,{children:"useGetPokemonInfiniteQuery('fire')"}),", the resulting cache data might look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'{\n  queries: {\n    "getPokemon(\'fire\')": {\n      data: {\n        pages: [\n          ["Charmander", "Charmeleon"],\n          ["Charizard", "Vulpix"],\n          ["Magmar", "Flareon"]\n        ],\n        pageParams: [\n          1,\n          2,\n          3\n        ]\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This structure allows flexibility in how your UI chooses to render the data (showing individual pages, flattening into a single list), enables limiting how many pages are kept in cache, and makes it possible to dynamically determine the next or previous page to fetch based on either the data or the page params."}),"\n",(0,t.jsx)(n.h2,{id:"defining-infinite-query-endpoints",children:"Defining Infinite Query Endpoints"}),"\n",(0,t.jsxs)(n.p,{children:["Infinite query endpoints are defined by returning an object inside the ",(0,t.jsx)(n.code,{children:"endpoints"})," section of ",(0,t.jsx)(n.code,{children:"createApi"}),", and defining the fields using the ",(0,t.jsx)(n.code,{children:"build.infiniteQuery()"})," method. They are an extension of standard query endpoints - you can specify ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/queries#defining-query-endpoints",children:"the same options as standard queries"})," (providing either ",(0,t.jsx)(n.code,{children:"query"})," or ",(0,t.jsx)(n.code,{children:"queryFn"}),", customizing with ",(0,t.jsx)(n.code,{children:"transformResponse"}),", lifecycles with ",(0,t.jsx)(n.code,{children:"onCacheEntryAdded"})," and ",(0,t.jsx)(n.code,{children:"onQueryStarted"}),", defining tags, etc). However, they also require an additional ",(0,t.jsx)(n.code,{children:"infiniteQueryOptions"})," field to specify the infinite query behavior."]}),"\n",(0,t.jsxs)(n.p,{children:["With TypeScript, you must supply 3 generic arguments: ",(0,t.jsx)(n.code,{children:"build.infiniteQuery<ResultType, QueryArg, PageParam>"}),", where ",(0,t.jsx)(n.code,{children:"ResultType"})," is the contents of a single page, ",(0,t.jsx)(n.code,{children:"QueryArg"})," is the type passed in as the cache key, and ",(0,t.jsx)(n.code,{children:"PageParam"})," is the value used to request a specific page. If there is no argument, use ",(0,t.jsx)(n.code,{children:"void"})," for the arg type instead."]}),"\n",(0,t.jsx)(n.h3,{id:"infinitequeryoptions",children:(0,t.jsx)(n.code,{children:"infiniteQueryOptions"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"infiniteQueryOptions"})," field includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"initialPageParam"}),": the default page param value used for the first request, if this was not specified at the usage site"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"maxPages"}),": an optional limit to how many fetched pages will be kept in the cache entry at a time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getNextPageParam"}),": a required callback you must provide to calculate the next page param, given the existing cached pages and page params"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getPreviousPageParam"}),": an optional callback that will be used to calculate the previous page param, if you try to fetch backwards."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"initialPageParam"})," and ",(0,t.jsx)(n.code,{children:"getNextPageParam"})," are required, to\nensure the infinite query can properly fetch the next page of data. Also, ",(0,t.jsx)(n.code,{children:"initialPageParam"})," may be specified when using the endpoint, to override the default value for a first fetch. ",(0,t.jsx)(n.code,{children:"maxPages"})," and ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"})," are both optional."]}),"\n",(0,t.jsx)(n.h3,{id:"page-param-functions",children:"Page Param Functions"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"getNextPageParam"})," and ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"})," are user-defined, giving you flexibility to determine how those values are calculated:"]}),"\n",(0,t.jsxs)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,t.jsx)(s.Z,{value:"ts",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export type PageParamFunction<DataType, PageParam, QueryArg> = (\n  currentPage: DataType,\n  allPages: DataType[],\n  currentPageParam: PageParam,\n  allPageParams: PageParam[],\n  queryArg: QueryArg,\n) => PageParam | undefined | null\n"})})}),(0,t.jsx)(s.Z,{value:"js",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export {}\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["A page param can be any value at all: numbers, strings, objects, arrays, etc. Since the existing page param values are stored in Redux state, you should still treat those immutably. For example, if you had a param structure like ",(0,t.jsx)(n.code,{children:"{page: Number, filters: Filters}"}),", incrementing the page would look like ",(0,t.jsx)(n.code,{children:"return {...currentPageParam, page: currentPageParam.page + 1}"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Since both actual page contents and page params are passed in, you can calculate new page params based on any of those. This enables a number of possible infinite query use cases, including cursor-based and limit+offset-based queries."}),"\n",(0,t.jsxs)(n.p,{children:['The "current" arguments will be either the last page for ',(0,t.jsx)(n.code,{children:"getNextPageParam"}),", or the first page for ",(0,t.jsx)(n.code,{children:"getPreviousPageParam"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The list of arguments is the same as with React Query, but with the addition of ",(0,t.jsx)(n.code,{children:"queryArg"})," at the end. (This is because React Query always has access to the query arg when you pass the options to its ",(0,t.jsx)(n.code,{children:"useQuery"})," hook, but with RTK Query the endpoints are defined separately, so this makes the query arg accessible if you need it to calculate the page params.)"]}),"\n",(0,t.jsxs)(n.p,{children:["If there is no possible page to fetch in that direction, the callback should return ",(0,t.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"infinite-query-definition-example",children:"Infinite Query Definition Example"}),"\n",(0,t.jsx)(n.p,{children:"A complete example of this for a fictional Pokemon API service might look like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'no-transpile title="Infinite Query definition example"',children:"type Pokemon = {\n  id: string\n  name: string\n}\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    // 3 TS generics: page contents, query arg, page param\n    getInfinitePokemonWithMax: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        // Must provide a default initial page param value\n        initialPageParam: 1,\n        // Optionally limit the number of cached pages\n        maxPages: 3,\n        // Must provide a `getNextPageParam` function\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n          queryArg,\n        ) => lastPageParam + 1,\n        // Optionally provide a `getPreviousPageParam` function\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n          queryArg,\n        ) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      // The `query` function receives `{queryArg, pageParam}` as its argument\n      query({ queryArg, pageParam }) {\n        return `/type/${queryArg}?page=${pageParam}`\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performing-infinite-queries-with-react-hooks",children:"Performing Infinite Queries with React Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/rtk-query/usage/queries#performing-queries-with-react-hooks",children:"Similar to query endpoints"}),", RTK Query will automatically generate React hooks for infinite query endpoints based on the name of the endpoint. An endpoint field with ",(0,t.jsx)(n.code,{children:"getPokemon: build.infiniteQuery()"})," will generate a hook named ",(0,t.jsx)(n.code,{children:"useGetPokemonInfiniteQuery"}),", as well as a generically-named hook attached to the endpoint, like ",(0,t.jsx)(n.code,{children:"api.endpoints.getPokemon.useInfiniteQuery"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"hook-types",children:"Hook Types"}),"\n",(0,t.jsx)(n.p,{children:"There are 3 infinite query-related hooks:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/rtk-query/api/created-api/hooks#useinfinitequery",children:(0,t.jsx)(n.code,{children:"useInfiniteQuery"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Composes ",(0,t.jsx)(n.code,{children:"useInfiniteQuerySubscription"})," and ",(0,t.jsx)(n.code,{children:"useInfiniteQueryState"}),", and is the primary hook. Automatically triggers fetches of data from an endpoint, 'subscribes' the component to the cached data, and reads the request status and cached data from the Redux store."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/rtk-query/api/created-api/hooks#useinfinitequerysubscription",children:(0,t.jsx)(n.code,{children:"useInfiniteQuerySubscription"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns a ",(0,t.jsx)(n.code,{children:"refetch"})," function and ",(0,t.jsx)(n.code,{children:"fetchNext/PreviousPage"})," functions, and accepts all hooks options. Automatically triggers refetches of data from an endpoint, and 'subscribes' the component to the cached data."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/rtk-query/api/created-api/hooks#useinfinitequerystate",children:(0,t.jsx)(n.code,{children:"useInfiniteQueryState"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns the query state and accepts ",(0,t.jsx)(n.code,{children:"skip"})," and ",(0,t.jsx)(n.code,{children:"selectFromResult"}),". Reads the request status and cached data from the Redux store."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In practice, the standard ",(0,t.jsx)(n.code,{children:"useInfiniteQuery"}),"-based hooks such as ",(0,t.jsx)(n.code,{children:"useGetPokemonInfiniteQuery"})," will be the primary hooks used in your application, but the other hooks are available for specific use cases."]}),"\n",(0,t.jsx)(n.h3,{id:"query-hook-options",children:"Query Hook Options"}),"\n",(0,t.jsxs)(n.p,{children:["The query hooks expect two parameters: ",(0,t.jsx)(n.code,{children:"(queryArg?, queryOptions?)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"queryOptions"})," object accepts ",(0,t.jsxs)(n.a,{href:"/rtk-query/usage/queries#query-hook-options",children:["all the same parameters as ",(0,t.jsx)(n.code,{children:"useQuery"})]}),", including ",(0,t.jsx)(n.code,{children:"skip"}),", ",(0,t.jsx)(n.code,{children:"selectFromResult"}),", and refetching/polling options."]}),"\n",(0,t.jsxs)(n.p,{children:["Unlike normal query hooks, your ",(0,t.jsx)(n.code,{children:"query"})," or ",(0,t.jsx)(n.code,{children:"queryFn"}),' callbacks will receive a "page param" value to generate the URL or make the request, instead of the "query arg" that was passed to the hook. By default, the ',(0,t.jsx)(n.code,{children:"initialPageParam"})," value specified in the endpoint will be used to make the first request, and then your ",(0,t.jsx)(n.code,{children:"getNext/PreviousPageParam"})," callbacks will be used to calculate further page params as you fetch forwards or backwards."]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to start from a different page param, you may override the ",(0,t.jsx)(n.code,{children:"initialPageParam"})," by passing it as part of the hook options:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const { data } = useGetPokemonInfiniteQuery('fire', {\n  initialPageParam: 3,\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"The next and previous page params will still be calculated as needed."}),"\n",(0,t.jsx)(n.h3,{id:"frequently-used-query-hook-return-values",children:"Frequently Used Query Hook Return Values"}),"\n",(0,t.jsxs)(n.p,{children:["Infinite query hooks return ",(0,t.jsx)(n.a,{href:"/rtk-query/usage/queries#frequently-used-query-hook-return-values",children:"the same result object as normal query hooks"}),", but with ",(0,t.jsx)(n.a,{href:"/rtk-query/api/created-api/hooks#useinfinitequery-signature",children:"a few additional fields specific to infinite queries"})," and a different structure for ",(0,t.jsx)(n.code,{children:"data"})," and ",(0,t.jsx)(n.code,{children:"currentData"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," / ",(0,t.jsx)(n.code,{children:"currentData"}),': These contain the same "latest successful" and "latest for current arg" results as normal queries, but the value is the ',(0,t.jsx)(n.code,{children:"{pages, pageParams}"})," infinite query object with all fetched pages instead of a single response value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hasNextPage"})," / ",(0,t.jsx)(n.code,{children:"hasPreviousPage"}),": When true, indicates that there ",(0,t.jsx)(n.em,{children:"should"})," be another page available to fetch in that direction. This is calculated by calling ",(0,t.jsx)(n.code,{children:"getNext/PreviousPageParam"})," with the latest fetched pages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isFetchingNext/PreviousPage"}),": When true, indicates that the current ",(0,t.jsx)(n.code,{children:"isFetching"})," flag represents a fetch in that direction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"isFetchNext/PreviousPageError"}),": When true, indicates that the current ",(0,t.jsx)(n.code,{children:"isError"})," flag represents an error for a failed fetch in that direction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fetchNext/PreviousPage"}),": methods that will trigger a fetch for another page in that direction."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In most cases, you will probably read ",(0,t.jsx)(n.code,{children:"data"})," and either ",(0,t.jsx)(n.code,{children:"isLoading"})," or ",(0,t.jsx)(n.code,{children:"isFetching"})," in order to render your UI. You will also want to use the ",(0,t.jsx)(n.code,{children:"fetchNext/PreviousPage"})," methods to trigger fetching additional pages."]}),"\n",(0,t.jsx)(n.h3,{id:"displaying-infinite-query-data",children:"Displaying Infinite Query Data"}),"\n",(0,t.jsxs)(n.p,{children:["For infinite query hooks, the ",(0,t.jsx)(n.code,{children:"data"})," field returned by the hook will be the ",(0,t.jsx)(n.code,{children:"{pages, pageParams}"})," structure containing all fetched pages, instead of just a single response value."]}),"\n",(0,t.jsx)(n.p,{children:"This gives you control over how the data is used for display. You can flatten all the page contents into a single array for infinite scrolling, use the individual page results for pagination, sort or reverse the entries, or any other logic you need for rendering the UI with this data."}),"\n",(0,t.jsxs)(n.p,{children:["As with any other Redux data, you should avoid mutating these arrays (including calling ",(0,t.jsx)(n.code,{children:"array.sort/reverse()"})," directly on the existing references)."]}),"\n",(0,t.jsx)(n.h3,{id:"infinite-query-hook-usage-example",children:"Infinite Query Hook Usage Example"}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of a typical infinite query endpoint definition, and hook usage in a component:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:"no-transpile",children:"type Pokemon = {\n  id: string\n  name: string\n}\n\nconst pokemonApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    getPokemon: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        initialPageParam: 1,\n        getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n          lastPageParam + 1,\n      },\n      query({ queryArg, pageParam }) {\n        return `/type/${queryArg}?page=${pageParam}`\n      },\n    }),\n  }),\n})\n\nfunction PokemonList({ pokemonType }: { pokemonType: string }) {\n  const { data, isFetching, fetchNextPage, fetchPreviousPage, refetch } =\n    pokemonApi.useGetPokemonInfiniteQuery(pokemonType)\n\n  const handleNextPage = async () => {\n    await fetchNextPage()\n  }\n\n  const handleRefetch = async () => {\n    await refetch()\n  }\n\n  const allResults = data?.pages.flat() ?? []\n\n  return (\n    <div>\n      <div>Type: {pokemonType}</div>\n      <div>\n        {allResults.map((pokemon, i: number | null | undefined) => (\n          <div key={i}>{pokemon.name}</div>\n        ))}\n      </div>\n      <button onClick={() => handleNextPage()}>Fetch More</button>\n      <button onClick={() => handleRefetch()}>Refetch</button>\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the server returns an array of Pokemon as the response for each individual page. This component shows the results as a single list. Since the ",(0,t.jsx)(n.code,{children:"data"})," field itself has a ",(0,t.jsx)(n.code,{children:"pages"})," array of all responses, the component needs to flatten the pages into a single array to render that list. Alternately, it could map over the pages and show them in a paginated format."]}),"\n",(0,t.jsxs)(n.p,{children:['Similarly, this example relies on manual user clicks on a "Fetch More" button to trigger fetching the next page, but could automatically call ',(0,t.jsx)(n.code,{children:"fetchNextPage"})," based on things like an ",(0,t.jsx)(n.code,{children:"IntersectionObserver"}),', a list component triggering some kind of "end of the list" event, or other similar indicators.']}),"\n",(0,t.jsxs)(n.p,{children:["The endpoint itself only defines ",(0,t.jsx)(n.code,{children:"getNextPageParam"}),", so this example doesn't support fetching backwards, but that can be provided in cases where backwards fetching makes sense. The page param here is a simple incremented number, but the page param"]}),"\n",(0,t.jsx)(n.h2,{id:"infinite-query-behaviors",children:"Infinite Query Behaviors"}),"\n",(0,t.jsx)(n.h3,{id:"overlapping-page-fetches",children:"Overlapping Page Fetches"}),"\n",(0,t.jsx)(n.p,{children:"Since all pages are stored in a single cache entry, there can only be one request in progress at a time. RTK Query already has logic built in to bail out of running a new request if there is already a request in flight for that cache entry."}),"\n",(0,t.jsxs)(n.p,{children:["That means that if you call ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," again while an existing request is in progress, the second call won't actually execute a request. Be sure to either await the previous ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," promise result first or check the ",(0,t.jsx)(n.code,{children:"isFetching"})," flag if you have concerns about a potential request already in progress."]}),"\n",(0,t.jsxs)(n.p,{children:["The promise returned from ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," does have ",(0,t.jsxs)(n.a,{href:"/api/createAsyncThunk#canceling-while-running",children:["a ",(0,t.jsx)(n.code,{children:"promise.abort()"})," method attached"]})," that will force the earlier request to reject and not save the results. Note that this will mark the cache entry as errored, but the data will still exist. Since ",(0,t.jsx)(n.code,{children:"promise.abort()"})," is synchronous, you would also need to await the previous promise to ensure the rejection is handled, and then trigger the new page fetch."]}),"\n",(0,t.jsx)(n.h3,{id:"refetching",children:"Refetching"}),"\n",(0,t.jsx)(n.p,{children:"When an infinite query endpoint is refetched (due to tag invalidation, polling, arg change configuration, or manual refetching), RTK Query will try to sequentially refetch all pages currently in the cache. This ensures that the client is always working with the latest data, and avoids stale cursors or duplicate records."}),"\n",(0,t.jsx)(n.p,{children:"If the cache entry is ever removed and then re-added, it will start with only fetching the initial page."}),"\n",(0,t.jsx)(n.h3,{id:"limiting-cache-entry-size",children:"Limiting Cache Entry Size"}),"\n",(0,t.jsxs)(n.p,{children:["All fetched pages for a given query arg are stored in the ",(0,t.jsx)(n.code,{children:"pages"})," array in that cache entry. By default, there is no limit to the number of stored pages - if you call ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," 1000 times, ",(0,t.jsx)(n.code,{children:"data.pages"})," will have 1000 pages stored."]}),"\n",(0,t.jsxs)(n.p,{children:["If you need to limit the number of stored pages (for reasons like memory usage), you can supply a ",(0,t.jsx)(n.code,{children:"maxPages"})," option as part of the endpoint. If provided, fetching a page when already at the max will automatically drop the last page in the opposite direction. For example, with ",(0,t.jsx)(n.code,{children:"maxPages: 3"})," and a cached page params of ",(0,t.jsx)(n.code,{children:"[1, 2, 3]"}),", calling ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," would result in page ",(0,t.jsx)(n.code,{children:"1"})," being dropped and the new cached pages being ",(0,t.jsx)(n.code,{children:"[2, 3, 4]"}),". From there, calling ",(0,t.jsx)(n.code,{children:"fetchNextPage()"})," would result in ",(0,t.jsx)(n.code,{children:"[3, 4, 5]"}),", or calling ",(0,t.jsx)(n.code,{children:"fetchPreviousPage()"})," would go back to ",(0,t.jsx)(n.code,{children:"[1, 2, 3]"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"common-infinite-query-patterns",children:"Common Infinite Query Patterns"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"getNext/PreviousPageParam"})," callbacks offer flexibility in how you interact with the backend API."]}),"\n",(0,t.jsx)(n.p,{children:"Here are some examples of common infinite query patterns to show how you might approach different use cases."}),"\n",(0,t.jsxs)(n.p,{children:["For additional examples, and to see some of these patterns in action, see ",(0,t.jsx)(n.a,{href:"https://github.com/reduxjs/redux-toolkit/tree/master/examples/query/react/infinite-queries",children:'the RTK Query "infinite queries" example app in the repo'}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-pagination",children:"Basic Pagination"}),"\n",(0,t.jsx)(n.p,{children:"For a simple API that just needs page numbers, you can calculate the previous and next page numbers based on the existing page params:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"const pokemonApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    getInfinitePokemon: build.infiniteQuery<Pokemon[], string, number>({\n      infiniteQueryOptions: {\n        initialPageParam: 0,\n        getNextPageParam: (lastPage, allPages, lastPageParam) =>\n          lastPageParam + 1,\n        getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n          return firstPageParam > 0 ? firstPageParam - 1 : undefined\n        },\n      },\n      query({ pageParam }) {\n        return `https://example.com/listItems?page=${pageParam}`\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pagination-with-sizes",children:"Pagination with Sizes"}),"\n",(0,t.jsx)(n.p,{children:"For an API that accepts values like page number and page size and includes total pages in the response, you can calculate whether there are more pages remaining:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type ProjectsResponse = {\n  projects: Project[]\n  serverTime: string\n  totalPages: number\n}\n\ntype ProjectsInitialPageParam = {\n  page: number\n  size: number\n}\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    projectsPaginated: build.infiniteQuery<\n      ProjectsResponse,\n      void,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: {\n          page: 0,\n          size: 20,\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          const nextPage = lastPageParam.page + 1\n          const remainingPages = lastPage?.totalPages - nextPage\n\n          if (remainingPages <= 0) {\n            return undefined\n          }\n\n          return {\n            ...lastPageParam,\n            page: nextPage,\n          }\n        },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          const prevPage = firstPageParam.page - 1\n          if (prevPage < 0) return undefined\n\n          return {\n            ...firstPageParam,\n            page: prevPage,\n          }\n        },\n      },\n      query: ({ pageParam: { page, size } }) => {\n        return `https://example.com/api/projectsPaginated?page=${page}&size=${size}`\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"bidirectional-cursors",children:"Bidirectional Cursors"}),"\n",(0,t.jsx)(n.p,{children:"If the server sends back cursor values in the response, you can use those as the page params for the next and previous requests:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type ProjectsCursorPaginated = {\n  projects: Project[]\n  serverTime: string\n  pageInfo: {\n    startCursor: number\n    endCursor: number\n    hasNextPage: boolean\n    hasPreviousPage: boolean\n  }\n}\n\ntype ProjectsInitialPageParam = {\n  before?: number\n  around?: number\n  after?: number\n  limit: number\n}\ntype QueryParamLimit = number\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    getProjectsBidirectionalCursor: build.infiniteQuery<\n      ProjectsCursorPaginated,\n      QueryParamLimit,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: { limit: 10 },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          if (!firstPage.pageInfo.hasPreviousPage) {\n            return undefined\n          }\n          return {\n            before: firstPage.pageInfo.startCursor,\n            limit: firstPageParam.limit,\n          }\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          if (!lastPage.pageInfo.hasNextPage) {\n            return undefined\n          }\n          return {\n            after: lastPage.pageInfo.endCursor,\n            limit: lastPageParam.limit,\n          }\n        },\n      },\n      query: ({ pageParam: { before, after, around, limit } }) => {\n        const params = new URLSearchParams()\n        params.append('limit', String(limit))\n        if (after != null) {\n          params.append('after', String(after))\n        } else if (before != null) {\n          params.append('before', String(before))\n        } else if (around != null) {\n          params.append('around', String(around))\n        }\n\n        return `https://example.com/api/projectsBidirectionalCursor?${params.toString()}`,\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"limit-and-offset",children:"Limit and Offset"}),"\n",(0,t.jsx)(n.p,{children:"If the API expects a combination of limit and offset values, those can also be calculated based on the responses and page params."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"export type ProjectsResponse = {\n  projects: Project[]\n  numFound: number\n  serverTime: string\n}\n\ntype ProjectsInitialPageParam = {\n  offset: number\n  limit: number\n}\n\nconst projectsApi = createApi({\n  baseQuery,\n  endpoints: (build) => ({\n    projectsLimitOffset: build.infiniteQuery<\n      ProjectsResponse,\n      void,\n      ProjectsInitialPageParam\n    >({\n      infiniteQueryOptions: {\n        initialPageParam: {\n          offset: 0,\n          limit: 20,\n        },\n        getNextPageParam: (\n          lastPage,\n          allPages,\n          lastPageParam,\n          allPageParams,\n        ) => {\n          const nextOffset = lastPageParam.offset + lastPageParam.limit\n          const remainingItems = lastPage?.numFound - nextOffset\n\n          if (remainingItems <= 0) {\n            return undefined\n          }\n\n          return {\n            ...lastPageParam,\n            offset: nextOffset,\n          }\n        },\n        getPreviousPageParam: (\n          firstPage,\n          allPages,\n          firstPageParam,\n          allPageParams,\n        ) => {\n          const prevOffset = firstPageParam.offset - firstPageParam.limit\n          if (prevOffset < 0) return undefined\n\n          return {\n            ...firstPageParam,\n            offset: firstPageParam.offset - firstPageParam.limit,\n          }\n        },\n      },\n      query: ({ pageParam: { offset, limit } }) => {\n        return `https://example.com/api/projectsLimitOffset?offset=${offset}&limit=${limit}`\n      },\n    }),\n  }),\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"runtime-validation-using-schemas",children:"Runtime Validation using Schemas"}),"\n",(0,t.jsxs)(n.p,{children:["Endpoints can use any ",(0,t.jsx)(n.a,{href:"https://standardschema.dev/",children:"Standard Schema"})," compliant library for runtime validation of query args, responses, and errors. See ",(0,t.jsx)(n.a,{href:"/rtk-query/api/createApi#schema-validation",children:"API reference"})," for full list of available schemas."]}),"\n",(0,t.jsxs)(n.p,{children:["When used with TypeScript, schemas can also be used to ",(0,t.jsx)(n.a,{href:"/rtk-query/usage-with-typescript#schema-validation",children:"infer the type of that value instead of having to declare it"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Most commonly, you'll want to use ",(0,t.jsx)(n.code,{children:"responseSchema"})," to validate the response from the server (or ",(0,t.jsx)(n.code,{children:"rawResponseSchema"})," when using ",(0,t.jsx)(n.code,{children:"transformResponse"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="Using responseSchema" no-transpile',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport * as v from 'valibot'\n\nconst pokemonSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n})\ntype Pokemon = v.InferOutput<typeof pokemonSchema>\nconst transformedPokemonSchema = v.object({\n  ...pokemonSchema.entries,\n  id: v.string(),\n})\ntype TransformedPokemon = v.InferOutput<typeof transformedPokemonSchema>\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/pokemon' }),\n  endpoints: (build) => ({\n    getInfinitePokemon: build.infiniteQuery<Pokemon[], string, number>({\n      query: ({ queryArg, pageParam }) => `type/${queryArg}?page=${pageParam}`,\n      // argSchema for infinite queries must have both queryArg and pageParam\n      argSchema: v.object({\n        queryArg: v.string(),\n        pageParam: v.number(),\n      }),\n      responseSchema: v.array(pokemonSchema),\n    }),\n    getTransformedPokemon: build.infiniteQuery<\n      TransformedPokemon[],\n      string,\n      number\n    >({\n      query: ({ queryArg, pageParam }) => `type/${queryArg}?page=${pageParam}`,\n      argSchema: v.object({\n        queryArg: v.string(),\n        pageParam: v.number(),\n      }),\n      rawResponseSchema: v.array(pokemonSchema),\n      transformResponse: (response) =>\n        response.map((pokemon) => ({\n          ...pokemon,\n          id: String(pokemon.id),\n        })),\n      // responseSchema can still be provided, to validate the transformed response\n      responseSchema: v.array(transformedPokemonSchema),\n    }),\n  }),\n})\n"})})]})}function p(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8049:function(e,n,a){a.d(n,{Z:()=>r});var i=a("4246");a("7378");var t=a("4870");function r(e){let{children:n,hidden:a,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,t.Z)("tabItem_wHwb",r),hidden:a,children:n})}},5181:function(e,n,a){a.d(n,{Z:()=>x});var i=a("4246"),t=a("7378"),r=a("4870"),s=a("5403"),o=a("3620"),l=a("7090"),c=a("6180"),d=a("3418"),u=a("9073");function h(e){var n,a;return null!==(a=null===(n=t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==a?a:[]}function p(e){let{value:n,tabValues:a}=e;return a.some(e=>e.value===n)}var g=a("3344");function m(e){let{className:n,block:a,selectedValue:t,selectValue:o,tabValues:l}=e,c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),u=e=>{let n=e.currentTarget,a=l[c.indexOf(n)].value;a!==t&&(d(n),o(a))},h=e=>{var n,a;let i=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let a=c.indexOf(e.currentTarget)+1;i=null!==(n=c[a])&&void 0!==n?n:c[0];break}case"ArrowLeft":{let n=c.indexOf(e.currentTarget)-1;i=null!==(a=c[n])&&void 0!==a?a:c[c.length-1]}}null==i||i.focus()};return(0,i.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},n),children:l.map(e=>{let{value:n,label:a,attributes:s}=e;return(0,i.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>c.push(e),onKeyDown:h,onClick:u,...s,className:(0,r.Z)("tabs__item","tabItem_l0OV",null==s?void 0:s.className,{"tabs__item--active":t===n}),children:null!=a?a:n},n)})})}function f(e){let{lazy:n,children:a,selectedValue:s}=e,o=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){let e=o.find(e=>e.props.value===s);return e?(0,t.cloneElement)(e,{className:(0,r.Z)("margin-top--md",e.props.className)}):null}return(0,i.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function y(e){let n=function(e){let{defaultValue:n,queryString:a=!1,groupId:i}=e,r=function(e){let{values:n,children:a}=e;return(0,t.useMemo)(()=>{let e=null!=n?n:h(a).map(e=>{let{props:{value:n,label:a,attributes:i,default:t}}=e;return{value:n,label:a,attributes:i,default:t}});return!function(e){let n=(0,d.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,a])}(e),[s,g]=(0,t.useState)(()=>(function(e){var n;let{defaultValue:a,tabValues:i}=e;if(0===i.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!p({value:a,tabValues:i}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(a,'" but none of its children has the corresponding value. Available values are: ').concat(i.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return a}let t=null!==(n=i.find(e=>e.default))&&void 0!==n?n:i[0];if(!t)throw Error("Unexpected error: 0 tabValues");return t.value})({defaultValue:n,tabValues:r})),[m,f]=function(e){let{queryString:n=!1,groupId:a}=e,i=(0,o.k6)(),r=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,c._X)(r),(0,t.useCallback)(e=>{if(!r)return;let n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})},[r,i])]}({queryString:a,groupId:i}),[y,x]=function(e){let{groupId:n}=e,a=n?"docusaurus.tab.".concat(n):null,[i,r]=(0,u.Nk)(a);return[i,(0,t.useCallback)(e=>{a&&r.set(e)},[a,r])]}({groupId:i}),P=(()=>{let e=null!=m?m:y;return p({value:e,tabValues:r})?e:null})();return(0,l.Z)(()=>{P&&g(P)},[P]),{selectedValue:s,selectValue:(0,t.useCallback)(e=>{if(!p({value:e,tabValues:r}))throw Error("Can't select invalid tab value=".concat(e));g(e),f(e),x(e)},[f,x,r]),tabValues:r}}(e);return(0,i.jsxs)("div",{className:(0,r.Z)("tabs-container","tabList_J5MA"),children:[(0,i.jsx)(m,{...n,...e}),(0,i.jsx)(f,{...n,...e})]})}function x(e){let n=(0,g.Z)();return(0,i.jsx)(y,{...e,children:h(e.children)},String(n))}},980:function(e,n,a){a.d(n,{Z:function(){return o},a:function(){return s}});var i=a(7378);let t={},r=i.createContext(t);function s(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);