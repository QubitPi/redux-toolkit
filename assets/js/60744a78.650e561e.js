"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2026"],{2621:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>a,metadata:()=>s,assets:()=>l,toc:()=>c,contentTitle:()=>o});var s=JSON.parse('{"id":"rtk-query/api/created-api/hooks","title":"API Slices: React Hooks","description":"&nbsp;","source":"@site/../docs/rtk-query/api/created-api/hooks.mdx","sourceDirName":"rtk-query/api/created-api","slug":"/rtk-query/api/created-api/hooks","permalink":"/rtk-query/api/created-api/hooks","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1747226538000,"frontMatter":{"id":"hooks","title":"API Slices: React Hooks","sidebar_label":"React Hooks","hide_title":true},"sidebar":"docs","previous":{"title":"Endpoints","permalink":"/rtk-query/api/created-api/endpoints"},"next":{"title":"Code Splitting","permalink":"/rtk-query/api/created-api/code-splitting"}}'),r=t("4246"),i=t("980");t("8049"),t("5181");let a={id:"hooks",title:"API Slices: React Hooks",sidebar_label:"React Hooks",hide_title:!0},o="API Slices: React Hooks",l={},c=[{value:"Hooks Overview",id:"hooks-overview",level:2},{value:"Generated Hook Names",id:"generated-hook-names",level:3},{value:"Available Hooks",id:"available-hooks",level:3},{value:"Feature Comparison",id:"feature-comparison",level:3},{value:"Primary Hooks",id:"primary-hooks",level:2},{value:"<code>useQuery</code>",id:"usequery",level:3},{value:"<code>useQuery</code> Signature",id:"usequery-signature",level:4},{value:"<code>skipToken</code>",id:"skiptoken",level:4},{value:"<code>useMutation</code>",id:"usemutation",level:3},{value:"<code>useMutation</code> Signature",id:"usemutation-signature",level:4},{value:"<code>useInfiniteQuery</code>",id:"useinfinitequery",level:3},{value:"<code>useInfiniteQuery</code> Signature",id:"useinfinitequery-signature",level:4},{value:"Secondary Hooks",id:"secondary-hooks",level:2},{value:"<code>useLazyQuery</code>",id:"uselazyquery",level:3},{value:"<code>useLazyQuery</code> Signature",id:"uselazyquery-signature",level:4},{value:"<code>usePrefetch</code>",id:"useprefetch",level:3},{value:"Features",id:"features",level:5},{value:"Signature",id:"signature",level:5},{value:"Implementation Hooks",id:"implementation-hooks",level:2},{value:"<code>useQueryState</code>",id:"usequerystate",level:3},{value:"<code>useQueryState</code> Signature",id:"usequerystate-signature",level:5},{value:"<code>useQuerySubscription</code>",id:"usequerysubscription",level:3},{value:"<code>useQuerySubscription</code> Signature",id:"usequerysubscription-signature",level:5},{value:"<code>useInfiniteQueryState</code>",id:"useinfinitequerystate",level:3},{value:"<code>useInfiniteQuerySubscription</code>",id:"useinfinitequerysubscription",level:3},{value:"<code>useLazyQuerySubscription</code>",id:"uselazyquerysubscription",level:3},{value:"<code>useLazyQuerySubscription</code> Signature",id:"uselazyquerysubscription-signature",level:5}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"\xa0"}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"api-slices-react-hooks",children:"API Slices: React Hooks"})}),"\n",(0,r.jsx)(n.h2,{id:"hooks-overview",children:"Hooks Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The core RTK Query ",(0,r.jsx)(n.code,{children:"createApi"})," method is UI-agnostic, in the same way that the Redux core library and Redux Toolkit are UI-agnostic. They are all plain JS logic that can be used anywhere. So, if you import ",(0,r.jsx)(n.code,{children:"createApi"})," from ",(0,r.jsx)(n.code,{children:"'@reduxjs/toolkit/query'"}),", it does not have any specific UI integrations included."]}),"\n",(0,r.jsxs)(n.p,{children:["However, RTK Query also provides the ability to auto-generate React hooks for each of your endpoints. Since this specifically depends on React itself, RTK Query provides an additional entry point that exposes a customized version of ",(0,r.jsx)(n.code,{children:"createApi"})," that includes that functionality:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"import { createApi } from '@reduxjs/toolkit/query/react'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you have used the React-specific version of ",(0,r.jsx)(n.code,{children:"createApi"}),", the generated ",(0,r.jsx)(n.code,{children:"api"})," slice structure will also contain a set of React hooks. The primary endpoint hooks are available as ",(0,r.jsx)(n.code,{children:"api.endpoints[endpointName].useQuery"}),", ",(0,r.jsx)(n.code,{children:"api.endpoints[endpointName].useMutation"}),", and ",(0,r.jsx)(n.code,{children:"api.endpoints[endpointName].useInfiniteQuery"}),", matching how you defined that endpoint."]}),"\n",(0,r.jsx)(n.h3,{id:"generated-hook-names",children:"Generated Hook Names"}),"\n",(0,r.jsxs)(n.p,{children:["The same hooks are also added to the ",(0,r.jsx)(n.code,{children:"api"})," object itself, and given auto-generated names based on the endpoint name and query/mutation type."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, if you had endpoints for ",(0,r.jsx)(n.code,{children:"getPosts"})," and ",(0,r.jsx)(n.code,{children:"updatePost"}),", these options would be available:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Generated React Hook names" no-transpile',children:"// Hooks attached to the endpoint definition\nconst { data } = api.endpoints.getPosts.useQuery()\nconst [updatePost, { data }] = api.endpoints.updatePost.useMutation()\n\n// Same hooks, but given unique names and attached to the API slice object\nconst { data } = api.useGetPostsQuery()\nconst [updatePost, { data }] = api.useUpdatePostMutation()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The general format is ",(0,r.jsx)(n.code,{children:"use(Endpointname)(Query|Mutation|InfiniteQuery)"})," - ",(0,r.jsx)(n.code,{children:"use"})," is prefixed, the first letter of your endpoint name is capitalized, then ",(0,r.jsx)(n.code,{children:"Query"})," or ",(0,r.jsx)(n.code,{children:"Mutation"})," or ",(0,r.jsx)(n.code,{children:"InfiniteQuery"})," is appended depending on the type."]}),"\n",(0,r.jsx)(n.h3,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,r.jsxs)(n.p,{children:["RTK Query provides additional hooks for more advanced use-cases, although not all are generated directly on the ",(0,r.jsx)(n.code,{children:"api"})," object as well."]}),"\n",(0,r.jsx)(n.p,{children:"Most of the hooks are generated on a per-endpoint basis."}),"\n",(0,r.jsxs)(n.p,{children:["The full list of hooks generated in the React-specific version of ",(0,r.jsx)(n.code,{children:"createApi"})," is:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Endpoint-specific, generated the ",(0,r.jsx)(n.code,{children:"api"})," object with a unique name and on the endpoint object with a generic name:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#usequery",children:(0,r.jsx)(n.code,{children:"useQuery"})})," (all standard queries)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#usemutation",children:(0,r.jsx)(n.code,{children:"useMutation"})})," (all mutations)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#useinfinitequery",children:(0,r.jsx)(n.code,{children:"useInfiniteQuery"})})," (only infinite queries)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#uselazyquery",children:(0,r.jsx)(n.code,{children:"useLazyQuery"})})," (all standard queries)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Endpoint-specific, only generated on the endpoint object with a generic name:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#usequerystate",children:(0,r.jsx)(n.code,{children:"useQueryState"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#usequerysubscription",children:(0,r.jsx)(n.code,{children:"useQuerySubscription"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#uselazyquerysubscription",children:(0,r.jsx)(n.code,{children:"useLazyQuerySubscription"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#useinfinitequerystate",children:(0,r.jsx)(n.code,{children:"useInfiniteQueryState"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#useinfinitequerysubscription",children:(0,r.jsx)(n.code,{children:"useInfiniteQuerySubscription"})})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Endpoint-agnostic, generated on the ",(0,r.jsx)(n.code,{children:"api"})," object:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#useprefetch",children:(0,r.jsx)(n.code,{children:"usePrefetch"})})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For the example above, the full set of generated hooks for the api would be like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Generated React Hooks" no-transpile',children:"/* Hooks attached to the `getPosts` query endpoint definition */\napi.endpoints.getPosts.useQuery(arg, options)\napi.endpoints.getPosts.useQueryState(arg, options)\napi.endpoints.getPosts.useQuerySubscription(arg, options)\napi.endpoints.getPosts.useLazyQuery(options)\napi.endpoints.getPosts.useLazyQuerySubscription(options)\n\n/* hooks attached to the `getManyPosts` infinite query endpoint definition */\napi.endpoints.getManyPosts.useInfiniteQuery(arg, options)\napi.endpoints.getManyPosts.useInfiniteQueryState(arg, options)\napi.endpoints.getManyPosts.useInfiniteQuerySubscription(arg, options)\n\n/* Hooks attached to the `updatePost` mutation endpoint definition */\napi.endpoints.updatePost.useMutation(options)\n\n/* Hooks attached to the `api` object */\n// same as api.endpoints.getPosts.useQuery\napi.useGetPostsQuery(arg, options)\n// same as api.endpoints.getPosts.useLazyQuery\napi.useLazyGetPostsQuery(arg, options)\n// same as api.endpoints.updatePost.useMutation\napi.useUpdatePostMutation(arg, options)\n// same as api.endpoints.getManyPosts.useInfiniteQuery\napi.useGetManyPostsInfiniteQuery(arg, options)\n// Generic, used for any endpoint\napi.usePrefetch(endpointName, options)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"feature-comparison",children:"Feature Comparison"}),"\n",(0,r.jsx)(n.p,{children:"The provided hooks have a degree of feature overlap in order to provide options optimized for a given situation. The table below provides a comparison of the core features for each hook."}),"\n",(0,r.jsxs)("table",{style:{"overflow-y":"hidden"},children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{style:{height:"250px",border:"none"},children:[(0,r.jsx)("th",{style:{width:"300px"},children:"Feature"}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#usequery",children:"useQuery"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#usemutation",children:"useMutation"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#usequerystate",children:"useQueryState"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#usequerysubscription",children:"useQuerySubscription"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#uselazyquery",children:"useLazyQuery"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#uselazyquerysubscription",children:"useLazyQuerySubscription"})})}),(0,r.jsx)("th",{style:{"white-space":"nowrap",border:"none"},children:(0,r.jsx)("div",{style:{transform:"translate(0px, 51px) rotate(315deg)",width:"20px"},children:(0,r.jsx)("a",{href:"#useprefetch",children:"usePrefetch"})})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:"Automatically triggers query requests"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Allows manually triggering query requests"})}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Allows manually triggering mutation requests"})}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Subscribes a component to keep cached data in the store"})}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Returns request status and cached data from the store"})}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Re-renders as request status and data become available"})}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{style:{width:"330px"},children:(0,r.jsx)(n.p,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches"})}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{children:"\u2714\uFE0F"}),(0,r.jsx)("td",{})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"primary-hooks",children:"Primary Hooks"}),"\n",(0,r.jsx)(n.p,{children:"These hooks are the main methods you will use to interact with RTK Query in your React components. They encapsulate all of logic and options needed for most data fetching and update use cases."}),"\n",(0,r.jsx)(n.h3,{id:"usequery",children:(0,r.jsx)(n.code,{children:"useQuery"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useQuery hook" no-transpile',children:"const useQueryResult = api.endpoints.getPosts.useQuery(arg, options)\n// or\nconst useQueryResult = api.useGetPostsQuery(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that automatically triggers fetches of data from an endpoint, 'subscribes' the component to the cached data, and reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available."}),"\n",(0,r.jsx)(n.p,{children:"The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already, and the hook will return the data for that query arg once it's available."}),"\n",(0,r.jsxs)(n.p,{children:["This hook combines the functionality of both ",(0,r.jsx)(n.a,{href:"#usequerystate",children:(0,r.jsx)(n.code,{children:"useQueryState"})})," and ",(0,r.jsx)(n.a,{href:"#usequerysubscription",children:(0,r.jsx)(n.code,{children:"useQuerySubscription"})})," together, and is intended to be used in the majority of situations."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met"}),"\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"usequery-signature",children:[(0,r.jsx)(n.code,{children:"useQuery"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'type UseQuery = (\n  arg: any | SkipToken,\n  options?: UseQueryOptions,\n) => UseQueryResult\n\ntype UseQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseQueryResult<T> = {\n  // Base query state\n\n  // Arguments passed to the query\n  originalArgs?: unknown\n  // The latest returned result regardless of hook arg, if present\n  data?: T\n  // The latest returned result for the current hook arg, if present\n  currentData?: T\n  // Error result if present\n  error?: unknown\n  // A string generated by RTK Query\n  requestId?: string\n  // The name of the given endpoint for the query\n  endpointName?: string\n  // Timestamp for when the query was initiated\n  startedTimeStamp?: number\n  // Timestamp for when the query was completed\n  fulfilledTimeStamp?: number\n\n  // Derived request status booleans\n\n  // Query has not started yet.\n  isUninitialized: boolean\n  // Query is currently loading for the first time. No data yet.\n  isLoading: boolean\n  // Query is currently fetching, but might have data from an earlier request.\n  isFetching: boolean\n  // Query has data from a successful load.\n  isSuccess: boolean\n  // Query is currently in an "error" state.\n  isError: boolean\n\n  // A function to force refetch the query - returns a Promise with additional methods\n  refetch: () => QueryActionCreatorResult\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arg"}),": The query argument to be used in constructing the query itself, and as a cache key for the query.\nYou can also pass in ",(0,r.jsx)(n.code,{children:"skipToken"})," here as an alternative way of skipping the query, see ",(0,r.jsx)(n.a,{href:"#skiptoken",children:"skipToken"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the fetching behavior of the hook"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A query result object containing the current loading state, the actual data or error returned from the API call, metadata about the request, and a function to ",(0,r.jsx)(n.code,{children:"refetch"})," the data. Can be customized with ",(0,r.jsx)(n.code,{children:"selectFromResult"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"skiptoken",children:(0,r.jsx)(n.code,{children:"skipToken"})}),"\n",(0,r.jsxs)(n.p,{children:["Can be passed into ",(0,r.jsx)(n.code,{children:"useQuery"}),", ",(0,r.jsx)(n.code,{children:"useQueryState"})," or ",(0,r.jsx)(n.code,{children:"useQuerySubscription"}),"\ninstead of the query argument to get the same effect as if setting\n",(0,r.jsx)(n.code,{children:"skip: true"})," in the query options."]}),"\n",(0,r.jsxs)(n.p,{children:["Useful for scenarios where a query should be skipped when ",(0,r.jsx)(n.code,{children:"arg"})," is ",(0,r.jsx)(n.code,{children:"undefined"}),"\nand TypeScript complains about it because ",(0,r.jsx)(n.code,{children:"arg"})," is not allowed to be passed\nin as ",(0,r.jsx)(n.code,{children:"undefined"}),", such as"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="will error if the query argument is not allowed to be undefined" no-transpile',children:"useSomeQuery(arg, { skip: !!arg })\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="using skipToken instead" no-transpile',children:"useSomeQuery(arg ?? skipToken)\n"})}),"\n",(0,r.jsx)(n.p,{children:"If passed directly into a query or mutation selector, that selector will always\nreturn an uninitialized state."}),"\n",(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsxs)(n.a,{href:"/rtk-query/usage-with-typescript#skipping-queries-with-typescript-using-skiptoken",children:["Skipping queries with TypeScript using ",(0,r.jsx)(n.code,{children:"skipToken"})]})]}),"\n",(0,r.jsx)(n.h3,{id:"usemutation",children:(0,r.jsx)(n.code,{children:"useMutation"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useMutation hook" no-transpile',children:"const useMutationResult = api.endpoints.updatePost.useMutation(options)\n// or\nconst useMutationResult = api.useUpdatePostMutation(options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that lets you trigger an update request for a given endpoint, and subscribes the component to read the request status from the Redux store. The component will re-render as the loading status changes."}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Manual control over firing a request to alter data on the server or possibly invalidate the cache"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"usemutation-signature",children:[(0,r.jsx)(n.code,{children:"useMutation"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'type UseMutation = (\n  options?: UseMutationStateOptions,\n) => [UseMutationTrigger, UseMutationResult | SelectedUseMutationResult]\n\ntype UseMutationStateOptions = {\n  // A method to determine the contents of `UseMutationResult`\n  selectFromResult?: (result: UseMutationStateDefaultResult) => any\n  // A string used to enable shared results across hook instances which have the same key\n  fixedCacheKey?: string\n}\n\ntype UseMutationTrigger<T> = (arg: any) => Promise<\n  { data: T } | { error: BaseQueryError | SerializedError }\n> & {\n  requestId: string // A string generated by RTK Query\n  abort: () => void // A method to cancel the mutation promise\n  unwrap: () => Promise<T> // A method to unwrap the mutation call and provide the raw response/error\n  reset: () => void // A method to manually unsubscribe from the mutation call and reset the result to the uninitialized state\n}\n\ntype UseMutationResult<T> = {\n  // Base query state\n\n  // Arguments passed to the latest mutation call. Not available if using the `fixedCacheKey` option\n  originalArgs?: unknown\n  // Returned result if present\n  data?: T\n  // Error result if present\n  error?: unknown\n  // The name of the given endpoint for the mutation\n  endpointName?: string\n  // Timestamp for when the mutation was completed\n  fulfilledTimeStamp?: number\n\n  // Derived request status booleans\n\n  // Mutation has not been fired yet\n  isUninitialized: boolean\n  // Mutation has been fired and is awaiting a response\n  isLoading: boolean\n  // Mutation has data from a successful call\n  isSuccess: boolean\n  // Mutation is currently in an "error" state\n  isError: boolean\n  // Timestamp for when the latest mutation was initiated\n  startedTimeStamp?: number\n\n  // A method to manually unsubscribe from the mutation call and reset the result to the uninitialized state\n  reset: () => void\n}\n'})}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["The generated ",(0,r.jsx)(n.code,{children:"UseMutation"})," hook will cause a component to re-render by default after the trigger callback is fired, as it affects the properties of the result. If you want to call the trigger but don't care about subscribing to the result with the hook, you can use the ",(0,r.jsx)(n.code,{children:"selectFromResult"})," option to limit the properties that the hook cares about."]}),(0,r.jsx)(n.p,{children:"Returning a completely empty object will mean that any individual mutation call will cause only one re-render at most, e.g."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"selectFromResult: () => ({})\n"})})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the subscription behavior of the hook:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"selectFromResult"}),": A callback that can be used to customize the mutation result returned as the second item in the tuple"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fixedCacheKey"}),": An optional string used to enable shared results across hook instances"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),": A tuple containing:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"trigger"}),": A function that triggers an update to the data based on the provided argument. The trigger function returns a promise with the properties shown above that may be used to handle the behavior of the promise"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mutationState"}),": A query status object containing the current loading state and metadata about the request, or the values returned by the ",(0,r.jsx)(n.code,{children:"selectFromResult"})," option where applicable.\nAdditionally, this object will contain","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["a ",(0,r.jsx)(n.code,{children:"reset"})," method to reset the hook back to its original state and remove the current result from the cache"]}),"\n",(0,r.jsxs)(n.li,{children:["an ",(0,r.jsx)(n.code,{children:"originalArgs"})," property that contains the argument passed to the last call of the ",(0,r.jsx)(n.code,{children:"trigger"})," function."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useinfinitequery",children:(0,r.jsx)(n.code,{children:"useInfiniteQuery"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useQuery hook" no-transpile',children:"const useQueryResult = api.endpoints.getManyPosts.useInfiniteQuery(arg, options)\n// or\nconst useQueryResult = api.useGetManyPostsInfiniteQuery(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that automatically triggers fetches of data from an endpoint, 'subscribes' the component to the cached data, and reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available.  Additionally, it will cache multiple \"pages\" worth of responses within a single cache entry, and allows fetching more pages forwards and backwards from the current cached pages."}),"\n",(0,r.jsx)(n.p,{children:"The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already, and the hook will return the data for that query arg once it's available."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"data"})," field will be a ",(0,r.jsx)(n.code,{children:"{pages: Data[], pageParams: PageParam[]}"})," structure containing all fetched page responses and the corresponding page param values for each page. You may use this to render individual pages, combine all pages into a single infinite list, or other display logic as needed."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook combines the functionality of both ",(0,r.jsx)(n.a,{href:"#useinfinitequerystate",children:(0,r.jsx)(n.code,{children:"useInfiniteQueryState"})})," and ",(0,r.jsx)(n.a,{href:"#useinfinitequerysubscription",children:(0,r.jsx)(n.code,{children:"useInfiniteQuerySubscription"})})," together, and is intended to be used in the majority of situations."]}),"\n",(0,r.jsxs)(n.p,{children:["As with normal query hooks, ",(0,r.jsx)(n.code,{children:"skipToken"})," is a valid argument that will skip the query from executing."]}),"\n",(0,r.jsxs)(n.p,{children:["By default, the initial request will use the ",(0,r.jsx)(n.code,{children:"initialPageParam"})," value that was defined on the infinite query endpoint. If you want to start from a different value, you can pass ",(0,r.jsx)(n.code,{children:"initialPageParam"})," as part of the hook options to override that initial request value."]}),"\n",(0,r.jsxs)(n.p,{children:["Use the returned ",(0,r.jsx)(n.code,{children:"fetchNextPage"})," and ",(0,r.jsx)(n.code,{children:"fetchPreviousPage"})," methods on the hook result object to trigger fetches forwards and backwards. These will always calculate the next or previous page param based on the current cached pages and the provided ",(0,r.jsx)(n.code,{children:"getNext/PreviousPageParam"})," callbacks defined in the endpoint."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Caches multiple pages worth of responses, and provides methods to trigger more page fetches forwards and backwards"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met"}),"\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"useinfinitequery-signature",children:[(0,r.jsx)(n.code,{children:"useInfiniteQuery"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'type UseInfiniteQuery = (\n  arg: any | SkipToken,\n  options?: UseQueryOptions,\n) => UseInfiniteQueryResult\n\ntype InfiniteData<Data, PageParam> = {\n  pages: Array<Data>\n  pageParams: Array<PageParam>\n}\n\ntype UseInfiniteQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n  initialPageParam?: PageParam\n}\n\ntype UseInfiniteQueryResult<Data, PageParam> = {\n  // Base query state\n\n  // Arguments passed to the query\n  originalArgs?: unknown\n  // The latest returned result regardless of hook arg, if present\n  data?: InfiniteData<Data, PageParam>\n  // The latest returned result for the current hook arg, if present\n  currentData?: InfiniteData<Data, PageParam>\n  // Error result if present\n  error?: unknown\n  // A string generated by RTK Query\n  requestId?: string\n  // The name of the given endpoint for the query\n  endpointName?: string\n  // Timestamp for when the query was initiated\n  startedTimeStamp?: number\n  // Timestamp for when the query was completed\n  fulfilledTimeStamp?: number\n\n  // Derived request status booleans\n\n  // Query has not started yet.\n  isUninitialized: boolean\n  // Query is currently loading for the first time. No data yet.\n  isLoading: boolean\n  // Query is currently fetching, but might have data from an earlier request.\n  isFetching: boolean\n  // Query has data from a successful load.\n  isSuccess: boolean\n  // Query is currently in an "error" state.\n  isError: boolean\n\n  // Derived request status booleans for infinite query pages\n\n  // There is another page available querying forwards\n  hasNextPage: boolean\n  // There is another page available querying backwards\n  hasPreviousPage: boolean\n  // The current in-progress fetch is for the next page\n  isFetchingNextPage: boolean\n  // The current in-progress fetch is for the previous page\n  isFetchingPreviousPage: boolean\n  // The current error occurred fetching the next page\n  isFetchNextPageError: boolean\n  // The current error occurred fetching the previous page\n  isFetchPreviousPageError: boolean\n\n  // A function to force refetch the query - returns a Promise with additional methods\n  refetch: () => InfiniteQueryActionCreatorResult\n\n  // Triggers a fetch for the next page, based on the current cache\n  fetchNextPage: () => InfiniteQueryActionCreatorResult\n  // Triggers a fetch for the previous page, based on the current cache\n  fetchPreviousPage: () => InfiniteQueryActionCreatorResult\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arg"}),": The query argument to be used in constructing the query itself, and as a cache key for the query.\nYou can also pass in ",(0,r.jsx)(n.code,{children:"skipToken"})," here as an alternative way of skipping the query, see ",(0,r.jsx)(n.a,{href:"#skiptoken",children:"skipToken"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the fetching behavior of the hook"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A query result object containing the current loading state, the actual data or error returned from the API call, metadata about the request, and a function to ",(0,r.jsx)(n.code,{children:"refetch"})," the data. Can be customized with ",(0,r.jsx)(n.code,{children:"selectFromResult"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"secondary-hooks",children:"Secondary Hooks"}),"\n",(0,r.jsx)(n.p,{children:"These hooks are useful for specific additional use cases in your application, but will probably not be used that frequently."}),"\n",(0,r.jsx)(n.h3,{id:"uselazyquery",children:(0,r.jsx)(n.code,{children:"useLazyQuery"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useLazyQuery hook" no-transpile',children:"const [trigger, result, lastPromiseInfo] =\n  api.endpoints.getPosts.useLazyQuery(options)\n// or\nconst [trigger, result, lastPromiseInfo] = api.useLazyGetPostsQuery(options)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A React hook similar to ",(0,r.jsx)(n.a,{href:"#usequery",children:(0,r.jsx)(n.code,{children:"useQuery"})}),", but with manual control over when the data fetching occurs."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook includes the functionality of ",(0,r.jsx)(n.a,{href:"#uselazyquerysubscription",children:(0,r.jsx)(n.code,{children:"useLazyQuerySubscription"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Manual control over firing a request to retrieve data"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met and the fetch has been manually called at least once"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{children:"Note"}),"\n",(0,r.jsxs)(n.p,{children:["When the trigger function returned from a LazyQuery is called, it always initiates a new request to the server even if there is cached data. Set ",(0,r.jsx)(n.code,{children:"preferCacheValue"}),"(the second argument to the function) as ",(0,r.jsx)(n.code,{children:"true"})," if you want it to immediately return a cached value if one exists."]}),"\n",(0,r.jsxs)(n.h4,{id:"uselazyquery-signature",children:[(0,r.jsx)(n.code,{children:"useLazyQuery"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'type UseLazyQuery = (\n  options?: UseLazyQueryOptions\n) => [UseLazyQueryTrigger, UseLazyQueryStateResult, UseLazyQueryLastPromiseInfo]\n\ntype UseLazyQueryOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseLazyQueryTrigger<T> = (arg: any, preferCacheValue?: boolean) => Promise<\n  QueryResultSelectorResult\n> & {\n  // Whatever argument was provided to the query\n  arg: unknown\n  // A string generated by RTK Query\n  requestId: string\n  // The values used for the query subscription\n  subscriptionOptions: SubscriptionOptions\n\n   // A method to cancel the query promise\n  abort: () => void\n  // A method to unwrap the query call and provide the raw response/error\n  unwrap: () => Promise<T>\n  // A method used to manually unsubscribe from the query results\n  unsubscribe: () => void\n  // A method used to re-run the query. In most cases when using a lazy query, you will never use this and should prefer to call the trigger again.\n  refetch: () => void\n  // A method used to update the subscription options (eg. pollingInterval)\n  updateSubscriptionOptions: (options: SubscriptionOptions) () => void\n}\n\ntype UseLazyQueryStateResult<T> = {\n  // Base query state\n\n  // Arguments passed to the query\n  originalArgs?: unknown\n  // The latest returned result regardless of hook arg, if present\n  data?: T\n  // The latest returned result for the current hook arg, if present\n  currentData?: T\n  // Error result if present\n  error?: unknown\n  // A string generated by RTK Query\n  requestId?: string\n  // The name of the given endpoint for the query\n  endpointName?: string\n  // Timestamp for when the query was initiated\n  startedTimeStamp?: number\n  // Timestamp for when the query was completed\n  fulfilledTimeStamp?: number\n\n  // Derived request status booleans\n\n  // Query has not started yet.\n  isUninitialized: boolean\n  // Query is currently loading for the first time. No data yet.\n  isLoading: boolean\n  // Query is currently fetching, but might have data from an earlier request.\n  isFetching: boolean\n  // Query has data from a successful load.\n  isSuccess: boolean\n  // Query is currently in an "error" state.\n  isError: boolean\n}\n\ntype UseLazyQueryLastPromiseInfo = {\n  lastArg: any\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the fetching behavior and returned result value of the hook. Options affecting fetching behavior will only have an effect after the lazy query has been triggered at least once."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),": A tuple containing:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"trigger"}),": A function that fetches the corresponding data for the endpoint when called"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"result"}),": A query result object containing the current loading state, the actual data or error returned from the API call and metadata about the request. Can be customized with ",(0,r.jsx)(n.code,{children:"selectFromResult"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lastPromiseInfo"}),": An object containing the last argument used to call the trigger function"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useprefetch",children:(0,r.jsx)(n.code,{children:"usePrefetch"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a usePrefetch hook" no-transpile',children:"const prefetchCallback = api.usePrefetch(endpointName, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook which can be used to initiate fetching data ahead of time."}),"\n",(0,r.jsx)(n.h5,{id:"features",children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Manual control over firing a request to retrieve data"}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"signature",children:"Signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type UsePrefetch = (\n  endpointName: string,\n  options?: UsePrefetchOptions,\n) => PrefetchCallback\n\ntype UsePrefetchOptions =\n  | {\n      // If specified, only runs the query if the difference between `new Date()` and the last\n      // `fulfilledTimeStamp` is greater than the given value (in seconds)\n      ifOlderThan?: false | number\n    }\n  | {\n      // If `force: true`, it will ignore the `ifOlderThan` value if it is set and the query\n      // will be run even if it exists in the cache.\n      force?: boolean\n    }\n\ntype PrefetchCallback = (arg: any, options?: UsePrefetchOptions) => void\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"endpointName"}),": The name of the endpoint to prefetch data for"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control whether the prefetch request should occur"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"prefetch"})," callback that when called, will initiate fetching the data for the provided endpoint"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-hooks",children:"Implementation Hooks"}),"\n",(0,r.jsx)(n.p,{children:"This hooks exist as implementation details of the primary hooks. They may be useful in rare cases, but you should generally use the primary hooks in your apps."}),"\n",(0,r.jsx)(n.h3,{id:"usequerystate",children:(0,r.jsx)(n.code,{children:"useQueryState"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useQuery hook" no-transpile',children:"const useQueryStateResult = api.endpoints.getPosts.useQueryState(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available."}),"\n",(0,r.jsxs)(n.p,{children:["Note that this hook does not trigger fetching new data. For that use-case, see ",(0,r.jsx)(n.a,{href:"#usequery",children:(0,r.jsx)(n.code,{children:"useQuery"})})," or ",(0,r.jsx)(n.a,{href:"#usequerysubscription",children:(0,r.jsx)(n.code,{children:"useQuerySubscription"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"usequerystate-signature",children:[(0,r.jsx)(n.code,{children:"useQueryState"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:'type UseQueryState = (\n  arg: any | SkipToken,\n  options?: UseQueryStateOptions,\n) => UseQueryStateResult | SelectedQueryStateResult\n\ntype UseQueryStateOptions = {\n  skip?: boolean\n  selectFromResult?: (result: UseQueryStateDefaultResult) => any\n}\n\ntype UseQueryStateResult<T> = {\n  // Base query state\n\n  // Arguments passed to the query\n  originalArgs?: unknown\n  // The latest returned result regardless of hook arg, if present\n  data?: T\n  // The latest returned result for the current hook arg, if present\n  currentData?: T\n  // Error result if present\n  error?: unknown\n  // A string generated by RTK Query\n  requestId?: string\n  // The name of the given endpoint for the query\n  endpointName?: string\n  // Timestamp for when the query was initiated\n  startedTimeStamp?: number\n  // Timestamp for when the query was completed\n  fulfilledTimeStamp?: number\n\n  // Derived request status booleans\n\n  // Query has not started yet.\n  isUninitialized: boolean\n  // Query is currently loading for the first time. No data yet.\n  isLoading: boolean\n  // Query is currently fetching, but might have data from an earlier request.\n  isFetching: boolean\n  // Query has data from a successful load.\n  isSuccess: boolean\n  // Query is currently in an "error" state.\n  isError: boolean\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arg"}),": The argument passed to the query defined in the endpoint.\nYou can also pass in ",(0,r.jsx)(n.code,{children:"skipToken"})," here as an alternative way of skipping the selection, see ",(0,r.jsx)(n.a,{href:"#skiptoken",children:"skipToken"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the return value for the hook"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A query result object containing the current loading state, the actual data or error returned from the API call and metadata about the request. Can be customized with ",(0,r.jsx)(n.code,{children:"selectFromResult"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usequerysubscription",children:(0,r.jsx)(n.code,{children:"useQuerySubscription"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useQuerySubscription hook" no-transpile',children:"const { refetch } = api.endpoints.getPosts.useQuerySubscription(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that automatically triggers fetches of data from an endpoint, and 'subscribes' the component to the cached data."}),"\n",(0,r.jsx)(n.p,{children:"The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already."}),"\n",(0,r.jsxs)(n.p,{children:["Note that this hook does not return a request status or cached data. For that use-case, see ",(0,r.jsx)(n.a,{href:"#usequery",children:(0,r.jsx)(n.code,{children:"useQuery"})})," or ",(0,r.jsx)(n.a,{href:"#usequerystate",children:(0,r.jsx)(n.code,{children:"useQueryState"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"usequerysubscription-signature",children:[(0,r.jsx)(n.code,{children:"useQuerySubscription"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type UseQuerySubscription = (\n  arg: any | SkipToken,\n  options?: UseQuerySubscriptionOptions,\n) => UseQuerySubscriptionResult\n\ntype UseQuerySubscriptionOptions = {\n  skip?: boolean\n  refetchOnMountOrArgChange?: boolean | number\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n}\n\ntype UseQuerySubscriptionResult = {\n  refetch: () => void // A function to force refetch the query\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arg"}),": The argument passed to the query defined in the endpoint.\nYou can also pass in ",(0,r.jsx)(n.code,{children:"skipToken"})," here as an alternative way of skipping the query, see ",(0,r.jsx)(n.a,{href:"#skiptoken",children:"skipToken"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the fetching behavior of the hook"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An object containing a function to ",(0,r.jsx)(n.code,{children:"refetch"})," the data"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useinfinitequerystate",children:(0,r.jsx)(n.code,{children:"useInfiniteQueryState"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useInfiniteQueryState hook" no-transpile',children:"const useInfiniteQueryStateResult =\n  api.endpoints.getManyPosts.useInfiniteQueryState(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available."}),"\n",(0,r.jsxs)(n.p,{children:["Note that this hook does not trigger fetching new data. For that use-case, see ",(0,r.jsx)(n.a,{href:"#useinfinitequery",children:(0,r.jsx)(n.code,{children:"useInfiniteQuery"})})," or ",(0,r.jsx)(n.a,{href:"#useinfinitequerysubscription",children:(0,r.jsx)(n.code,{children:"useInfiniteQuerySubscription"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns the latest request status and cached data from the Redux store"}),"\n",(0,r.jsx)(n.li,{children:"Re-renders as the request status changes and data becomes available"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useinfinitequerysubscription",children:(0,r.jsx)(n.code,{children:"useInfiniteQuerySubscription"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useInfiniteQuerySubscription hook" no-transpile',children:"const useInfiniteQuerySubscriptionResult =\n  api.endpoints.getManyPosts.useInfiniteQuerySubscription(arg, options)\n"})}),"\n",(0,r.jsx)(n.p,{children:"A React hook that automatically triggers fetches of data from an endpoint, and 'subscribes' the component to the cached data. Additionally, it will cache multiple \"pages\" worth of responses within a single cache entry, and allows fetching more pages forwards and backwards from the current cached pages."}),"\n",(0,r.jsx)(n.p,{children:"The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already."}),"\n",(0,r.jsxs)(n.p,{children:["Note that this hook does not return a request status or cached data. For that use-case, see ",(0,r.jsx)(n.a,{href:"#useinfinitequery",children:(0,r.jsx)(n.code,{children:"useInfiniteQuery"})})," or ",(0,r.jsx)(n.a,{href:"#useinfinitequerystate",children:(0,r.jsx)(n.code,{children:"useInfiniteQueryState"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Caches multiple pages worth of responses, and provides methods to trigger more page fetches forwards and backwards"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"uselazyquerysubscription",children:(0,r.jsx)(n.code,{children:"useLazyQuerySubscription"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="Accessing a useLazyQuerySubscription hook" no-transpile',children:"const [trigger, lastArg] =\n  api.endpoints.getPosts.useLazyQuerySubscription(options)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A React hook similar to ",(0,r.jsx)(n.a,{href:"#usequerysubscription",children:(0,r.jsx)(n.code,{children:"useQuerySubscription"})}),", but with manual control over when the data fetching occurs."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that this hook does not return a request status or cached data. For that use-case, see ",(0,r.jsx)(n.a,{href:"#uselazyquery",children:(0,r.jsx)(n.code,{children:"useLazyQuery"})}),"."]}),"\n",(0,r.jsx)(n.h4,{children:"Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Manual control over firing a request to retrieve data"}),"\n",(0,r.jsx)(n.li,{children:"'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts"}),"\n",(0,r.jsx)(n.li,{children:"Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met and the fetch has been manually called at least once"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"uselazyquerysubscription-signature",children:[(0,r.jsx)(n.code,{children:"useLazyQuerySubscription"})," Signature"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"no-transpile",children:"type UseLazyQuerySubscription = (\n  options?: UseLazyQuerySubscriptionOptions,\n) => [UseLazyQuerySubscriptionTrigger, LastArg]\n\ntype UseLazyQuerySubscriptionOptions = {\n  pollingInterval?: number\n  skipPollingIfUnfocused?: boolean\n  refetchOnReconnect?: boolean\n  refetchOnFocus?: boolean\n}\n\ntype UseLazyQuerySubscriptionTrigger = (\n  arg: any,\n  preferCacheValue?: boolean,\n) => void\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options"}),": A set of options that control the fetching behavior of the hook. The options will only have an effect after the lazy query has been triggered at least once."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),": A tuple containing:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"trigger"}),": A function that fetches the corresponding data for the endpoint when called"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lastArg"}),": The last argument used to call the trigger function"]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8049:function(e,n,t){t.d(n,{Z:()=>i});var s=t("4246");t("7378");var r=t("4870");function i(e){let{children:n,hidden:t,className:i}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.Z)("tabItem_wHwb",i),hidden:t,children:n})}},5181:function(e,n,t){t.d(n,{Z:()=>j});var s=t("4246"),r=t("7378"),i=t("4870"),a=t("5403"),o=t("3620"),l=t("7090"),c=t("6180"),d=t("3418"),u=t("9073");function h(e){var n,t;return null!==(t=null===(n=r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==t?t:[]}function p(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var g=t("3344");function x(e){let{className:n,block:t,selectedValue:r,selectValue:o,tabValues:l}=e,c=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.o5)(),u=e=>{let n=e.currentTarget,t=l[c.indexOf(n)].value;t!==r&&(d(n),o(t))},h=e=>{var n,t;let s=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let t=c.indexOf(e.currentTarget)+1;s=null!==(n=c[t])&&void 0!==n?n:c[0];break}case"ArrowLeft":{let n=c.indexOf(e.currentTarget)-1;s=null!==(t=c[n])&&void 0!==t?t:c[c.length-1]}}null==s||s.focus()};return(0,s.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n),children:l.map(e=>{let{value:n,label:t,attributes:a}=e;return(0,s.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>c.push(e),onKeyDown:h,onClick:u,...a,className:(0,i.Z)("tabs__item","tabItem_l0OV",null==a?void 0:a.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)})})}function y(e){let{lazy:n,children:t,selectedValue:a}=e,o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=o.find(e=>e.props.value===a);return e?(0,r.cloneElement)(e,{className:(0,i.Z)("margin-top--md",e.props.className)}):null}return(0,s.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function f(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:s}=e,i=function(e){let{values:n,children:t}=e;return(0,r.useMemo)(()=>{let e=null!=n?n:h(t).map(e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}});return!function(e){let n=(0,d.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,t])}(e),[a,g]=(0,r.useState)(()=>(function(e){var n;let{defaultValue:t,tabValues:s}=e;if(0===s.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:s}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(t,'" but none of its children has the corresponding value. Available values are: ').concat(s.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return t}let r=null!==(n=s.find(e=>e.default))&&void 0!==n?n:s[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:n,tabValues:i})),[x,y]=function(e){let{queryString:n=!1,groupId:t}=e,s=(0,o.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,c._X)(i),(0,r.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(s.location.search);n.set(i,e),s.replace({...s.location,search:n.toString()})},[i,s])]}({queryString:t,groupId:s}),[f,j]=function(e){let{groupId:n}=e,t=n?"docusaurus.tab.".concat(n):null,[s,i]=(0,u.Nk)(t);return[s,(0,r.useCallback)(e=>{t&&i.set(e)},[t,i])]}({groupId:s}),m=(()=>{let e=null!=x?x:f;return p({value:e,tabValues:i})?e:null})();return(0,l.Z)(()=>{m&&g(m)},[m]),{selectedValue:a,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:i}))throw Error("Can't select invalid tab value=".concat(e));g(e),y(e),j(e)},[y,j,i]),tabValues:i}}(e);return(0,s.jsxs)("div",{className:(0,i.Z)("tabs-container","tabList_J5MA"),children:[(0,s.jsx)(x,{...n,...e}),(0,s.jsx)(y,{...n,...e})]})}function j(e){let n=(0,g.Z)();return(0,s.jsx)(f,{...e,children:h(e.children)},String(n))}},980:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return a}});var s=t(7378);let r={},i=s.createContext(r);function a(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);