"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["7061"],{2514:function(e,t,a){a.r(t),a.d(t,{default:()=>p,frontMatter:()=>d,metadata:()=>n,assets:()=>o,toc:()=>u,contentTitle:()=>l});var n=JSON.parse('{"id":"rtk-query/usage/manual-cache-updates","title":"Manual Cache Updates","description":"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually","source":"@site/../docs/rtk-query/usage/manual-cache-updates.mdx","sourceDirName":"rtk-query/usage","slug":"/rtk-query/usage/manual-cache-updates","permalink":"/rtk-query/usage/manual-cache-updates","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1753994190000,"frontMatter":{"id":"manual-cache-updates","title":"Manual Cache Updates","sidebar_label":"Manual Cache Updates","hide_title":true,"description":"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},"sidebar":"docs","previous":{"title":"Conditional Fetching","permalink":"/rtk-query/usage/conditional-fetching"},"next":{"title":"Error Handling","permalink":"/rtk-query/usage/error-handling"}}'),i=a("4246"),r=a("980"),s=a("8049"),c=a("5181");let d={id:"manual-cache-updates",title:"Manual Cache Updates",sidebar_label:"Manual Cache Updates",hide_title:!0,description:"RTK Query > Usage > Manual Cache Updates: Updating and creating cached data manually"},l="Manual Cache Updates",o={},u=[{value:"Overview",id:"overview",level:2},{value:"Updating existing cache entries",id:"updating-existing-cache-entries",level:3},{value:"Creating new cache entries or replacing existing ones",id:"creating-new-cache-entries-or-replacing-existing-ones",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Example",id:"example",level:4},{value:"Pessimistic Updates",id:"pessimistic-updates",level:3},{value:"General Updates",id:"general-updates",level:3}];function h(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"manual-cache-updates",children:"Manual Cache Updates"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:["For most cases, in order to receive up to date data after a triggering a change in the backend, you can take advantage of cache tag invalidation to perform ",(0,i.jsx)(t.a,{href:"./automated-refetching",children:"automated re-fetching"}),". This will cause a query to re-fetch its data when it has been told that a mutation has occurred which would cause its data to become out of date."]}),"\n",(0,i.jsx)(t.p,{children:"We recommend using automated re-fetching as a preference over manual cache updates in most situations."}),"\n",(0,i.jsxs)(t.p,{children:["However, there ",(0,i.jsx)(t.em,{children:"are"}),' use cases when manual cache updates are necessary, such as "optimistic" or "pessimistic" updates, or modifying data as part of cache entry lifecycles.']}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query exports thunks for these use cases, attached to ",(0,i.jsx)(t.code,{children:"api.utils"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/rtk-query/api/created-api/api-slice-utils#updatequerydata",children:(0,i.jsx)(t.code,{children:"updateQueryData"})}),": updates an already existing cache entry"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/rtk-query/api/created-api/api-slice-utils#upsertquerydata",children:(0,i.jsx)(t.code,{children:"upsertQueryData"})}),": creates or replaces cache entries"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Since these are thunks, you can dispatch them anywhere you have access to ",(0,i.jsx)(t.code,{children:"dispatch"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"updating-existing-cache-entries",children:"Updating existing cache entries"}),"\n",(0,i.jsxs)(t.p,{children:["For updates of existing cache entries, use ",(0,i.jsx)(t.a,{href:"/rtk-query/api/created-api/api-slice-utils#updatequerydata",children:(0,i.jsx)(t.code,{children:"updateQueryData"})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"updateQueryData"})," is strictly intended to perform ",(0,i.jsx)(t.em,{children:"updates"})," to existing cache entries, not create new entries. If an ",(0,i.jsx)(t.code,{children:"updateQueryData"})," thunk action is dispatched and the ",(0,i.jsx)(t.code,{children:"endpointName"})," + ",(0,i.jsx)(t.code,{children:"args"})," combination that does not match any existing cache entry, the provided ",(0,i.jsx)(t.code,{children:"recipe"})," callback will not be called, and no ",(0,i.jsx)(t.code,{children:"patches"})," or ",(0,i.jsx)(t.code,{children:"inversePatches"})," will be returned."]}),"\n",(0,i.jsx)(t.p,{children:"Use cases for manual update of cache entries:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Providing immediate feedback to the user when a mutation is attempted"}),"\n",(0,i.jsx)(t.li,{children:"After a mutation, updating a single item in a large list of items that is already cached, rather than re-fetching the whole list"}),"\n",(0,i.jsx)(t.li,{children:"Debouncing a large number of mutations with immediate feedback as though they are being applied, followed by a single request sent to the server to update the debounced attempts"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"creating-new-cache-entries-or-replacing-existing-ones",children:"Creating new cache entries or replacing existing ones"}),"\n",(0,i.jsxs)(t.p,{children:["To create or replace existing cache entries, use ",(0,i.jsx)(t.a,{href:"/rtk-query/api/created-api/api-slice-utils#upsertquerydata",children:(0,i.jsx)(t.code,{children:"upsertQueryData"})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"upsertQueryData"})," is intended to perform ",(0,i.jsx)(t.em,{children:"replacements"})," to existing cache entries or ",(0,i.jsx)(t.em,{children:"creation"})," of new ones. Since ",(0,i.jsx)(t.code,{children:"upsertQueryData"})," does not have access to the previous state of the cache entry, the update may be performed only as a replacement. In comparison, ",(0,i.jsx)(t.code,{children:"updateQueryData"})," allows patching of the existing cache entry, but cannot create a new one."]}),"\n",(0,i.jsxs)(t.p,{children:["One example use case is ",(0,i.jsx)(t.a,{href:"/rtk-query/usage/manual-cache-updates#pessimistic-updates",children:"pessimistic updates"}),". If the client makes an API call to create a ",(0,i.jsx)(t.code,{children:"Post"}),", the backend could return its complete data including the ",(0,i.jsx)(t.code,{children:"id"}),". Then we can use ",(0,i.jsx)(t.code,{children:"upsertQueryData"})," to create a new cache entry for the ",(0,i.jsx)(t.code,{children:"getPostById(id)"})," query, preventing an extra fetch to retrieve the item later."]}),"\n",(0,i.jsx)(t.h2,{id:"recipes",children:"Recipes"}),"\n",(0,i.jsx)(t.h3,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,i.jsxs)(t.p,{children:["When you wish to perform an update to cache data immediately after a ",(0,i.jsx)(t.a,{href:"./mutations",children:(0,i.jsx)(t.code,{children:"mutation"})})," is\ntriggered, you can apply an ",(0,i.jsx)(t.code,{children:"optimistic update"}),". This can be a useful pattern for when you want to\ngive the user the impression that their changes are immediate, even while the mutation request is\nstill in flight."]}),"\n",(0,i.jsx)(t.p,{children:"The core concepts for an optimistic update are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["when you start a query or mutation, ",(0,i.jsx)(t.code,{children:"onQueryStarted"})," will be executed"]}),"\n",(0,i.jsxs)(t.li,{children:["you manually update the cached data by dispatching ",(0,i.jsx)(t.code,{children:"api.util.updateQueryData"})," within ",(0,i.jsx)(t.code,{children:"onQueryStarted"})]}),"\n",(0,i.jsxs)(t.li,{children:["then, in the case that ",(0,i.jsx)(t.code,{children:"queryFulfilled"})," rejects:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["you roll it back via the ",(0,i.jsx)(t.code,{children:".undo"})," property of the object you got back from the earlier dispatch,\nOR"]}),"\n",(0,i.jsxs)(t.li,{children:["you invalidate the cache data via ",(0,i.jsx)(t.code,{children:"api.util.invalidateTags"})," to trigger a full re-fetch of the data"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["Where many mutations are potentially triggered in short succession causing overlapping requests,\nyou may encounter race conditions if attempting to roll back patches using the ",(0,i.jsx)(t.code,{children:".undo"})," property\non failures. For these scenarios, it is often simplest and safest to invalidate the tags on error\ninstead, and re-fetch truly up-to-date data from the server."]})}),"\n",(0,i.jsxs)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,i.jsx)(s.Z,{value:"ts",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Optimistic update mutation example (async await)"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<void, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          }),\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,i.jsx)(s.Z,{value:"js",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",metastring:'title="Optimistic update mutation example (async await)"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          }),\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,i.jsxs)(t.p,{children:["or, if you prefer the slightly shorter version with ",(0,i.jsx)(t.code,{children:".catch"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:"-      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n+      onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n-       try {\n-         await queryFulfilled\n-       } catch {\n-         patchResult.undo()\n-       }\n+       queryFulfilled.catch(patchResult.undo)\n      }\n"})}),"\n",(0,i.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"./examples#react-optimistic-updates",children:"React Optimistic Updates"})}),"\n",(0,i.jsx)(t.h3,{id:"pessimistic-updates",children:"Pessimistic Updates"}),"\n",(0,i.jsxs)(t.p,{children:["When you wish to perform an update to cache data based on the response received from the server\nafter a ",(0,i.jsx)(t.a,{href:"./mutations",children:(0,i.jsx)(t.code,{children:"mutation"})})," is triggered, you can apply a ",(0,i.jsx)(t.code,{children:"pessimistic update"}),".\nThe distinction between a ",(0,i.jsx)(t.code,{children:"pessimistic update"})," and an ",(0,i.jsx)(t.code,{children:"optimistic update"})," is that the\n",(0,i.jsx)(t.code,{children:"pessimistic update"})," will instead wait for the response from the server prior to updating\nthe cached data."]}),"\n",(0,i.jsx)(t.p,{children:"The core concepts for a pessimistic update are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["when you start a query or mutation, ",(0,i.jsx)(t.code,{children:"onQueryStarted"})," will be executed"]}),"\n",(0,i.jsxs)(t.li,{children:["you await ",(0,i.jsx)(t.code,{children:"queryFulfilled"})," to resolve to an object containing the transformed response from the\nserver in the ",(0,i.jsx)(t.code,{children:"data"})," property"]}),"\n",(0,i.jsxs)(t.li,{children:["you manually update the cached data by dispatching ",(0,i.jsx)(t.code,{children:"api.util.updateQueryData"})," within\n",(0,i.jsx)(t.code,{children:"onQueryStarted"}),", using the data in the response from the server for your draft updates"]}),"\n",(0,i.jsxs)(t.li,{children:["you manually create a new cache entry by dispatching ",(0,i.jsx)(t.code,{children:"api.util.upsertQueryData"})," within ",(0,i.jsx)(t.code,{children:"onQueryStarted"}),",\nusing the complete Post object returned by backend."]}),"\n"]}),"\n",(0,i.jsxs)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,i.jsx)(s.Z,{value:"ts",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="Pessimistic update mutation example (async await)"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport type { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            }),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n    createPost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})}),(0,i.jsx)(s.Z,{value:"js",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",metastring:'title="Pessimistic update mutation example (async await)"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            }),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n    createPost: build.mutation({\n      query: ({ id, ...body }) => ({\n        url: `post/${id}`,\n        method: 'POST',\n        body,\n      }),\n      // highlight-start\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: createdPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.upsertQueryData('getPost', id, createdPost),\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n"})})})]}),"\n",(0,i.jsx)(t.h3,{id:"general-updates",children:"General Updates"}),"\n",(0,i.jsxs)(t.p,{children:["If you find yourself wanting to update cache data elsewhere in your application, you can do so\nanywhere you have access to the ",(0,i.jsx)(t.code,{children:"store.dispatch"})," method, including within React components via\nthe ",(0,i.jsx)(t.a,{href:"https://react-redux.js.org/api/hooks#usedispatch",children:"useDispatch"})," hook (or a typed version such\nas ",(0,i.jsx)(t.a,{href:"https://react-redux.js.org/using-react-redux/usage-with-typescript#define-typed-hooks",children:"useAppDispatch"}),"\nfor typescript users)."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["You should generally avoid manually updating the cache outside of the ",(0,i.jsx)(t.code,{children:"onQueryStarted"}),"\ncallback for a mutation without a good reason, as RTK Query is intended to be used by considering\nyour cached data as a reflection of the server-side state."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'no-transpile title="General manual cache update example"',children:"import { api } from './api'\nimport { useAppDispatch } from './store/hooks'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n\n  function handleClick() {\n    /**\n     * This will update the cache data for the query corresponding to the `getPosts` endpoint,\n     * when that endpoint is used with no argument (undefined).\n     */\n    const patchCollection = dispatch(\n      api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n        draftPosts.push({ id: 1, name: 'Teddy' })\n      }),\n    )\n  }\n\n  return <button onClick={handleClick}>Add post to cache</button>\n}\n"})})]})}function p(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8049:function(e,t,a){a.d(t,{Z:()=>r});var n=a("4246");a("7378");var i=a("4870");function r(e){let{children:t,hidden:a,className:r}=e;return(0,n.jsx)("div",{role:"tabpanel",className:(0,i.Z)("tabItem_wHwb",r),hidden:a,children:t})}},5181:function(e,t,a){a.d(t,{Z:()=>x});var n=a("4246"),i=a("7378"),r=a("4870"),s=a("5403"),c=a("3620"),d=a("7090"),l=a("6180"),o=a("3418"),u=a("9073");function h(e){var t,a;return null!==(a=null===(t=i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){let{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===t?void 0:t.filter(Boolean))&&void 0!==a?a:[]}function p(e){let{value:t,tabValues:a}=e;return a.some(e=>e.value===t)}var y=a("3344");function m(e){let{className:t,block:a,selectedValue:i,selectValue:c,tabValues:d}=e,l=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.o5)(),u=e=>{let t=e.currentTarget,a=d[l.indexOf(t)].value;a!==i&&(o(t),c(a))},h=e=>{var t,a;let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let a=l.indexOf(e.currentTarget)+1;n=null!==(t=l[a])&&void 0!==t?t:l[0];break}case"ArrowLeft":{let t=l.indexOf(e.currentTarget)-1;n=null!==(a=l[t])&&void 0!==a?a:l[l.length-1]}}null==n||n.focus()};return(0,n.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},t),children:d.map(e=>{let{value:t,label:a,attributes:s}=e;return(0,n.jsx)("li",{role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,ref:e=>l.push(e),onKeyDown:h,onClick:u,...s,className:(0,r.Z)("tabs__item","tabItem_l0OV",null==s?void 0:s.className,{"tabs__item--active":i===t}),children:null!=a?a:t},t)})})}function f(e){let{lazy:t,children:a,selectedValue:s}=e,c=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){let e=c.find(e=>e.props.value===s);return e?(0,i.cloneElement)(e,{className:(0,r.Z)("margin-top--md",e.props.className)}):null}return(0,n.jsx)("div",{className:"margin-top--md",children:c.map((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==s}))})}function g(e){let t=function(e){let{defaultValue:t,queryString:a=!1,groupId:n}=e,r=function(e){let{values:t,children:a}=e;return(0,i.useMemo)(()=>{let e=null!=t?t:h(a).map(e=>{let{props:{value:t,label:a,attributes:n,default:i}}=e;return{value:t,label:a,attributes:n,default:i}});return!function(e){let t=(0,o.lx)(e,(e,t)=>e.value===t.value);if(t.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(t.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[t,a])}(e),[s,y]=(0,i.useState)(()=>(function(e){var t;let{defaultValue:a,tabValues:n}=e;if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!p({value:a,tabValues:n}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(a,'" but none of its children has the corresponding value. Available values are: ').concat(n.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return a}let i=null!==(t=n.find(e=>e.default))&&void 0!==t?t:n[0];if(!i)throw Error("Unexpected error: 0 tabValues");return i.value})({defaultValue:t,tabValues:r})),[m,f]=function(e){let{queryString:t=!1,groupId:a}=e,n=(0,c.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:t,groupId:a});return[(0,l._X)(r),(0,i.useCallback)(e=>{if(!r)return;let t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})},[r,n])]}({queryString:a,groupId:n}),[g,x]=function(e){let{groupId:t}=e,a=t?"docusaurus.tab.".concat(t):null,[n,r]=(0,u.Nk)(a);return[n,(0,i.useCallback)(e=>{a&&r.set(e)},[a,r])]}({groupId:n}),j=(()=>{let e=null!=m?m:g;return p({value:e,tabValues:r})?e:null})();return(0,d.Z)(()=>{j&&y(j)},[j]),{selectedValue:s,selectValue:(0,i.useCallback)(e=>{if(!p({value:e,tabValues:r}))throw Error("Can't select invalid tab value=".concat(e));y(e),f(e),x(e)},[f,x,r]),tabValues:r}}(e);return(0,n.jsxs)("div",{className:(0,r.Z)("tabs-container","tabList_J5MA"),children:[(0,n.jsx)(m,{...t,...e}),(0,n.jsx)(f,{...t,...e})]})}function x(e){let t=(0,y.Z)();return(0,n.jsx)(g,{...e,children:h(e.children)},String(t))}},980:function(e,t,a){a.d(t,{Z:function(){return c},a:function(){return s}});var n=a(7378);let i={},r=n.createContext(i);function s(e){let t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);