"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["5931"],{3659:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>i,assets:()=>c,toc:()=>u,contentTitle:()=>d});var i=JSON.parse('{"id":"rtk-query/usage/code-splitting","title":"Code Splitting","description":"RTK Query > Usage > Code Splitting: dynamic injection of endpoints","source":"@site/../docs/rtk-query/usage/code-splitting.mdx","sourceDirName":"rtk-query/usage","slug":"/rtk-query/usage/code-splitting","permalink":"/rtk-query/usage/code-splitting","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1747226909000,"frontMatter":{"id":"code-splitting","title":"Code Splitting","sidebar_label":"Code Splitting","hide_title":true,"description":"RTK Query > Usage > Code Splitting: dynamic injection of endpoints"},"sidebar":"docs","previous":{"title":"Streaming Updates","permalink":"/rtk-query/usage/streaming-updates"},"next":{"title":"Code Generation","permalink":"/rtk-query/usage/code-generation"}}'),a=t("4246"),r=t("980"),s=t("8049"),l=t("5181");let o={id:"code-splitting",title:"Code Splitting",sidebar_label:"Code Splitting",hide_title:!0,description:"RTK Query > Usage > Code Splitting: dynamic injection of endpoints"},d="Code Splitting",c={},u=[{value:"Overview",id:"overview",level:2},{value:"Injecting Endpoints",id:"injecting-endpoints",level:2},{value:"Enhancing Endpoints",id:"enhancing-endpoints",level:2}];function p(e){let n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"\xa0"}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"code-splitting",children:"Code Splitting"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"By default, an RTK Query API definition normally has all of the endpoint definitions in a single file. However, in larger applications this can result in very large files that may be harder to maintain. It also means that all of the relevant code is being imported right away."}),"\n",(0,a.jsxs)(n.p,{children:["RTK Query allows dynamically injecting endpoint definitions into an existing API service object. This enables splitting up endpoints into multiple files for maintainability, as well as lazy-loading endpoint definitions and associated code to trim down initial bundle sizes. This can be very beneficial for larger applications that may have ",(0,a.jsx)(n.em,{children:"many"})," endpoints."]}),"\n",(0,a.jsx)(n.h2,{id:"injecting-endpoints",children:"Injecting Endpoints"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"api.injectEndpoints"})," accepts a collection of endpoint definitions (same as ",(0,a.jsx)(n.code,{children:"createApi"}),"), as well as an optional ",(0,a.jsx)(n.code,{children:"overrideExisting"})," parameter."]}),"\n",(0,a.jsxs)(n.p,{children:["Calling ",(0,a.jsx)(n.code,{children:"api.injectEndpoints"})," will inject the endpoints into the original API service object, modifying it immediately. It returns ",(0,a.jsxs)(n.strong,{children:["the ",(0,a.jsx)(n.em,{children:"same"})," API service object reference"]}),". If you're using TypeScript, the return value has the TS types for the new endpoints included. (Unfortunately, it cannot modify the types for the original API reference.)"]}),"\n",(0,a.jsx)(n.p,{children:"A typical approach would be to have one empty central API slice definition:"}),"\n",(0,a.jsxs)(l.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Basic setup"',children:"// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// initialize an empty api service that we'll inject endpoints into later as needed\nexport const emptySplitApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="Basic setup"',children:"// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// initialize an empty api service that we'll inject endpoints into later as needed\nexport const emptySplitApi = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: () => ({}),\n})\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"and then inject the api endpoints in other files and export them from there - that way you will be sure to always import the endpoints in a way that they are definitely injected."}),"\n",(0,a.jsxs)(l.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Injecting & exporting additional endpoints"',children:"import { emptySplitApi } from './emptySplitApi'\n\n// NOTE: these are the _SAME_ API reference!\nconst extendedApi = emptySplitApi.injectEndpoints({\n  endpoints: (build) => ({\n    example: build.query({\n      query: () => 'test',\n    }),\n  }),\n  overrideExisting: false,\n})\n\nexport const { useExampleQuery } = extendedApi\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:'title="Injecting & exporting additional endpoints"',children:"import { emptySplitApi } from './emptySplitApi'\n\n// NOTE: these are the _SAME_ API reference!\nconst extendedApi = emptySplitApi.injectEndpoints({\n  endpoints: (build) => ({\n    example: build.query({\n      query: () => 'test',\n    }),\n  }),\n  overrideExisting: false,\n})\n\nexport const { useExampleQuery } = extendedApi\n"})})})]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If you inject an endpoint that already exists and don't explicitly specify ",(0,a.jsx)(n.code,{children:"overrideExisting: true"}),", the endpoint\nwill not be overridden. In development mode, you will get a warning about this if ",(0,a.jsx)(n.code,{children:"overrideExisting"})," is set to ",(0,a.jsx)(n.code,{children:"false"}),",\nand an error will be throw if set to ",(0,a.jsx)(n.code,{children:"'throw'"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"enhancing-endpoints",children:"Enhancing Endpoints"}),"\n",(0,a.jsx)(n.p,{children:"Sometimes you may also need to modify an existing API definition, such as adding additional tag types, or providing additional configuration options to a given endpoint."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"api.enhanceEndpoints"})," returns an updated and enhanced version of the API slice object, containing the combined endpoint definitions."]}),"\n",(0,a.jsx)(n.p,{children:"This is primarily useful for taking an API slice object that was code-generated from an API schema file like OpenAPI, and adding additional specific hand-written configuration for cache invalidation management on top of the generated endpoint definitions."}),"\n",(0,a.jsxs)(n.p,{children:["For example, ",(0,a.jsx)(n.code,{children:"enhanceEndpoints"})," can be used to modify caching behavior by changing the values of ",(0,a.jsx)(n.code,{children:"providesTags"}),", ",(0,a.jsx)(n.code,{children:"invalidatesTags"}),", and ",(0,a.jsx)(n.code,{children:"keepUnusedDataFor"}),":"]}),"\n",(0,a.jsxs)(l.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],children:[(0,a.jsx)(s.Z,{value:"ts",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { api } from './api'\n\nconst enhancedApi = api.enhanceEndpoints({\n  addTagTypes: ['User'],\n  endpoints: {\n    getUserByUserId: {\n      providesTags: ['User'],\n    },\n    patchUserByUserId: {\n      invalidatesTags: ['User'],\n    },\n    // alternatively, define a function which is called with the endpoint definition as an argument\n    getUsers(endpoint) {\n      endpoint.providesTags = ['User']\n      endpoint.keepUnusedDataFor = 120\n    },\n  },\n})\n"})})}),(0,a.jsx)(s.Z,{value:"js",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { api } from './api'\n\nconst enhancedApi = api.enhanceEndpoints({\n  addTagTypes: ['User'],\n  endpoints: {\n    getUserByUserId: {\n      providesTags: ['User'],\n    },\n    patchUserByUserId: {\n      invalidatesTags: ['User'],\n    },\n    // alternatively, define a function which is called with the endpoint definition as an argument\n    getUsers(endpoint) {\n      endpoint.providesTags = ['User']\n      endpoint.keepUnusedDataFor = 120\n    },\n  },\n})\n"})})})]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8049:function(e,n,t){t.d(n,{Z:()=>r});var i=t("4246");t("7378");var a=t("4870");function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.Z)("tabItem_wHwb",r),hidden:t,children:n})}},5181:function(e,n,t){t.d(n,{Z:()=>y});var i=t("4246"),a=t("7378"),r=t("4870"),s=t("5403"),l=t("3620"),o=t("7090"),d=t("6180"),c=t("3418"),u=t("9073");function p(e){var n,t;return null!==(t=null===(n=a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))||void 0===n?void 0:n.filter(Boolean))&&void 0!==t?t:[]}function h(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var f=t("3344");function g(e){let{className:n,block:t,selectedValue:a,selectValue:l,tabValues:o}=e,d=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),u=e=>{let n=e.currentTarget,t=o[d.indexOf(n)].value;t!==a&&(c(n),l(t))},p=e=>{var n,t;let i=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let t=d.indexOf(e.currentTarget)+1;i=null!==(n=d[t])&&void 0!==n?n:d[0];break}case"ArrowLeft":{let n=d.indexOf(e.currentTarget)-1;i=null!==(t=d[n])&&void 0!==t?t:d[d.length-1]}}null==i||i.focus()};return(0,i.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},n),children:o.map(e=>{let{value:n,label:t,attributes:s}=e;return(0,i.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>d.push(e),onKeyDown:p,onClick:u,...s,className:(0,r.Z)("tabs__item","tabItem_l0OV",null==s?void 0:s.className,{"tabs__item--active":a===n}),children:null!=t?t:n},n)})})}function m(e){let{lazy:n,children:t,selectedValue:s}=e,l=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=l.find(e=>e.props.value===s);return e?(0,a.cloneElement)(e,{className:(0,r.Z)("margin-top--md",e.props.className)}):null}return(0,i.jsx)("div",{className:"margin-top--md",children:l.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function v(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:i}=e,r=function(e){let{values:n,children:t}=e;return(0,a.useMemo)(()=>{let e=null!=n?n:p(t).map(e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}});return!function(e){let n=(0,c.lx)(e,(e,n)=>e.value===n.value);if(n.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(n.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'))}(e),e},[n,t])}(e),[s,f]=(0,a.useState)(()=>(function(e){var n;let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:i}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(t,'" but none of its children has the corresponding value. Available values are: ').concat(i.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return t}let a=null!==(n=i.find(e=>e.default))&&void 0!==n?n:i[0];if(!a)throw Error("Unexpected error: 0 tabValues");return a.value})({defaultValue:n,tabValues:r})),[g,m]=function(e){let{queryString:n=!1,groupId:t}=e,i=(0,l.k6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,d._X)(r),(0,a.useCallback)(e=>{if(!r)return;let n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})},[r,i])]}({queryString:t,groupId:i}),[v,y]=function(e){let{groupId:n}=e,t=n?"docusaurus.tab.".concat(n):null,[i,r]=(0,u.Nk)(t);return[i,(0,a.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:i}),j=(()=>{let e=null!=g?g:v;return h({value:e,tabValues:r})?e:null})();return(0,o.Z)(()=>{j&&f(j)},[j]),{selectedValue:s,selectValue:(0,a.useCallback)(e=>{if(!h({value:e,tabValues:r}))throw Error("Can't select invalid tab value=".concat(e));f(e),m(e),y(e)},[m,y,r]),tabValues:r}}(e);return(0,i.jsxs)("div",{className:(0,r.Z)("tabs-container","tabList_J5MA"),children:[(0,i.jsx)(g,{...n,...e}),(0,i.jsx)(m,{...n,...e})]})}function y(e){let n=(0,f.Z)();return(0,i.jsx)(v,{...e,children:p(e.children)},String(n))}},980:function(e,n,t){t.d(n,{Z:function(){return l},a:function(){return s}});var i=t(7378);let a={},r=i.createContext(a);function s(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);