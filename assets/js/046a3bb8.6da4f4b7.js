"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[354],{3411:function(e,t,n){n.d(t,{Z:function(){return o}});var r=n(7378),a=n(7140),i="tabItem_wHwb";function o(e){var t=e.children,n=e.hidden,o=e.className;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i,o),hidden:n},t)}},2453:function(e,t,n){n.d(t,{Z:function(){return m}});var r=n(2685),a=n(7378),i=n(7140),o=n(362),l=n(56),c=n(5720),s=n(9169),u="tabList_J5MA",d="tabItem_l0OV";function p(e){var t,n,o=e.lazy,p=e.block,m=e.defaultValue,h=e.values,f=e.groupId,b=e.className,g=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=h?h:g.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),k=(0,l.l)(y,(function(e,t){return e.value===t.value}));if(k.length>0)throw new Error('Docusaurus error: Duplicate values "'+k.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===m?m:null!=(t=null!=m?m:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:g[0].props.value;if(null!==v&&!y.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+y.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var S=(0,c.U)(),N=S.tabGroupChoices,w=S.setTabGroupChoices,j=(0,a.useState)(v),C=j[0],R=j[1],x=[],P=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var T=N[f];null!=T&&T!==C&&y.some((function(e){return e.value===T}))&&R(T)}var I=function(e){var t=e.currentTarget,n=x.indexOf(t),r=y[n].value;r!==C&&(P(t),R(r),null!=f&&w(f,String(r)))},L=function(e){var t,n=null;switch(e.key){case"ArrowRight":var r,a=x.indexOf(e.currentTarget)+1;n=null!=(r=x[a])?r:x[0];break;case"ArrowLeft":var i,o=x.indexOf(e.currentTarget)-1;n=null!=(i=x[o])?i:x[x.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,i.Z)("tabs-container",u)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":p},b)},y.map((function(e){var t=e.value,n=e.label,o=e.attributes;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return x.push(e)},onKeyDown:L,onFocus:I,onClick:I},o,{className:(0,i.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),o?(0,a.cloneElement)(g.filter((function(e){return e.props.value===C}))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},g.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function m(e){var t=(0,o.Z)();return a.createElement(p,(0,r.Z)({key:String(t)},e))}},2915:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return m}});var r=n(2685),a=n(1244),i=(n(7378),n(5318)),o=n(3411),l=n(2453),c=["components"],s={id:"combineSlices",title:"combineSlices",sidebar_label:"combineSlices",hide_title:!0},u=void 0,d={unversionedId:"api/combineSlices",id:"api/combineSlices",title:"combineSlices",description:"&nbsp;",source:"@site/../docs/api/combineSlices.mdx",sourceDirName:"api",slug:"/api/combineSlices",permalink:"/api/combineSlices",draft:!1,tags:[],version:"current",lastUpdatedAt:1716194519,formattedLastUpdatedAt:"May 20, 2024",frontMatter:{id:"combineSlices",title:"combineSlices",sidebar_label:"combineSlices",hide_title:!0},sidebar:"docs",previous:{title:"createEntityAdapter",permalink:"/api/createEntityAdapter"},next:{title:"createSelector",permalink:"/api/createSelector"}},p={},m=[{value:"Overview",id:"overview",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"<code>withLazyLoadedSlices</code>",id:"withlazyloadedslices",level:3},{value:"<code>inject</code>",id:"inject",level:3},{value:"Reducer replacement",id:"reducer-replacement",level:4},{value:"<code>selector</code>",id:"selector",level:3},{value:"Nested combined reducer",id:"nested-combined-reducer",level:4},{value:"<code>original</code>",id:"original",level:4},{value:"Slice integration",id:"slice-integration",level:2},{value:"<code>injectInto</code>",id:"injectinto",level:3},{value:"<code>selectors</code> / <code>getSelectors</code>",id:"selectors--getselectors",level:3}],h={toc:m};function f(e){var t=e.components,n=(0,a.Z)(e,c);return(0,i.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"combineslices"},(0,i.kt)("inlineCode",{parentName:"h1"},"combineSlices")),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"A function that combines slices into a single reducer, and enables injection of more reducers after initialisation."),(0,i.kt)(l.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// file: slices/index.js\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { api } from './api'\nimport { userSlice } from './users'\n\nexport const rootReducer = combineSlices(api, userSlice)\n\n\n// file: store.js\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './slices'\n\nexport const store = configureStore({\n  reducer: rootReducer,\n})\n")))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'A "slice" for ',(0,i.kt)("inlineCode",{parentName:"p"},"combineSlices")," is typically created with ",(0,i.kt)("a",{parentName:"p",href:"/api/createSlice"},(0,i.kt)("inlineCode",{parentName:"a"},"createSlice")),',\nbut can be any "slice-like" object with ',(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reducer")," properties (meaning RTK Query ",(0,i.kt)("a",{parentName:"p",href:"/rtk-query/api/created-api/overview"},"API instances")," are also compatible)."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const withUserReducer = rootReducer.inject({\n  reducerPath: 'user',\n  reducer: userReducer,\n})\n\nconst withApiReducer = rootReducer.inject(fooApi)\n")),(0,i.kt)("p",{parentName:"admonition"},"For simplicity, this ",(0,i.kt)("inlineCode",{parentName:"p"},"{ reducerPath, reducer }"),' shape will be described in these docs as a "slice".')),(0,i.kt)("h2",{id:"parameters"},"Parameters"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"combineSlices")," accepts a set of slices and/or reducer map objects, and combines them into a single reducer."),(0,i.kt)("p",null,"Slices will be mounted at their ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath"),", and items from reducer map objects will be mounted under their respective key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const rootReducer = combineSlices(counterSlice, baseApi, {\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n// is like\nconst rootReducer = combineReducers({\n  [counterSlice.reducerPath]: counterSlice.reducer,\n  [baseApi.reducerPath]: baseApi.reducer,\n  user: userSlice.reducer,\n  auth: authSlice.reducer,\n})\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"If multiple slices/map objects have the same reducer path, the reducer provided later in the arguments will override the previous."),(0,i.kt)("p",{parentName:"admonition"},"However, typing will not be able to account for this. It's best to ensure that all of your reducers will aim for a unique location.")),(0,i.kt)("h2",{id:"return-value"},"Return Value"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"combineSlices")," returns a reducer function, with attached methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"interface CombinedSliceReducer<InitialState, DeclaredState = InitialState>\n  extends Reducer<DeclaredState, AnyAction, Partial<DeclaredState>> {\n  withLazyLoadedSlices<LazyLoadedSlices>(): CombinedSliceReducer<\n    InitialState,\n    DeclaredState & Partial<LazyLoadedSlices>\n  >\n  inject<Slice extends SliceLike>(\n    slice: Slice,\n    config?: InjectConfig\n  ): CombinedSliceReducer<InitialState, DeclaredState & WithSlice<Slice>>\n  selector: {\n    (selectorFn: Selector, selectState?: SelectFromRootState) => WrappedSelector\n    original(state: DeclaredState) => InitialState & Partial<DeclaredState>\n  }\n}\n")),(0,i.kt)("h3",{id:"withlazyloadedslices"},(0,i.kt)("inlineCode",{parentName:"h3"},"withLazyLoadedSlices")),(0,i.kt)("p",null,"It's recommended to ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types"},"infer your RootState type from your store"),", which is inferred from the reducer. However, this can present issues if slices are lazy loaded, and thus not able to be inferred from."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"withLazyLoadedSlices")," allows you to declare slices that will be added to state later, which will be included in the final state type."),(0,i.kt)("p",null,"One possible pattern of managing this would be with declaration merging:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="Using declaration merging to declare injected slices"',"no-transpile":!0,title:'"Using',declaration:!0,merging:!0,to:!0,declare:!0,injected:!0,'slices"':!0},"// file: slices/index.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './static'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// keys in LazyLoadedSlices are marked as optional\nexport type RootState = ReturnType<typeof rootReducer>\n\n// file: slices/lazySlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof lazySlice> {}\n}\n\nconst injectedReducer = rootReducer.inject(lazySlice)\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer)\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The above example uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"WithSlice")," utility type for a slice mounted under its ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath"),". If the slice is mounted under a different key, you can declare it as a regular key instead."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="Declaring a slice mounted outside its reducerPath"',"no-transpile":!0,title:'"Declaring',a:!0,slice:!0,mounted:!0,outside:!0,its:!0,'reducerPath"':!0},"// file: slices/lazySlice.ts\nimport { rootReducer } from '.'\n\nconst lazySlice = createSlice({\n  /* ... */\n})\n\ndeclare module '.' {\n  export interface LazyLoadedSlices {\n    customKey: LazyState\n  }\n}\n\nconst injectedReducer = rootReducer.inject({\n  reducerPath: 'customKey',\n  reducer: lazySlice.reducer,\n})\n\n// and/or\n\nconst injectedSlice = lazySlice.injectInto(rootReducer, {\n  reducerPath: 'customKey',\n})\n"))),(0,i.kt)("h3",{id:"inject"},(0,i.kt)("inlineCode",{parentName:"h3"},"inject")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"inject")," allows you to add a slice to your set of reducers after initialisation.\nIt expects to be passed a slice and an optional config, and returns an updated version of the reducer with the slice included."),(0,i.kt)("p",null,"This is mainly useful for lazy loading reducers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const reducerWithUser = rootReducer.inject(userSlice)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"inject")," adds the slice to the map of reducers in your original reducer, but doesn't dispatch an action."),(0,i.kt)("p",{parentName:"admonition"},"This means that the added reducer state will not show up in your store until the next action is dispatched.")),(0,i.kt)("h4",{id:"reducer-replacement"},"Reducer replacement"),(0,i.kt)("p",null,"By default, replacing a reducer is not allowed.\nIn development mode, a warning will be logged to console if a new reducer instance is attempted to inject into a ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath")," that's already injected. (It won't warn if the same reducer instance is injected into the same place twice.)"),(0,i.kt)("p",null,"If you wish to allow replacing a reducer with a new instance, you must explicitly pass ",(0,i.kt)("inlineCode",{parentName:"p"},"overrideExisting: true")," as part of your configuration object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const reducerWithUser = rootReducer.inject(userSlice, {\n  overrideExisting: true,\n})\n")),(0,i.kt)("p",null,'This may be useful for hot reload, or "removing" a reducer by replacing it with a function that always returns ',(0,i.kt)("inlineCode",{parentName:"p"},"null"),".\nNote that for predictable behaviour, your types should account for all of the possible reducers you intend to occupy a path."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile title=\"'Removing' a reducer, by replacing it with a no-op function\"","no-transpile":!0,title:"\"'Removing'",a:!0,"reducer,":!0,by:!0,replacing:!0,it:!0,with:!0,"no-op":!0,'function"':!0},"declare module '.' {\n  export interface LazyLoadedSlices {\n    removable: RemovableState | null\n  }\n}\n\nconst withInjected = rootReducer.inject(\n  { reducerPath: 'removable', reducer: removableReducer },\n  { overrideExisting: true },\n)\n\nconst emptyReducer = () => null\n\nconst removeReducer = () =>\n  rootReducer.inject(\n    { reducerPath: 'removable', reducer: emptyReducer },\n    { overrideExisting: true },\n  )\n")),(0,i.kt)("h3",{id:"selector"},(0,i.kt)("inlineCode",{parentName:"h3"},"selector")),(0,i.kt)("p",null,"As noted previously, an injected reducer can still be undefined in state if no action has been dispatched."),(0,i.kt)("p",null,"Dealing with this possibly-optional state can be inconvient when writing selectors, as you may end up with a lot of results being possibly undefined or relying on explicit defaults."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"selector")," allows you to get around this, by wrapping the reducer state in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Proxy")," that ensures that any currently injected reducers evaluate to their initial state if they're currently ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," in state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"declare module '.' {\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    /* ... */\n  },\n})\n\nconst withCounter = rootReducer.inject(counterSlice)\n\nconst selectCounterValue = (rootState: RootState) => rootState.counter?.value // number | undefined\n\nconst wrappedSelectCounterValue = withCounter.selector(\n  (rootState) => rootState.counter.value, // number\n)\n\nconsole.log(\n  selectCounterValue({}), // undefined\n  selectCounterValue({ counter: { value: 2 } }), // 2\n  wrappedSelectCounterValue({}), // 0\n  wrappedSelectCounterValue({ counter: { value: 2 } }), // 2\n)\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Proxy")," retrieves a reducer's initial state by calling it with a randomly generated action type - don't try to handle this as a special case inside your reducer.")),(0,i.kt)("h4",{id:"nested-combined-reducer"},"Nested combined reducer"),(0,i.kt)("p",null,"The wrapped selector expects to use the state returned by the combined reducer as its first argument."),(0,i.kt)("p",null,"If the combined reducer is nested further inside the store state, pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"selectState")," callback as the second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"selector"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"interface RootState {\n  innerCombined: ReturnType<typeof combinedReducer>\n}\n\nconst selectCounterValue = withCounter.selector(\n  (combinedState) => combinedState.counter.value,\n  (rootState: RootState) => rootState.innerCombined,\n)\n\nconsole.log(\n  selectCounterValue({\n    innerCombined: {},\n  }), // 0\n  selectCounterValue({\n    innerCombined: {\n      counter: {\n        value: 2,\n      },\n    },\n  }), // 2\n)\n")),(0,i.kt)("h4",{id:"original"},(0,i.kt)("inlineCode",{parentName:"h4"},"original")),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("a",{parentName:"p",href:"/usage/immer-reducers#debugging-and-inspecting-drafted-state"},"Immer usage"),", an ",(0,i.kt)("inlineCode",{parentName:"p"},"original")," function is provided to retrieve the original state value provided to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proxy"),"."),(0,i.kt)("p",null,"This is mainly useful for debugging/inspecting, as ",(0,i.kt)("inlineCode",{parentName:"p"},"Proxy")," instances tend to be displayed in a format that's hard to read."),(0,i.kt)("p",null,"The function is attached as a method on the ",(0,i.kt)("inlineCode",{parentName:"p"},"selector")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const wrappedSelectCounterValue = withCounter.selector((rootState) => {\n  console.log(withCounter.selector.original(rootState))\n  return rootState.counter.value\n})\n")),(0,i.kt)("h2",{id:"slice-integration"},"Slice integration"),(0,i.kt)("h3",{id:"injectinto"},(0,i.kt)("inlineCode",{parentName:"h3"},"injectInto")),(0,i.kt)("p",null,"Slice instances returned by ",(0,i.kt)("a",{parentName:"p",href:"./createSlice"},(0,i.kt)("inlineCode",{parentName:"a"},"createSlice"))," have an attached ",(0,i.kt)("inlineCode",{parentName:"p"},"injectInto")," method, which receive an injectable reducer from ",(0,i.kt)("inlineCode",{parentName:"p"},"combineSlices"),' and returns an "injected" version of that slice.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const injectedCounterSlice = counterSlice.injectInto(rootReducer)\n")),(0,i.kt)("p",null,"An optional configuration object can be passed. This follows ",(0,i.kt)("a",{parentName:"p",href:"#inject"},(0,i.kt)("inlineCode",{parentName:"a"},"inject")),"'s options with an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath")," field, for injecting the slice under a path other than its current ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath")," property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const aCounterSlice = counterSlice.injectInto(rootReducer, {\n  reducerPath: 'aCounter',\n})\n")),(0,i.kt)("h3",{id:"selectors--getselectors"},(0,i.kt)("inlineCode",{parentName:"h3"},"selectors")," / ",(0,i.kt)("inlineCode",{parentName:"h3"},"getSelectors")),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("a",{parentName:"p",href:"#selector"},(0,i.kt)("inlineCode",{parentName:"a"},"selector")),', the selectors from an "injected" slice instance behave slightly differently.'),(0,i.kt)("p",null,"If the slice state is undefined in the store state passed, the selector will instead be called with the slice's initial state."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"selectors")," will also reflect the change in ",(0,i.kt)("inlineCode",{parentName:"p"},"reducerPath")," if one was made during injection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"console.log(\n  injectedCounterSlice.selectors.selectValue({}), // 0\n  injectedCounterSlice.selectors.selectValue({ counter: { value: 2 } }), // 2\n  aCounterSlice.selectors.selectValue({ aCounter: { value: 2 } }), // 2\n)\n")))}f.isMDXComponent=!0},5318:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(n),m=a,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||i;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);