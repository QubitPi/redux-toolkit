"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5317],{3411:function(e,t,n){n.d(t,{Z:function(){return i}});var o=n(7378),a=n(7140),r="tabItem_wHwb";function i(e){var t=e.children,n=e.hidden,i=e.className;return o.createElement("div",{role:"tabpanel",className:(0,a.Z)(r,i),hidden:n},t)}},2453:function(e,t,n){n.d(t,{Z:function(){return m}});var o=n(2685),a=n(7378),r=n(7140),i=n(362),s=n(56),l=n(5720),d=n(9169),c="tabList_J5MA",p="tabItem_l0OV";function u(e){var t,n,i=e.lazy,u=e.block,m=e.defaultValue,h=e.values,g=e.groupId,f=e.className,k=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=h?h:k.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),T=(0,s.l)(y,(function(e,t){return e.value===t.value}));if(T.length>0)throw new Error('Docusaurus error: Duplicate values "'+T.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var w=null===m?m:null!=(t=null!=m?m:null==(n=k.find((function(e){return e.props.default})))?void 0:n.props.value)?t:k[0].props.value;if(null!==w&&!y.some((function(e){return e.value===w})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+y.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var x=(0,l.U)(),N=x.tabGroupChoices,S=x.setTabGroupChoices,v=(0,a.useState)(w),R=v[0],b=v[1],C=[],D=(0,d.o5)().blockElementScrollPositionUntilNextRender;if(null!=g){var A=N[g];null!=A&&A!==R&&y.some((function(e){return e.value===A}))&&b(A)}var E=function(e){var t=e.currentTarget,n=C.indexOf(t),o=y[n].value;o!==R&&(D(t),b(o),null!=g&&S(g,String(o)))},O=function(e){var t,n=null;switch(e.key){case"ArrowRight":var o,a=C.indexOf(e.currentTarget)+1;n=null!=(o=C[a])?o:C[0];break;case"ArrowLeft":var r,i=C.indexOf(e.currentTarget)-1;n=null!=(r=C[i])?r:C[C.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,r.Z)("tabs-container",c)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":u},f)},y.map((function(e){var t=e.value,n=e.label,i=e.attributes;return a.createElement("li",(0,o.Z)({role:"tab",tabIndex:R===t?0:-1,"aria-selected":R===t,key:t,ref:function(e){return C.push(e)},onKeyDown:O,onFocus:E,onClick:E},i,{className:(0,r.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":R===t})}),null!=n?n:t)}))),i?(0,a.cloneElement)(k.filter((function(e){return e.props.value===R}))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},k.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==R})}))))}function m(e){var t=(0,i.Z)();return a.createElement(u,(0,o.Z)({key:String(t)},e))}},2657:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return g},frontMatter:function(){return d},metadata:function(){return p},toc:function(){return m}});var o=n(2685),a=n(1244),r=n(7378),i=n(5318),s=(n(3411),n(2453),function(e){var t=e.children,n=e.title,o=void 0===n?"Detailed Explanation":n;return r.createElement("details",{className:"detailed-explanation"},r.createElement("summary",null,r.createElement("h4",null,o)),t)}),l=["components"],d={id:"migrating-to-modern-redux",title:"Migrating to Modern Redux",description:"Usage > Setup > Migrating to Modern Redux: how to modernize legacy Redux code"},c=void 0,p={unversionedId:"usage/migrating-to-modern-redux",id:"usage/migrating-to-modern-redux",title:"Migrating to Modern Redux",description:"Usage > Setup > Migrating to Modern Redux: how to modernize legacy Redux code",source:"@site/../docs/usage/migrating-to-modern-redux.mdx",sourceDirName:"usage",slug:"/usage/migrating-to-modern-redux",permalink:"/usage/migrating-to-modern-redux",draft:!1,tags:[],version:"current",lastUpdatedAt:1716194519,formattedLastUpdatedAt:"May 20, 2024",frontMatter:{id:"migrating-to-modern-redux",title:"Migrating to Modern Redux",description:"Usage > Setup > Migrating to Modern Redux: how to modernize legacy Redux code"},sidebar:"docs",previous:{title:"RTK Query Quick Start",permalink:"/tutorials/rtk-query"},next:{title:"Migrating to RTK 2.0 and Redux 5.0",permalink:"/usage/migrating-rtk-2"}},u={},m=[{value:"Overview",id:"overview",level:2},{value:"Modernizing Redux Logic with Redux Toolkit",id:"modernizing-redux-logic-with-redux-toolkit",level:2},{value:"Store Setup with <code>configureStore</code>",id:"store-setup-with-configurestore",level:3},{value:"Reducers and Actions with <code>createSlice</code>",id:"reducers-and-actions-with-createslice",level:3},{value:"Data Fetching with RTK Query",id:"data-fetching-with-rtk-query",level:3},{value:"Data Fetching with <code>createAsyncThunk</code>",id:"data-fetching-with-createasyncthunk",level:3},{value:"Reactive Logic with <code>createListenerMiddleware</code>",id:"reactive-logic-with-createlistenermiddleware",level:3},{value:"Migrating TypeScript for Redux Logic",id:"migrating-typescript-for-redux-logic",level:3},{value:"Modernizing React Components with React-Redux",id:"modernizing-react-components-with-react-redux",level:2},{value:"Migrating <code>connect</code> to Hooks",id:"migrating-connect-to-hooks",level:3},{value:"Migrating TypeScript for Components",id:"migrating-typescript-for-components",level:3},{value:"Further Information",id:"further-information",level:2}],h={toc:m};function g(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"What You'll Learn",type:"tip"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},'How to modernize legacy "hand-written" Redux logic to use Redux Toolkit'),(0,i.kt)("li",{parentName:"ul"},"How to modernize legacy React-Redux ",(0,i.kt)("inlineCode",{parentName:"li"},"connect")," components to use the hooks API"),(0,i.kt)("li",{parentName:"ul"},"How to modernize Redux logic and React-Redux components that use TypeScript"))),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Redux has been around since 2015, and our recommended patterns for writing Redux code have changed significantly over the years. In the same way that React has evolved from ",(0,i.kt)("inlineCode",{parentName:"p"},"createClass")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"React.Component")," to function components with hooks, Redux has evolved from manual store setup + hand-written reducers with object spreads + React-Redux's ",(0,i.kt)("inlineCode",{parentName:"p"},"connect"),", to Redux Toolkit's ",(0,i.kt)("inlineCode",{parentName:"p"},"configureStore")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"createSlice")," + React-Redux's hooks API."),(0,i.kt)("p",null,'Many users are working on older Redux codebases that have been around since before these "modern Redux" patterns existed. Migrating those codebases to today\'s recommended modern Redux patterns will result in codebases that are much smaller and easier to maintain.'),(0,i.kt)("p",null,"The good news is that ",(0,i.kt)("strong",{parentName:"p"},"you can migrate your code to modern Redux incrementally, piece by piece, with old and new Redux code coexisting and working together!")),(0,i.kt)("p",null,"This page covers the general approaches and techniques you can use to modernize an existing legacy Redux codebase."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},'For more details on how "modern Redux" with Redux Toolkit + React-Redux hooks simplifies using Redux, see these additional resources:'),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/introduction/why-rtk-is-redux-today"},"Why Redux Toolkit is How to use Redux Today")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/tutorials/essentials/part-2-app-structure"},"Redux Essentials: Redux Toolkit App Structure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/tutorials/fundamentals/part-8-modern-redux"},"Redux Fundamentals: Modern Redux with Redux Toolkit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2022/06/presentations-modern-redux-rtk/"},"Presentation: Modern Redux with Redux Toolkit")))),(0,i.kt)("h2",{id:"modernizing-redux-logic-with-redux-toolkit"},"Modernizing Redux Logic with Redux Toolkit"),(0,i.kt)("p",null,"The general approach to migrating Redux logic is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace the existing manual Redux store setup with Redux Toolkit's ",(0,i.kt)("inlineCode",{parentName:"li"},"configureStore")),(0,i.kt)("li",{parentName:"ul"},"Pick an existing slice reducer and its associated actions. Replace those with RTK's ",(0,i.kt)("inlineCode",{parentName:"li"},"createSlice"),". Repeat for one reducer at a time."),(0,i.kt)("li",{parentName:"ul"},"As needed, replace existing data fetching logic with RTK Query or ",(0,i.kt)("inlineCode",{parentName:"li"},"createAsyncThunk")),(0,i.kt)("li",{parentName:"ul"},"Use RTK's other APIs like ",(0,i.kt)("inlineCode",{parentName:"li"},"createListenerMiddleware")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"createEntityAdapter")," as needed")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"You should always start by replacing the legacy ",(0,i.kt)("inlineCode",{parentName:"strong"},"createStore")," call with ",(0,i.kt)("inlineCode",{parentName:"strong"},"configureStore")),". This is a one-time step, and all of the existing reducers and middleware will continue to work as-is. ",(0,i.kt)("inlineCode",{parentName:"p"},"configureStore")," includes development-mode checks for common mistakes like accidental mutations and non-serializable values, so having those in place will help identify any areas of the codebase where those mistakes are happening."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You can see this general approach in action in ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/tutorials/fundamentals/part-8-modern-redux"},(0,i.kt)("strong",{parentName:"a"},"Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit")),".")),(0,i.kt)("h3",{id:"store-setup-with-configurestore"},"Store Setup with ",(0,i.kt)("inlineCode",{parentName:"h3"},"configureStore")),(0,i.kt)("p",null,"A typical legacy Redux store setup file does several different steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Combining the slice reducers into the root reducer"),(0,i.kt)("li",{parentName:"ul"},"Creating the middleware enhancer, usually with the thunk middleware, and possibly other middleware in development mode such as ",(0,i.kt)("inlineCode",{parentName:"li"},"redux-logger")),(0,i.kt)("li",{parentName:"ul"},"Adding the Redux DevTools enhancer, and composing the enhancers together"),(0,i.kt)("li",{parentName:"ul"},"Calling ",(0,i.kt)("inlineCode",{parentName:"li"},"createStore"))),(0,i.kt)("p",null,"Here's what those steps might look like in an existing application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/app/store.js"',title:'"src/app/store.js"'},"import { createStore, applyMiddleware, combineReducers, compose } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport postsReducer from '../reducers/postsReducer'\nimport usersReducer from '../reducers/usersReducer'\n\nconst rootReducer = combineReducers({\n  posts: postsReducer,\n  users: usersReducer,\n})\n\nconst middlewareEnhancer = applyMiddleware(thunk)\n\nconst composeWithDevTools =\n  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\n\nconst composedEnhancers = composeWithDevTools(middlewareEnhancer)\n\nconst store = createStore(rootReducer, composedEnhancers)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"All")," of those steps can be replaced with a single call to Redux Toolkit's ",(0,i.kt)("inlineCode",{parentName:"strong"},"configureStore")," API"),"."),(0,i.kt)("p",null,"RTK's ",(0,i.kt)("inlineCode",{parentName:"p"},"configureStore")," wraps around the original ",(0,i.kt)("inlineCode",{parentName:"p"},"createStore")," method, and handles most of the store setup for us automatically. In fact, we can cut it down to effectively one step:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Basic Store Setup: src/app/store.js"',title:'"Basic',Store:!0,"Setup:":!0,'src/app/store.js"':!0},"import { configureStore } from '@reduxjs/toolkit'\n\nimport postsReducer from '../reducers/postsReducer'\nimport usersReducer from '../reducers/usersReducer'\n\n// highlight-start\n// Automatically adds the thunk middleware and the Redux DevTools extension\nconst store = configureStore({\n  // Automatically calls `combineReducers`\n  reducer: {\n    posts: postsReducer,\n    users: usersReducer,\n  },\n})\n// highlight-end\n")),(0,i.kt)("p",null,"That one call to ",(0,i.kt)("inlineCode",{parentName:"p"},"configureStore")," did all the work for us:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It called ",(0,i.kt)("inlineCode",{parentName:"li"},"combineReducers")," to combine ",(0,i.kt)("inlineCode",{parentName:"li"},"postsReducer")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"usersReducer")," into the root reducer function, which will handle a root state that looks like ",(0,i.kt)("inlineCode",{parentName:"li"},"{posts, users}")),(0,i.kt)("li",{parentName:"ul"},"It called ",(0,i.kt)("inlineCode",{parentName:"li"},"createStore")," to create a Redux store using that root reducer"),(0,i.kt)("li",{parentName:"ul"},"It automatically added the thunk middleware and called ",(0,i.kt)("inlineCode",{parentName:"li"},"applyMiddleware")),(0,i.kt)("li",{parentName:"ul"},"It automatically added more middleware to check for common mistakes like accidentally mutating the state"),(0,i.kt)("li",{parentName:"ul"},"It automatically set up the Redux DevTools Extension connection")),(0,i.kt)("p",null,"If your store setup requires additional steps, such as adding additional middleware, passing in an ",(0,i.kt)("inlineCode",{parentName:"p"},"extra")," argument to the thunk middleware, or creating a persisted root reducer, you can do that as well. Here's a larger example that shows customizing the built-in middleware and turning on Redux-Persist, which demonstrates some of the options for working with ",(0,i.kt)("inlineCode",{parentName:"p"},"configureStore"),":"),(0,i.kt)(s,{title:"Detailed Example: Custom Store Setup with Persistence and Middleware",mdxType:"DetailedExplanation"},(0,i.kt)("p",null,"This example shows several possible common tasks when setting up a Redux store:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Combining the reducers separately (sometimes needed due to other architectural constraints)"),(0,i.kt)("li",{parentName:"ul"},"Adding additional middleware, both conditionally and unconditionally"),(0,i.kt)("li",{parentName:"ul"},'Passing an "extra argument" into the thunk middleware, such as an API service layer'),(0,i.kt)("li",{parentName:"ul"},"Using the Redux-Persist library, which requires special handling for its non-serializable action types"),(0,i.kt)("li",{parentName:"ul"},"Turning the devtools off in prod, and setting additional devtools options in development")),(0,i.kt)("p",null,"None of these are ",(0,i.kt)("em",{parentName:"p"},"required"),", but they do show up frequently in real-world codebases."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Custom Store Setup: src/app/store.js"',title:'"Custom',Store:!0,"Setup:":!0,'src/app/store.js"':!0},"import { configureStore, combineReducers } from '@reduxjs/toolkit'\nimport {\n  persistStore,\n  persistReducer,\n  FLUSH,\n  REHYDRATE,\n  PAUSE,\n  PERSIST,\n  PURGE,\n  REGISTER,\n} from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nimport { PersistGate } from 'redux-persist/integration/react'\nimport logger from 'redux-logger'\n\nimport postsReducer from '../features/posts/postsSlice'\nimport usersReducer from '../features/users/usersSlice'\nimport { api } from '../features/api/apiSlice'\nimport { serviceLayer } from '../features/api/serviceLayer'\n\nimport stateSanitizerForDevtools from './devtools'\nimport customMiddleware from './someCustomMiddleware'\n\n// Can call `combineReducers` yourself if needed\nconst rootReducer = combineReducers({\n  posts: postsReducer,\n  users: usersReducer,\n  [api.reducerPath]: api.reducer,\n})\n\nconst persistConfig = {\n  key: 'root',\n  version: 1,\n  storage,\n}\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer)\n\nconst store = configureStore({\n  // Can create a root reducer separately and pass that in\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) => {\n    const middleware = getDefaultMiddleware({\n      // Pass in a custom `extra` argument to the thunk middleware\n      thunk: {\n        extraArgument: { serviceLayer },\n      },\n      // Customize the built-in serializability dev check\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }).concat(customMiddleware, api.middleware)\n\n    // Conditionally add another middleware in dev\n    if (process.env.NODE_ENV !== 'production') {\n      middleware.push(logger)\n    }\n\n    return middleware\n  },\n  // Turn off devtools in prod, or pass options in dev\n  devTools:\n    process.env.NODE_ENV === 'production'\n      ? false\n      : {\n          stateSanitizer: stateSanitizerForDevtools,\n        },\n})\n"))),(0,i.kt)("h3",{id:"reducers-and-actions-with-createslice"},"Reducers and Actions with ",(0,i.kt)("inlineCode",{parentName:"h3"},"createSlice")),(0,i.kt)("p",null,"A typical legacy Redux codebase has its reducer logic, action creators, and action types spread across separate files, and those files are often in separate folders by type. The reducer logic is written using ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statements and hand-written immutable update logic with object spreads and array mapping:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/constants/todos.js"',title:'"src/constants/todos.js"'},"export const ADD_TODO = 'ADD_TODO'\nexport const TOGGLE_TODO = 'TOGGLE_TODO'\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/actions/todos.js"',title:'"src/actions/todos.js"'},"import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'\n\nexport const addTodo = (id, text) => ({\n  type: ADD_TODO,\n  text,\n  id,\n})\n\nexport const toggleTodo = (id) => ({\n  type: TOGGLE_TODO,\n  id,\n})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/reducers/todos.js"',title:'"src/reducers/todos.js"'},"import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'\n\nconst initialState = []\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    case ADD_TODO: {\n      return state.concat({\n        id: action.id,\n        text: action.text,\n        completed: false,\n      })\n    }\n    case TOGGLE_TODO: {\n      return state.map((todo) => {\n        if (todo.id !== action.id) {\n          return todo\n        }\n\n        return {\n          ...todo,\n          completed: !todo.completed,\n        }\n      })\n    }\n    default:\n      return state\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Redux Toolkit's ",(0,i.kt)("inlineCode",{parentName:"strong"},"createSlice"),' API was designed to eliminate all the "boilerplate" with writing reducers, actions, and immutable updates!')),(0,i.kt)("p",null,"With Redux Toolkit, there's multiple changes to that legacy code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"createSlice")," will eliminate the hand-written action creators and action types entirely"),(0,i.kt)("li",{parentName:"ul"},"All of the uniquely-named fields like ",(0,i.kt)("inlineCode",{parentName:"li"},"action.text")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"action.id")," get replaced by ",(0,i.kt)("inlineCode",{parentName:"li"},"action.payload"),", either as an individual value or an object containing those fields"),(0,i.kt)("li",{parentName:"ul"},'The hand-written immutable updates are replaced by "mutating" logic in reducers thanks to Immer'),(0,i.kt)("li",{parentName:"ul"},"There's no need for separate files for each type of code"),(0,i.kt)("li",{parentName:"ul"},"We teach having ",(0,i.kt)("em",{parentName:"li"},"all"),' logic for a given reducer in a single "slice" file'),(0,i.kt)("li",{parentName:"ul"},'Instead of having separate folders by "type of code", we recommend organizing files by "features", with related code living in the same folder'),(0,i.kt)("li",{parentName:"ul"},'Ideally, the naming of the reducers and actions should use the past tense and describe "a thing that happened", rather than an imperative "do this thing now", such as ',(0,i.kt)("inlineCode",{parentName:"li"},"todoAdded")," instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"ADD_TODO"))),(0,i.kt)("p",null,'Those separate files for constants, actions, and reducers, would all be replaced by a single "slice" file. The modernized slice file would look like this:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},'import { createSlice } from \'@reduxjs/toolkit\'\n\nconst initialState = []\n\nconst todosSlice = createSlice({\n  name: \'todos\',\n  initialState,\n  reducers: {\n    // highlight-start\n    // Give case reducers meaningful past-tense "event"-style names\n    todoAdded(state, action) {\n      const { id, text } = action.payload\n      // "Mutating" update syntax thanks to Immer, and no `return` needed\n      state.todos.push({\n        id,\n        text,\n        completed: false,\n      })\n    },\n    // highlight-end\n    todoToggled(state, action) {\n      // Look for the specific nested object to update.\n      // In this case, `action.payload` is the default field in the action,\n      // and can hold the `id` value - no need for `action.id` separately\n      const matchingTodo = state.todos.find(\n        (todo) => todo.id === action.payload,\n      )\n\n      if (matchingTodo) {\n        // Can directly "mutate" the nested object\n        matchingTodo.completed = !matchingTodo.completed\n      }\n    },\n  },\n})\n\n// highlight-start\n// `createSlice` automatically generated action creators with these names.\n// export them as named exports from this "slice" file\nexport const { todoAdded, todoToggled } = todosSlice.actions\n//highlight-end\n\n// Export the slice reducer as the default export\nexport default todosSlice.reducer\n')),(0,i.kt)("p",null,"When you call ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch(todoAdded('Buy milk'))"),", whatever single value you pass to the ",(0,i.kt)("inlineCode",{parentName:"p"},"todoAdded")," action creator will automatically get used as the ",(0,i.kt)("inlineCode",{parentName:"p"},"action.payload")," field. If you need to pass in multiple values, do so as an object, like ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch(todoAdded({id, text}))"),". Alternately, you can use ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/tutorials/essentials/part-4-using-data#preparing-action-payloads"},'the "prepare" notation inside of a ',(0,i.kt)("inlineCode",{parentName:"a"},"createSlice")," reducer")," to accept multiple separate arguments and create the ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," field. The ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare")," notation is also useful for cases where the action creators were doing additional work, such as generating unique IDs for each item."),(0,i.kt)("p",null,"While Redux Toolkit does not specifically care about your folder and file structures or action naming, ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/style-guide/"},"these are the best practices we recommend")," because we've found they lead to more maintainable and understandable code."),(0,i.kt)("h3",{id:"data-fetching-with-rtk-query"},"Data Fetching with RTK Query"),(0,i.kt)("p",null,"Typical legacy data fetching in a React+Redux app requires many moving pieces and types of code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Action creators and action types that represent "request starting", "request succeeded", and "request failed" actions'),(0,i.kt)("li",{parentName:"ul"},"Thunks to dispatch the actions and make the async request"),(0,i.kt)("li",{parentName:"ul"},"Reducers that track loading status and store the cached data"),(0,i.kt)("li",{parentName:"ul"},"Selectors to read those values from the store"),(0,i.kt)("li",{parentName:"ul"},"Dispatching the thunk in a component after mounting, either via ",(0,i.kt)("inlineCode",{parentName:"li"},"componentDidMount")," in a class component or ",(0,i.kt)("inlineCode",{parentName:"li"},"useEffect")," in a function component")),(0,i.kt)("p",null,"These typically would be split across many different files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/constants/todos.js"',title:'"src/constants/todos.js"'},"export const FETCH_TODOS_STARTED = 'FETCH_TODOS_STARTED'\nexport const FETCH_TODOS_SUCCEEDED = 'FETCH_TODOS_SUCCEEDED'\nexport const FETCH_TODOS_FAILED = 'FETCH_TODOS_FAILED'\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/actions/todos.js"',title:'"src/actions/todos.js"'},"import axios from 'axios'\nimport {\n  FETCH_TODOS_STARTED,\n  FETCH_TODOS_SUCCEEDED,\n  FETCH_TODOS_FAILED,\n} from '../constants/todos'\n\nexport const fetchTodosStarted = () => ({\n  type: FETCH_TODOS_STARTED,\n})\n\nexport const fetchTodosSucceeded = (todos) => ({\n  type: FETCH_TODOS_SUCCEEDED,\n  todos,\n})\n\nexport const fetchTodosFailed = (error) => ({\n  type: FETCH_TODOS_FAILED,\n  error,\n})\n\nexport const fetchTodos = () => {\n  return async (dispatch) => {\n    dispatch(fetchTodosStarted())\n\n    try {\n      // Axios is common, but also `fetch`, or your own \"API service\" layer\n      const res = await axios.get('/todos')\n      dispatch(fetchTodosSucceeded(res.data))\n    } catch (err) {\n      dispatch(fetchTodosFailed(err))\n    }\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/reducers/todos.js"',title:'"src/reducers/todos.js"'},"import {\n  FETCH_TODOS_STARTED,\n  FETCH_TODOS_SUCCEEDED,\n  FETCH_TODOS_FAILED,\n} from '../constants/todos'\n\nconst initialState = {\n  status: 'uninitialized',\n  todos: [],\n  error: null,\n}\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    case FETCH_TODOS_STARTED: {\n      return {\n        ...state,\n        status: 'loading',\n      }\n    }\n    case FETCH_TODOS_SUCCEEDED: {\n      return {\n        ...state,\n        status: 'succeeded',\n        todos: action.todos,\n      }\n    }\n    case FETCH_TODOS_FAILED: {\n      return {\n        ...state,\n        status: 'failed',\n        todos: [],\n        error: action.error,\n      }\n    }\n    default:\n      return state\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/selectors/todos.js"',title:'"src/selectors/todos.js"'},"export const selectTodosStatus = (state) => state.todos.status\nexport const selectTodos = (state) => state.todos.todos\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/components/TodosList.js"',title:'"src/components/TodosList.js"'},"import { useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { fetchTodos } from '../actions/todos'\nimport { selectTodosStatus, selectTodos } from '../selectors/todos'\n\nexport function TodosList() {\n  const dispatch = useDispatch()\n  const status = useSelector(selectTodosStatus)\n  const todos = useSelector(selectTodos)\n\n  useEffect(() => {\n    dispatch(fetchTodos())\n  }, [dispatch])\n\n  // omit rendering logic here\n}\n")),(0,i.kt)("p",null,"Many users may be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"redux-saga")," library to manage data fetching, in which case they might have ",(0,i.kt)("em",{parentName:"p"},"additional"),' "signal" action types used to trigger the sagas, and this saga file instead of thunks:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/sagas/todos.js"',title:'"src/sagas/todos.js"'},"import { put, takeEvery, call } from 'redux-saga/effects'\nimport {\n  FETCH_TODOS_BEGIN,\n  fetchTodosStarted,\n  fetchTodosSucceeded,\n  fetchTodosFailed,\n} from '../actions/todos'\n\n// Saga to actually fetch data\nexport function* fetchTodos() {\n  yield put(fetchTodosStarted())\n\n  try {\n    const res = yield call(axios.get, '/todos')\n    yield put(fetchTodosSucceeded(res.data))\n  } catch (err) {\n    yield put(fetchTodosFailed(err))\n  }\n}\n\n// \"Watcher\" saga that waits for a \"signal\" action, which is\n// dispatched only to kick off logic, not to update state\nexport function* fetchTodosSaga() {\n  yield takeEvery(FETCH_TODOS_BEGIN, fetchTodos)\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"All")," of that code can be replaced with ",(0,i.kt)("a",{parentName:"strong",href:"https://redux-toolkit.js.org/rtk-query/overview"},'Redux Toolkit\'s "RTK Query" data fetching and caching layer'),"!")),(0,i.kt)("p",null,"RTK Query replaces the need to write ",(0,i.kt)("em",{parentName:"p"},"any")," actions, thunks, reducers, selectors, or effects to manage data fetching. (In fact, it actually ",(0,i.kt)("em",{parentName:"p"},"uses")," all those same tools internally.) Additionally, RTK Query takes care of tracking loading state, deduplicating requests, and managing cache data lifecycles (including removing expired data that is no longer needed)."),(0,i.kt)("p",null,"To migrate, ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/tutorials/essentials/part-7-rtk-query-basics"},'set up a single RTK Query "API slice" definition and add the generated reducer + middleware to your store'),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/api/apiSlice.js"',title:'"src/features/api/apiSlice.js"'},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({\n    // Fill in your own server starting URL here\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({}),\n})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/app/store.js"',title:'"src/app/store.js"'},"import { configureStore } from '@reduxjs/toolkit'\n\n// Import the API object\n// highlight-next-line\nimport { api } from '../features/api/apiSlice'\n// Import any other slice reducers as usual here\nimport usersReducer from '../features/users/usersSlice'\n\nexport const store = configureStore({\n  reducer: {\n    // Add the generated RTK Query \"API slice\" caching reducer\n    // highlight-next-line\n    [api.reducerPath]: api.reducer,\n    // Add any other reducers\n    users: usersReducer,\n  },\n  // Add the RTK Query API middleware\n  // highlight-start\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(api.middleware),\n  // highlight-end\n})\n")),(0,i.kt)("p",null,'Then, add "endpoints" that represents the specific data you want to fetch and cache, and export the auto-generated React hooks for each endpoint:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/api/apiSlice.js"',title:'"src/features/api/apiSlice.js"'},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({\n    // Fill in your own server starting URL here\n    baseUrl: '/',\n  }),\n  endpoints: (build) => ({\n    // highlight-start\n    // A query endpoint with no arguments\n    getTodos: build.query({\n      query: () => '/todos',\n    }),\n    // A query endpoint with an argument\n    userById: build.query({\n      query: (userId) => `/users/${userId}`,\n    }),\n    // highlight-end\n    // A mutation endpoint\n    updateTodo: build.mutation({\n      query: (updatedTodo) => ({\n        url: `/todos/${updatedTodo.id}`,\n        method: 'POST',\n        body: updatedTodo,\n      }),\n    }),\n  }),\n})\n\n// highlight-next-line\nexport const { useGetTodosQuery, useUserByIdQuery, useUpdateTodoMutation } = api\n")),(0,i.kt)("p",null,"Finally, use the hooks in your components:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/TodoList.js"',title:'"src/features/todos/TodoList.js"'},"// highlight-next-line\nimport { useGetTodosQuery } from '../api/apiSlice'\n\nexport function TodoList() {\n  // highlight-next-line\n  const { data: todos, isFetching, isSuccess } = useGetTodosQuery()\n\n  // omit rendering logic here\n}\n")),(0,i.kt)("h3",{id:"data-fetching-with-createasyncthunk"},"Data Fetching with ",(0,i.kt)("inlineCode",{parentName:"h3"},"createAsyncThunk")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"We ",(0,i.kt)("em",{parentName:"strong"},"specifically")," recommend using RTK Query for data fetching.")," However, some users have told us they aren't ready to make that step yet. In that case, you can at least cut down on some of the boilerplate of hand-written thunks and reducers using RTK's ",(0,i.kt)("inlineCode",{parentName:"p"},"createAsyncThunk"),". It automatically generates the action creators and action types for you, calls the async function you provide to make the request, and dispatches those actions based on the promise lifecycle. The same example with ",(0,i.kt)("inlineCode",{parentName:"p"},"createAsyncThunk")," might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice"',title:'"src/features/todos/todosSlice"'},"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport axios from 'axios'\n\nconst initialState = {\n  status: 'uninitialized',\n  todos: [],\n  error: null,\n}\n\nconst fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {\n  // Just make the async request here, and return the response.\n  // This will automatically dispatch a `pending` action first,\n  // and then `fulfilled` or `rejected` actions based on the promise.\n  // as needed based on the\n  const res = await axios.get('/todos')\n  return res.data\n})\n\nexport const todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    // any additional \"normal\" case reducers here.\n    // these will generate new action creators\n  },\n  extraReducers: (builder) => {\n    // Use `extraReducers` to handle actions that were generated\n    // _outside_ of the slice, such as thunks or in other slices\n    builder\n      .addCase(fetchTodos.pending, (state, action) => {\n        state.status = 'loading'\n      })\n      // Pass the generated action creators to `.addCase()`\n      .addCase(fetchTodos.fulfilled, (state, action) => {\n        // Same \"mutating\" update syntax thanks to Immer\n        state.status = 'succeeded'\n        state.todos = action.payload\n      })\n      .addCase(fetchTodos.rejected, (state, action) => {\n        state.status = 'failed'\n        state.todos = []\n        state.error = action.error\n      })\n  },\n})\n\nexport default todosSlice.reducer\n")),(0,i.kt)("p",null,"You'd also still need to write any selectors, and dispatch the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetchTodos")," thunk yourself in a ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," hook."),(0,i.kt)("h3",{id:"reactive-logic-with-createlistenermiddleware"},"Reactive Logic with ",(0,i.kt)("inlineCode",{parentName:"h3"},"createListenerMiddleware")),(0,i.kt)("p",null,'Many Redux apps have "reactive"-style logic that listens for specific actions or state changes, and runs additional logic in response. These behaviors are often implemented using the ',(0,i.kt)("inlineCode",{parentName:"p"},"redux-saga")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"redux-observable")," libraries."),(0,i.kt)("p",null,"These libraries are used for a wide variety of tasks. As a basic example, a saga and an epic that listen for an action, wait one second, and then dispatch an additional action might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/sagas/ping.js"',title:'"src/sagas/ping.js"'},"import { delay, put, takeEvery } from 'redux-saga/effects'\n\nexport function* ping() {\n  yield delay(1000)\n  yield put({ type: 'PONG' })\n}\n\n// \"Watcher\" saga that waits for a \"signal\" action, which is\n// dispatched only to kick off logic, not to update state\nexport function* pingSaga() {\n  yield takeEvery('PING', ping)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/epics/ping.js"',title:'"src/epics/ping.js"'},"import { filter, mapTo } from 'rxjs/operators'\nimport { ofType } from 'redux-observable'\n\nconst pingEpic = (action$) =>\n  action$.pipe(ofType('PING'), delay(1000), mapTo({ type: 'PONG' }))\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/app/store.js"',title:'"src/app/store.js"'},"import { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\nimport { combineEpics, createEpicMiddleware  } from 'redux-observable';\n\n// skip reducers\n\nimport { pingEpic } from '../sagas/ping'\nimport { pingSaga } from '../epics/ping\n\nfunction* rootSaga() {\n  yield pingSaga()\n}\n\nconst rootEpic = combineEpics(\n  pingEpic\n);\n\nconst sagaMiddleware = createSagaMiddleware()\nconst epicMiddleware = createEpicMiddleware()\n\nconst middlewareEnhancer = applyMiddleware(sagaMiddleware, epicMiddleware)\n\nconst store = createStore(rootReducer, middlewareEnhancer)\n\nsagaMiddleware.run(rootSaga)\nepicMiddleware.run(rootEpic)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'The RTK "listener" middleware is designed to replace sagas and observables, with a simpler API, smaller bundle size, and better TS support.')),(0,i.kt)("p",null,"The saga and epic examples could be replaced with the listener middleware, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/app/listenerMiddleware.js"',title:'"src/app/listenerMiddleware.js"'},"import { createListenerMiddleware } from '@reduxjs/toolkit'\n\n// Best to define this in a separate file, to avoid importing\n// from the store file into the rest of the codebase\nexport const listenerMiddleware = createListenerMiddleware()\n\nexport const { startListening, stopListening } = listenerMiddleware\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/ping/pingSlice.js"',title:'"src/features/ping/pingSlice.js"'},"import { createSlice } from '@reduxjs/toolkit'\nimport { startListening } from '../../app/listenerMiddleware'\n\nconst pingSlice = createSlice({\n  name: 'ping',\n  initialState,\n  reducers: {\n    pong(state, action) {\n      // state update here\n    },\n  },\n})\n\nexport const { pong } = pingSlice.actions\nexport default pingSlice.reducer\n\n// highlight-start\n// The `startListening()` call could go in different files,\n// depending on your preferred app setup. Here, we just add\n// it directly in a slice file.\nstartListening({\n  // Match this exact action type based on the action creator\n  actionCreator: pong,\n  // Run this effect callback whenever that action is dispatched\n  effect: async (action, listenerApi) => {\n    // Listener effect functions get a `listenerApi` object\n    // with many useful methods built in, including `delay`:\n    await listenerApi.delay(1000)\n    listenerApi.dispatch(pong())\n  },\n})\n// highlight-end\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/app/store.js"',title:'"src/app/store.js"'},"import { configureStore } from '@reduxjs/toolkit'\n\nimport { listenerMiddleware } from './listenerMiddleware'\n\n// omit reducers\n\nexport const store = configureStore({\n  reducer: rootReducer,\n  // Add the listener middleware _before_ the thunk or dev checks\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().prepend(listenerMiddleware.middleware),\n})\n")),(0,i.kt)("h3",{id:"migrating-typescript-for-redux-logic"},"Migrating TypeScript for Redux Logic"),(0,i.kt)("p",null,"Legacy Redux code that uses TypeScript typically follows ",(0,i.kt)("em",{parentName:"p"},"very"),' verbose patterns for defining types. In particular, many users in the community have decided to manually define TS types for each individual action, and then created "action type unions" that try to limit what specific actions can actually be passed to ',(0,i.kt)("inlineCode",{parentName:"p"},"dispatch"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"We specifically and strongly recommend ",(0,i.kt)("em",{parentName:"strong"},"against")," these patterns!")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/actions/todos.ts"',"no-transpile":!0,title:'"src/actions/todos.ts"'},"import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'\n\n// \u274c Common pattern: manually defining types for each action object\ninterface AddTodoAction {\n  type: typeof ADD_TODO\n  text: string\n  id: string\n}\n\ninterface ToggleTodoAction {\n  type: typeof TOGGLE_TODO\n  id: string\n}\n\n// \u274c Common pattern: an \"action type union\" of all possible actions\nexport type TodoActions = AddTodoAction | ToggleTodoAction\n\nexport const addTodo = (id: string, text: string): AddTodoAction => ({\n  type: ADD_TODO,\n  text,\n  id,\n})\n\nexport const toggleTodo = (id: string): ToggleTodoAction => ({\n  type: TOGGLE_TODO,\n  id,\n})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/reducers/todos.ts"',"no-transpile":!0,title:'"src/reducers/todos.ts"'},"import { ADD_TODO, TOGGLE_TODO, TodoActions } from '../constants/todos'\n\ninterface Todo {\n  id: string\n  text: string\n  completed: boolean\n}\n\nexport type TodosState = Todo[]\n\nconst initialState: TodosState = []\n\nexport default function todosReducer(\n  state = initialState,\n  action: TodoActions,\n) {\n  switch (action.type) {\n    // omit reducer logic\n    default:\n      return state\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/app/store.ts"',"no-transpile":!0,title:'"src/app/store.ts"'},"import { createStore, Dispatch } from 'redux'\n\nimport { TodoActions } from '../actions/todos'\nimport { CounterActions } from '../actions/counter'\nimport { TodosState } from '../reducers/todos'\nimport { CounterState } from '../reducers/counter'\n\n// omit reducer setup\n\nexport const store = createStore(rootReducer)\n\n// \u274c Common pattern: an \"action type union\" of all possible actions\nexport type RootAction = TodoActions | CounterActions\n// \u274c Common pattern: manually defining the root state type with each field\nexport interface RootState {\n  todos: TodosState\n  counter: CounterState\n}\n\n// \u274c Common pattern: limiting what can be dispatched at the types level\nexport type AppDispatch = Dispatch<RootAction>\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Redux Toolkit is designed to drastically simplify TS usage, and our recommendations include ",(0,i.kt)("em",{parentName:"strong"},"inferring")," types as much as possible!")),(0,i.kt)("p",null,"Per ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/typescript"},"our standard TypeScript setup and usage guidelines"),", start with setting up the store file to infer ",(0,i.kt)("inlineCode",{parentName:"p"},"AppDispatch")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"RootState")," types directly from the store itself. That will correctly include any modifications to ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch")," that were added by middleware, such as the ability to dispatch thunks, and update the ",(0,i.kt)("inlineCode",{parentName:"p"},"RootState")," type any time you modify a slice's state definition or add more slices."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="app/store.ts"',"no-transpile":!0,title:'"app/store.ts"'},"import { configureStore } from '@reduxjs/toolkit'\n// omit any other imports\n\nconst store = configureStore({\n  reducer: {\n    todos: todosReducer,\n    counter: counterReducer,\n  },\n})\n\n// highlight-start\n// Infer the `RootState` and `AppDispatch` types from the store itself\n\n// Inferred state type: {todos: TodosState, counter: CounterState}\nexport type RootState = ReturnType<typeof store.getState>\n\n// Inferred dispatch type: Dispatch & ThunkDispatch<RootState, undefined, UnknownAction>\nexport type AppDispatch = typeof store.dispatch\n// highlight-end\n")),(0,i.kt)("p",null,"Each slice file should declare and export a type for its own slice state. Then, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadAction")," type to declare the type of any ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," argument inside of ",(0,i.kt)("inlineCode",{parentName:"p"},"createSlice.reducers"),". The generated action creators will then ",(0,i.kt)("em",{parentName:"p"},"also")," have the correct type for the argument they accept, and the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"action.payload")," that they return."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/features/todos/todosSlice.ts"',"no-transpile":!0,title:'"src/features/todos/todosSlice.ts"'},"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\ninterface Todo {\n  id: string\n  text: string\n  completed: boolean\n}\n\n// highlight-start\n// Declare and export a type for the slice's state\nexport type TodosState = Todo[]\n\nconst initialState: TodosState = []\n// highlight-end\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  // The `state` argument type will be inferred for all case reducers\n  // from the type of `initialState`\n  initialState,\n  reducers: {\n    // highlight-start\n    // Use `PayloadAction<YourPayloadTypeHere>` for each `action` argument\n    todoAdded(state, action: PayloadAction<{ id: string; text: string }>) {\n      // omit logic\n    },\n    todoToggled(state, action: PayloadAction<string>) {\n      // omit logic\n    },\n    // highlight-end\n  },\n})\n")),(0,i.kt)("h2",{id:"modernizing-react-components-with-react-redux"},"Modernizing React Components with React-Redux"),(0,i.kt)("p",null,"The general approach to migrating React-Redux usage in components is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Migrate an existing React class component to be a function component"),(0,i.kt)("li",{parentName:"ul"},"Replace the ",(0,i.kt)("inlineCode",{parentName:"li"},"connect")," wrapper with uses of the ",(0,i.kt)("inlineCode",{parentName:"li"},"useSelector")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"useDispatch")," hooks ",(0,i.kt)("em",{parentName:"li"},"inside")," the component")),(0,i.kt)("p",null,"You can do this on an individual per-component basis. Components with ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," and with hooks can coexist at the same time."),(0,i.kt)("p",null,"This page won't cover the process of migrating class components to function components, but will focus on the changes specific to React-Redux."),(0,i.kt)("h3",{id:"migrating-connect-to-hooks"},"Migrating ",(0,i.kt)("inlineCode",{parentName:"h3"},"connect")," to Hooks"),(0,i.kt)("p",null,"A typical legacy component using React-Redux's ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," API might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/TodoListItem.js"',title:'"src/features/todos/TodoListItem.js"'},"import { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux'\nimport {\n  todoToggled,\n  todoDeleted,\n  selectTodoById,\n  selectActiveTodoId,\n} from './todosSlice'\n\n// A `mapState` function, possibly using values from `ownProps`,\n// and returning an object with multiple separate fields inside\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    todo: selectTodoById(state, ownProps.todoId),\n    activeTodoId: selectActiveTodoId(state),\n  }\n}\n\n// Several possible variations on how you might see `mapDispatch` written:\n\n// 1) a separate function, manual wrapping of `dispatch`\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    todoDeleted: (id) => dispatch(todoDeleted(id)),\n    todoToggled: (id) => dispatch(todoToggled(id)),\n  }\n}\n\n// 2) A separate function, wrapping with `bindActionCreators`\nconst mapDispatchToProps2 = (dispatch) => {\n  return bindActionCreators(\n    {\n      todoDeleted,\n      todoToggled,\n    },\n    dispatch,\n  )\n}\n\n// 3) An object full of action creators\nconst mapDispatchToProps3 = {\n  todoDeleted,\n  todoToggled,\n}\n\n// The component, which gets all these fields as props\nfunction TodoListItem({ todo, activeTodoId, todoDeleted, todoToggled }) {\n  // rendering logic here\n}\n\n// Finished with the call to `connect`\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoListItem)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"With the React-Redux hooks API, the ",(0,i.kt)("inlineCode",{parentName:"strong"},"connect")," call and ",(0,i.kt)("inlineCode",{parentName:"strong"},"mapState/mapDispatch")," arguments are replaced by hooks!")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each individual field returned in ",(0,i.kt)("inlineCode",{parentName:"li"},"mapState")," becomes a separate ",(0,i.kt)("inlineCode",{parentName:"li"},"useSelector")," call"),(0,i.kt)("li",{parentName:"ul"},"Each function passed in via ",(0,i.kt)("inlineCode",{parentName:"li"},"mapDispatch")," becomes a separate callback function defined inside the component")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/TodoListItem.js"',title:'"src/features/todos/TodoListItem.js"'},"import { useState } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport {\n  todoAdded,\n  todoToggled,\n  selectTodoById,\n  selectActiveTodoId,\n} from './todosSlice'\n\nexport function TodoListItem({ todoId }) {\n  // highlight-start\n  // Get the actual `dispatch` function with `useDispatch`\n  const dispatch = useDispatch()\n\n  // Select values from the state with `useSelector`\n  const activeTodoId = useSelector(selectActiveTodoId)\n  // Use prop in scope to select a specific value\n  const todo = useSelector((state) => selectTodoById(state, todoId))\n  // highlight-end\n\n  // Create callback functions that dispatch as needed, with arguments\n  const handleToggleClick = () => {\n    dispatch(todoToggled(todoId))\n  }\n\n  const handleDeleteClick = () => {\n    dispatch(todoDeleted(todoId))\n  }\n\n  // omit rendering logic\n}\n")),(0,i.kt)("p",null,"One thing that's different is that ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," optimized rendering performance by preventing the wrapped component from rendering unless its incoming ",(0,i.kt)("inlineCode",{parentName:"p"},"stateProps+dispatchProps+ownProps")," had changed. The hooks cannot do that, since they're ",(0,i.kt)("em",{parentName:"p"},"inside")," the component. If you need to prevent ",(0,i.kt)("a",{parentName:"p",href:"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#standard-render-behavior"},"React's normal recursive rendering behavior"),", wrap the component in ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo(MyComponent)")," yourself."),(0,i.kt)("h3",{id:"migrating-typescript-for-components"},"Migrating TypeScript for Components"),(0,i.kt)("p",null,"One of the major downsides with ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," is that it is ",(0,i.kt)("em",{parentName:"p"},"very")," hard to type correctly, and the type declarations end up being extremely verbose. This is due to it being a Higher-Order Component, and also the amount of flexibility in its API (four arguments, all optional, each with multiple possible overloads and variations)."),(0,i.kt)("p",null,"The community came up with multiple variations on how to handle this, with varying levels of complexity. On the low end, some usages required typing ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"mapState()"),", and then calculating the types of all the props for the component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="Simple connect TS example"',"no-transpile":!0,title:'"Simple',connect:!0,TS:!0,'example"':!0},"import { connect } from 'react-redux'\nimport { RootState } from '../../app/store'\nimport {\n  todoToggled,\n  todoDeleted,\n  selectTodoById,\n  selectActiveTodoId,\n} from './todosSlice'\n\ninterface TodoListItemOwnProps {\n  todoId: string\n}\n\nconst mapStateToProps = (state: RootState, ownProps) => {\n  return {\n    todo: selectTodoById(state, ownProps.todoId),\n    activeTodoId: selectActiveTodoId(state),\n  }\n}\n\nconst mapDispatchToProps = {\n  todoDeleted,\n  todoToggled,\n}\n\ntype TodoListItemProps = TodoListItemOwnProps &\n  ReturnType<typeof mapStateToProps> &\n  typeof mapDispatchToProps\n\nfunction TodoListItem({\n  todo,\n  activeTodoId,\n  todoDeleted,\n  todoToggled,\n}: TodoListItemProps) {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoListItem)\n")),(0,i.kt)("p",null,"The use of ",(0,i.kt)("inlineCode",{parentName:"p"},"typeof mapDispatch")," as an object in particular was dangerous, because it would fail if thunks were included."),(0,i.kt)("p",null,"Other community-created patterns required significantly more overhead, including declaring ",(0,i.kt)("inlineCode",{parentName:"p"},"mapDispatch")," as a function and calling ",(0,i.kt)("inlineCode",{parentName:"p"},"bindActionCreators")," in order to pass through a ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch: Dispatch<RootActions>")," type, or manually calculating the types of ",(0,i.kt)("em",{parentName:"p"},"all")," the props received by the wrapped component and passing those as generics to ",(0,i.kt)("inlineCode",{parentName:"p"},"connect"),"."),(0,i.kt)("p",null,"One slightly-better alternative was the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectedProps<T>")," type that was added to ",(0,i.kt)("inlineCode",{parentName:"p"},"@types/react-redux")," in v7.x, which enabled inferring the type of ",(0,i.kt)("em",{parentName:"p"},"all")," the props that would be passed to the component from ",(0,i.kt)("inlineCode",{parentName:"p"},"connect"),". This did require splitting up the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," into two parts for the inference to work right:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="ConnectedProps<T> TS example"',"no-transpile":!0,title:'"ConnectedProps<T>',TS:!0,'example"':!0},"import { connect, ConnectedProps } from 'react-redux'\nimport { RootState } from '../../app/store'\nimport {\n  todoToggled,\n  todoDeleted,\n  selectTodoById,\n  selectActiveTodoId,\n} from './todosSlice'\n\ninterface TodoListItemOwnProps {\n  todoId: string\n}\n\nconst mapStateToProps = (state: RootState, ownProps) => {\n  return {\n    todo: selectTodoById(state, ownProps.todoId),\n    activeTodoId: selectActiveTodoId(state),\n  }\n}\n\nconst mapDispatchToProps = {\n  todoDeleted,\n  todoToggled,\n}\n\n// Call the first part of `connect` to get the function that accepts the component.\n// This knows the types of the props returned by `mapState/mapDispatch`\nconst connector = connect(mapStateToProps, mapDispatchToProps)\n// The `ConnectedProps<T> util type can extract \"the type of all props from Redux\"\ntype PropsFromRedux = ConnectedProps<typeof connector>\n\n// The final component props are \"the props from Redux\" + \"props from the parent\"\ntype TodoListItemProps = PropsFromRedux & TodoListItemOwnProps\n\n// That type can then be used in the component\nfunction TodoListItem({\n  todo,\n  activeTodoId,\n  todoDeleted,\n  todoToggled,\n}: TodoListItemProps) {}\n\n// And the final wrapped component is generated and exported\nexport default connector(TodoListItem)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The React-Redux hooks API is ",(0,i.kt)("em",{parentName:"strong"},"much")," simpler to use with TypeScript!")," Instead of dealing with layers of component wrapping, type inference, and generics, the hooks are simple functions that take arguments and return a result. All that you need to pass around are the types for ",(0,i.kt)("inlineCode",{parentName:"p"},"RootState")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AppDispatch"),"."),(0,i.kt)("p",null,"Per ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/typescript"},"our standard TypeScript setup and usage guidelines"),', we specifically teach setting up "pre-typed" aliases for the hooks, so that those have the correct types baked in, and only use those pre-typed hooks in the app.'),(0,i.kt)("p",null,"First, set up the hooks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/app/hooks.ts"',"no-transpile":!0,title:'"src/app/hooks.ts"'},"import { useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\n\n// highlight-start\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>()\nexport const useAppSelector = useSelector.withTypes<RootState>()\n// highlight-end\n")),(0,i.kt)("p",null,"Then, use them in your components:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="src/features/todos/TodoListItem.tsx"',"no-transpile":!0,title:'"src/features/todos/TodoListItem.tsx"'},"import { useAppSelector, useAppDispatch } from '../../app/hooks'\nimport {\n  todoToggled,\n  todoDeleted,\n  selectTodoById,\n  selectActiveTodoId,\n} from './todosSlice'\n\ninterface TodoListItemProps {\n  todoId: string\n}\n\nfunction TodoListItem({ todoId }: TodoListItemProps) {\n  // highlight-start\n  // Use the pre-typed hooks in the component\n  const dispatch = useAppDispatch()\n  const activeTodoId = useAppSelector(selectActiveTodoId)\n  const todo = useAppSelector((state) => selectTodoById(state, todoId))\n  // highlight-end\n\n  // omit event handlers and rendering logic\n}\n")),(0,i.kt)("h2",{id:"further-information"},"Further Information"),(0,i.kt)("p",null,"See these docs pages and blog posts for more details:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Tutorials"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/tutorials/essentials/part-2-app-structure"},"Redux Essentials: Redux Toolkit App Structure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/tutorials/fundamentals/part-8-modern-redux"},"Redux Fundamentals: Modern Redux with Redux Toolkit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/tutorials/typescript"},"Redux TypeScript Quick Start")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Additional Documentation"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/introduction/why-rtk-is-redux-today"},"Why Redux Toolkit is How to use Redux Today")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/style-guide/"},"Redux Style Guide: Best Practices and Recommendations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://redux.js.org/usage/usage-with-typescript"},"Redux core: Usage with TypeScript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/usage/usage-with-typescript"},"Redux Toolkit: Usage with TypeScript")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Articles"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2022/06/presentations-modern-redux-rtk/"},"Presentation: Modern Redux with Redux Toolkit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2019/10/redux-toolkit-1.0/"},"Mark Erikson: Redux Toolkit 1.0 Announcement and development history")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://phryneas.de/redux-typescript-no-discriminating-union"},"Lenz Weber: Do Not Create Action Type Unions"))))))}g.isMDXComponent=!0},5318:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var o=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return n?o.createElement(h,i(i({ref:t},c),{},{components:n})):o.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);